{"version":3,"file":"extensions_cornerstone_src_Viewport_OHIFCornerstoneViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AAYA;AAEA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAIA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AAMA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAMA;AAKA;AAEA;AACA;AAEA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AAIA;AACA;AACA;AAOA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAUA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAMA;AAEA;AASA;AAGA;AAAA;AAAA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AASA;AAGA;AACA;;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AASA;AACA;AACA;AAEA;AASA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;;AAIA;AACA;AACA;;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AAAA;AAAA;;AAEA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhsBA;AAMA;AAEA;AAwEA;AAgbA;AA6CA;AAoCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChnBA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAIA;AAAA;AAzEA;AA2EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AAUA;AAEA;AA0BA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;AAAA;AAKA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAGA;;AAEA;AACA;AACA;AACA;AAIA;AAHA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAOA;;AAEA;AACA;AACA;AACA;AAMA;AALA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAGA;AAGA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAIA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAeA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAAA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAAA;AAIA;AAEA;AACA;AACA;AAGA;AAAA;AAMA;AAEA;AACA;AACA;AAGA;AAAA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1dA;AA6BA;AA0BA;AAeA;AAyBA;AAwQA;AAcA;AAyBA;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtbA;AACA;AACA;AACA;AACA;AAGA;AAQA;AAPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAIA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAKA;AACA;AAKA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AASA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AAOA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAOA;AANA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAKA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAQA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAIA;AAEA;AAIA;AAAA;AAEA;AAAA;AAGA;AAUA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3NA;AACA;AAGA;AA4JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChLA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxFA;AAWA;AAaA;AAiBA;AAUA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/OHIFCornerstoneViewport.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/CornerstoneOverlays.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/CustomizableViewportOverlay.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/ViewportImageScrollbar.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/ViewportImageSliceLoadingIndicator.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/ViewportOrientationMarkers.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/utils.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/OHIFCornerstoneViewport.css","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/CustomizableViewportOverlay.css","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/Viewport/Overlays/ViewportOrientationMarkers.css","webpack:///../../../extensions/cornerstone/src/Viewport/OHIFCornerstoneViewport.css?bf30","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/CustomizableViewportOverlay.css?3d2d","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/ViewportOrientationMarkers.css?1327"],"sourcesContent":["import React, { useEffect, useRef, useCallback, useState } from 'react';\nimport ReactResizeDetector from 'react-resize-detector';\nimport PropTypes from 'prop-types';\nimport * as cs3DTools from '@cornerstonejs/tools';\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { MeasurementService } from '@ohif/core';\nimport {\n  CinePlayer,\n  useCine,\n  useViewportGrid,\n  Notification,\n  useViewportDialog,\n} from '@ohif/ui';\nimport {\n  IStackViewport,\n  IVolumeViewport,\n} from '@cornerstonejs/core/dist/esm/types';\n\nimport { setEnabledElement } from '../state';\n\nimport './OHIFCornerstoneViewport.css';\nimport CornerstoneOverlays from './Overlays/CornerstoneOverlays';\nimport getSOPInstanceAttributes from '../utils/measurementServiceMappings/utils/getSOPInstanceAttributes';\nimport CornerstoneServices from '../types/CornerstoneServices';\n\nconst STACK = 'stack';\n\n/**\n * Caches the jump to measurement operation, so that if display set is shown,\n * it can jump to the measurement.\n */\nlet cacheJumpToMeasurementEvent;\n\nfunction areEqual(prevProps, nextProps) {\n  if (nextProps.needsRerendering) {\n    return false;\n  }\n\n  if (prevProps.displaySets.length !== nextProps.displaySets.length) {\n    return false;\n  }\n\n  if (\n    prevProps.viewportOptions.orientation !==\n    nextProps.viewportOptions.orientation\n  ) {\n    return false;\n  }\n\n  if (\n    prevProps.viewportOptions.toolGroupId !==\n    nextProps.viewportOptions.toolGroupId\n  ) {\n    return false;\n  }\n\n  if (\n    prevProps.viewportOptions.viewportType !==\n    nextProps.viewportOptions.viewportType\n  ) {\n    return false;\n  }\n\n  const prevDisplaySets = prevProps.displaySets;\n  const nextDisplaySets = nextProps.displaySets;\n\n  if (prevDisplaySets.length !== nextDisplaySets.length) {\n    return false;\n  }\n\n  for (let i = 0; i < prevDisplaySets.length; i++) {\n    const prevDisplaySet = prevDisplaySets[i];\n\n    const foundDisplaySet = nextDisplaySets.find(\n      nextDisplaySet =>\n        nextDisplaySet.displaySetInstanceUID ===\n        prevDisplaySet.displaySetInstanceUID\n    );\n\n    if (!foundDisplaySet) {\n      return false;\n    }\n\n    // check they contain the same image\n    if (foundDisplaySet.images?.length !== prevDisplaySet.images?.length) {\n      return false;\n    }\n\n    // check if their imageIds are the same\n    if (foundDisplaySet.images?.length) {\n      for (let j = 0; j < foundDisplaySet.images.length; j++) {\n        if (\n          foundDisplaySet.images[j].imageId !== prevDisplaySet.images[j].imageId\n        ) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n// Todo: This should be done with expose of internal API similar to react-vtkjs-viewport\n// Then we don't need to worry about the re-renders if the props change.\nconst OHIFCornerstoneViewport = React.memo(props => {\n  const {\n    viewportIndex,\n    displaySets,\n    dataSource,\n    viewportOptions,\n    displaySetOptions,\n    servicesManager,\n    onElementEnabled,\n    onElementDisabled,\n    // Note: you SHOULD NOT use the initialImageIdOrIndex for manipulation\n    // of the imageData in the OHIFCornerstoneViewport. This prop is used\n    // to set the initial state of the viewport's first image to render\n    initialImageIndex,\n  } = props;\n\n  const [scrollbarHeight, setScrollbarHeight] = useState('100px');\n  const [{ isCineEnabled, cines }, cineService] = useCine();\n  const [{ activeViewportIndex }] = useViewportGrid();\n  const [enabledVPElement, setEnabledVPElement] = useState(null);\n\n  const elementRef = useRef();\n\n  const {\n    measurementService,\n    displaySetService,\n    toolbarService,\n    toolGroupService,\n    syncGroupService,\n    cornerstoneViewportService,\n    cornerstoneCacheService,\n    viewportGridService,\n    stateSyncService,\n  } = servicesManager.services as CornerstoneServices;\n\n  const [viewportDialogState] = useViewportDialog();\n\n  const cineHandler = () => {\n    if (!cines || !cines[viewportIndex] || !enabledVPElement) {\n      return;\n    }\n\n    const cine = cines[viewportIndex];\n    const isPlaying = cine.isPlaying || false;\n    const frameRate = cine.frameRate || 24;\n\n    const validFrameRate = Math.max(frameRate, 1);\n\n    if (isPlaying) {\n      cineService.playClip(enabledVPElement, {\n        framesPerSecond: validFrameRate,\n      });\n    } else {\n      cineService.stopClip(enabledVPElement);\n    }\n  };\n\n  useEffect(() => {\n    eventTarget.addEventListener(\n      Enums.Events.STACK_VIEWPORT_NEW_STACK,\n      cineHandler\n    );\n\n    return () => {\n      cineService.setCine({ id: viewportIndex, isPlaying: false });\n      eventTarget.removeEventListener(\n        Enums.Events.STACK_VIEWPORT_NEW_STACK,\n        cineHandler\n      );\n    };\n  }, [enabledVPElement]);\n\n  useEffect(() => {\n    if (!cines || !cines[viewportIndex] || !enabledVPElement) {\n      return;\n    }\n\n    cineHandler();\n\n    return () => {\n      if (enabledVPElement && cines?.[viewportIndex]?.isPlaying) {\n        cineService.stopClip(enabledVPElement);\n      }\n    };\n  }, [cines, viewportIndex, cineService, enabledVPElement, cineHandler]);\n\n  const cine = cines[viewportIndex];\n  const isPlaying = (cine && cine.isPlaying) || false;\n\n  const handleCineClose = () => {\n    toolbarService.recordInteraction({\n      groupId: 'MoreTools',\n      itemId: 'cine',\n      interactionType: 'toggle',\n      commands: [\n        {\n          commandName: 'toggleCine',\n          commandOptions: {},\n          context: 'CORNERSTONE',\n        },\n      ],\n    });\n  };\n\n  // useCallback for scroll bar height calculation\n  const setImageScrollBarHeight = useCallback(() => {\n    const scrollbarHeight = `${elementRef.current.clientHeight - 20}px`;\n    setScrollbarHeight(scrollbarHeight);\n  }, [elementRef]);\n\n  // useCallback for onResize\n  const onResize = useCallback(() => {\n    if (elementRef.current) {\n      cornerstoneViewportService.resize();\n      setImageScrollBarHeight();\n    }\n  }, [elementRef]);\n\n  const storePresentation = () => {\n    const currentPresentation = cornerstoneViewportService.getPresentation(\n      viewportIndex\n    );\n    if (!currentPresentation || !currentPresentation.presentationIds) return;\n    const {\n      lutPresentationStore,\n      positionPresentationStore,\n    } = stateSyncService.getState();\n    const { presentationIds } = currentPresentation;\n    const { lutPresentationId, positionPresentationId } = presentationIds || {};\n    const storeState = {};\n    if (lutPresentationId) {\n      storeState.lutPresentationStore = {\n        ...lutPresentationStore,\n        [lutPresentationId]: currentPresentation,\n      };\n    }\n    if (positionPresentationId) {\n      storeState.positionPresentationStore = {\n        ...positionPresentationStore,\n        [positionPresentationId]: currentPresentation,\n      };\n    }\n    stateSyncService.store(storeState);\n  };\n\n  const cleanUpServices = useCallback(() => {\n    const viewportInfo = cornerstoneViewportService.getViewportInfoByIndex(\n      viewportIndex\n    );\n\n    if (!viewportInfo) {\n      return;\n    }\n\n    const viewportId = viewportInfo.getViewportId();\n    const renderingEngineId = viewportInfo.getRenderingEngineId();\n    const syncGroups = viewportInfo.getSyncGroups();\n\n    toolGroupService.removeViewportFromToolGroup(viewportId, renderingEngineId);\n\n    syncGroupService.removeViewportFromSyncGroup(\n      viewportId,\n      renderingEngineId,\n      syncGroups\n    );\n  }, [viewportIndex, viewportOptions.viewportId]);\n\n  const elementEnabledHandler = useCallback(\n    evt => {\n      // check this is this element reference and return early if doesn't match\n      if (evt.detail.element !== elementRef.current) {\n        return;\n      }\n\n      const { viewportId, element } = evt.detail;\n      const viewportInfo = cornerstoneViewportService.getViewportInfo(\n        viewportId\n      );\n      const viewportIndex = viewportInfo.getViewportIndex();\n\n      setEnabledElement(viewportIndex, element);\n      setEnabledVPElement(element);\n\n      const renderingEngineId = viewportInfo.getRenderingEngineId();\n      const toolGroupId = viewportInfo.getToolGroupId();\n      const syncGroups = viewportInfo.getSyncGroups();\n\n      toolGroupService.addViewportToToolGroup(\n        viewportId,\n        renderingEngineId,\n        toolGroupId\n      );\n\n      syncGroupService.addViewportToSyncGroup(\n        viewportId,\n        renderingEngineId,\n        syncGroups\n      );\n\n      if (onElementEnabled) {\n        onElementEnabled(evt);\n      }\n    },\n    [viewportIndex, onElementEnabled, toolGroupService]\n  );\n\n  // disable the element upon unmounting\n  useEffect(() => {\n    cornerstoneViewportService.enableViewport(\n      viewportIndex,\n      viewportOptions,\n      elementRef.current\n    );\n\n    eventTarget.addEventListener(\n      Enums.Events.ELEMENT_ENABLED,\n      elementEnabledHandler\n    );\n\n    setImageScrollBarHeight();\n\n    return () => {\n      storePresentation();\n\n      cleanUpServices();\n\n      const viewportInfo = cornerstoneViewportService.getViewportInfoByIndex(\n        viewportIndex\n      );\n\n      cornerstoneViewportService.disableElement(viewportIndex);\n\n      if (onElementDisabled) {\n        onElementDisabled(viewportInfo);\n      }\n\n      eventTarget.removeEventListener(\n        Enums.Events.ELEMENT_ENABLED,\n        elementEnabledHandler\n      );\n    };\n  }, []);\n\n  // subscribe to displaySet metadata invalidation (updates)\n  // Currently, if the metadata changes we need to re-render the display set\n  // for it to take effect in the viewport. As we deal with scaling in the loading,\n  // we need to remove the old volume from the cache, and let the\n  // viewport to re-add it which will use the new metadata. Otherwise, the\n  // viewport will use the cached volume and the new metadata will not be used.\n  // Note: this approach does not actually end of sending network requests\n  // and it uses the network cache\n  useEffect(() => {\n    const { unsubscribe } = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SET_SERIES_METADATA_INVALIDATED,\n      async invalidatedDisplaySetInstanceUID => {\n        const viewportInfo = cornerstoneViewportService.getViewportInfoByIndex(\n          viewportIndex\n        );\n\n        if (viewportInfo.hasDisplaySet(invalidatedDisplaySetInstanceUID)) {\n          const viewportData = viewportInfo.getViewportData();\n          const newViewportData = await cornerstoneCacheService.invalidateViewportData(\n            viewportData,\n            invalidatedDisplaySetInstanceUID,\n            dataSource,\n            displaySetService\n          );\n\n          const keepCamera = true;\n          cornerstoneViewportService.updateViewport(\n            viewportIndex,\n            newViewportData,\n            keepCamera\n          );\n        }\n      }\n    );\n    return () => {\n      unsubscribe();\n    };\n  }, [viewportIndex]);\n\n  useEffect(() => {\n    // handle the default viewportType to be stack\n    if (!viewportOptions.viewportType) {\n      viewportOptions.viewportType = STACK;\n    }\n\n    const loadViewportData = async () => {\n      const viewportData = await cornerstoneCacheService.createViewportData(\n        displaySets,\n        viewportOptions,\n        dataSource,\n        initialImageIndex\n      );\n\n      // The presentation state will have been stored previously by closing\n      // a viewport.  Otherwise, this viewport will be unchanged and the\n      // presentation information will be directly carried over.\n      const {\n        lutPresentationStore,\n        positionPresentationStore,\n      } = stateSyncService.getState();\n      const { presentationIds } = viewportOptions;\n      const presentations = {\n        positionPresentation:\n          positionPresentationStore[presentationIds?.positionPresentationId],\n        lutPresentation:\n          lutPresentationStore[presentationIds?.lutPresentationId],\n      };\n      let measurement;\n      if (cacheJumpToMeasurementEvent?.viewportIndex === viewportIndex) {\n        measurement = cacheJumpToMeasurementEvent.measurement;\n        // Delete the position presentation so that viewport navigates direct\n        presentations.positionPresentation = null;\n        cacheJumpToMeasurementEvent = null;\n      }\n\n      cornerstoneViewportService.setViewportData(\n        viewportIndex,\n        viewportData,\n        viewportOptions,\n        displaySetOptions,\n        presentations\n      );\n\n      if (measurement) {\n        cs3DTools.annotation.selection.setAnnotationSelected(measurement.uid);\n      }\n    };\n\n    loadViewportData();\n  }, [viewportOptions, displaySets, dataSource]);\n\n  /**\n   * There are two scenarios for jump to click\n   * 1. Current viewports contain the displaySet that the annotation was drawn on\n   * 2. Current viewports don't contain the displaySet that the annotation was drawn on\n   * and we need to change the viewports displaySet for jumping.\n   * Since measurement_jump happens via events and listeners, the former case is handled\n   * by the measurement_jump direct callback, but the latter case is handled first by\n   * the viewportGrid to set the correct displaySet on the viewport, AND THEN we check\n   * the cache for jumping to see if there is any jump queued, then we jump to the correct slice.\n   */\n  useEffect(() => {\n    const unsubscribeFromJumpToMeasurementEvents = _subscribeToJumpToMeasurementEvents(\n      measurementService,\n      displaySetService,\n      elementRef,\n      viewportIndex,\n      displaySets,\n      viewportGridService,\n      cornerstoneViewportService\n    );\n\n    _checkForCachedJumpToMeasurementEvents(\n      measurementService,\n      displaySetService,\n      elementRef,\n      viewportIndex,\n      displaySets,\n      viewportGridService,\n      cornerstoneViewportService\n    );\n\n    return () => {\n      unsubscribeFromJumpToMeasurementEvents();\n    };\n  }, [displaySets, elementRef, viewportIndex]);\n\n  return (\n    <React.Fragment>\n      <div className=\"viewport-wrapper\">\n        <ReactResizeDetector\n          handleWidth\n          handleHeight\n          skipOnMount={true} // Todo: make these configurable\n          refreshMode={'debounce'}\n          refreshRate={200} // transition amount in side panel\n          onResize={onResize}\n          targetRef={elementRef.current}\n        />\n        <div\n          className=\"cornerstone-viewport-element\"\n          style={{ height: '100%', width: '100%' }}\n          onContextMenu={e => e.preventDefault()}\n          onMouseDown={e => e.preventDefault()}\n          ref={elementRef}\n        ></div>\n        <CornerstoneOverlays\n          viewportIndex={viewportIndex}\n          toolBarService={toolbarService}\n          element={elementRef.current}\n          scrollbarHeight={scrollbarHeight}\n          servicesManager={servicesManager}\n        />\n        {isCineEnabled && (\n          <CinePlayer\n            className=\"absolute left-1/2 -translate-x-1/2 bottom-3\"\n            isPlaying={isPlaying}\n            onClose={handleCineClose}\n            onPlayPauseChange={isPlaying =>\n              cineService.setCine({\n                id: activeViewportIndex,\n                isPlaying,\n              })\n            }\n            onFrameRateChange={frameRate =>\n              cineService.setCine({\n                id: activeViewportIndex,\n                frameRate,\n              })\n            }\n          />\n        )}\n      </div>\n      <div className=\"absolute w-full\">\n        {viewportDialogState.viewportIndex === viewportIndex && (\n          <Notification\n            id=\"viewport-notification\"\n            message={viewportDialogState.message}\n            type={viewportDialogState.type}\n            actions={viewportDialogState.actions}\n            onSubmit={viewportDialogState.onSubmit}\n            onOutsideClick={viewportDialogState.onOutsideClick}\n          />\n        )}\n      </div>\n    </React.Fragment>\n  );\n}, areEqual);\n\nfunction _subscribeToJumpToMeasurementEvents(\n  measurementService,\n  displaySetService,\n  elementRef,\n  viewportIndex,\n  displaySets,\n  viewportGridService,\n  cornerstoneViewportService\n) {\n  const displaysUIDs = displaySets.map(\n    displaySet => displaySet.displaySetInstanceUID\n  );\n  const { unsubscribe } = measurementService.subscribe(\n    MeasurementService.EVENTS.JUMP_TO_MEASUREMENT_VIEWPORT,\n    props => {\n      cacheJumpToMeasurementEvent = props;\n      const { viewportIndex: jumpIndex, measurement, isConsumed } = props;\n      if (!measurement || isConsumed) return;\n      if (cacheJumpToMeasurementEvent.cornerstoneViewport === undefined) {\n        // Decide on which viewport should handle this\n        cacheJumpToMeasurementEvent.cornerstoneViewport = cornerstoneViewportService.getViewportIndexToJump(\n          jumpIndex,\n          measurement.displaySetInstanceUID,\n          { referencedImageId: measurement.referencedImageId }\n        );\n      }\n      if (cacheJumpToMeasurementEvent.cornerstoneViewport !== viewportIndex) {\n        return;\n      }\n      _jumpToMeasurement(\n        measurement,\n        elementRef,\n        viewportIndex,\n        measurementService,\n        displaySetService,\n        viewportGridService,\n        cornerstoneViewportService\n      );\n    }\n  );\n\n  return unsubscribe;\n}\n\n// Check if there is a queued jumpToMeasurement event\nfunction _checkForCachedJumpToMeasurementEvents(\n  measurementService,\n  displaySetService,\n  elementRef,\n  viewportIndex,\n  displaySets,\n  viewportGridService,\n  cornerstoneViewportService\n) {\n  if (!cacheJumpToMeasurementEvent) return;\n  if (cacheJumpToMeasurementEvent.isConsumed) {\n    cacheJumpToMeasurementEvent = null;\n    return;\n  }\n  const displaysUIDs = displaySets.map(\n    displaySet => displaySet.displaySetInstanceUID\n  );\n  if (!displaysUIDs?.length) return;\n\n  // Jump to measurement if the measurement exists\n  const { measurement } = cacheJumpToMeasurementEvent;\n  if (measurement && elementRef) {\n    if (displaysUIDs.includes(measurement?.displaySetInstanceUID)) {\n      _jumpToMeasurement(\n        measurement,\n        elementRef,\n        viewportIndex,\n        measurementService,\n        displaySetService,\n        viewportGridService,\n        cornerstoneViewportService\n      );\n    }\n  }\n}\n\nfunction _jumpToMeasurement(\n  measurement,\n  targetElementRef,\n  viewportIndex,\n  measurementService,\n  displaySetService,\n  viewportGridService,\n  cornerstoneViewportService\n) {\n  const targetElement = targetElementRef.current;\n  const { displaySetInstanceUID, SOPInstanceUID, frameNumber } = measurement;\n\n  if (!SOPInstanceUID) {\n    console.warn('cannot jump in a non-acquisition plane measurements yet');\n    return;\n  }\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\n    displaySetInstanceUID\n  );\n\n  // Todo: setCornerstoneMeasurementActive should be handled by the toolGroupManager\n  //  to set it properly\n  // setCornerstoneMeasurementActive(measurement);\n\n  viewportGridService.setActiveViewportIndex(viewportIndex);\n\n  const enabledElement = getEnabledElement(targetElement);\n\n  const viewportInfo = cornerstoneViewportService.getViewportInfoByIndex(\n    viewportIndex\n  );\n\n  if (enabledElement) {\n    // See how the jumpToSlice() of Cornerstone3D deals with imageIdx param.\n    const viewport = enabledElement.viewport as\n      | IStackViewport\n      | IVolumeViewport;\n\n    let imageIdIndex = 0;\n    let viewportCameraDirectionMatch = true;\n\n    if (viewport instanceof StackViewport) {\n      const imageIds = viewport.getImageIds();\n      imageIdIndex = imageIds.findIndex(imageId => {\n        const {\n          SOPInstanceUID: aSOPInstanceUID,\n          frameNumber: aFrameNumber,\n        } = getSOPInstanceAttributes(imageId);\n        return (\n          aSOPInstanceUID === SOPInstanceUID &&\n          (!frameNumber || frameNumber === aFrameNumber)\n        );\n      });\n    } else {\n      // for volume viewport we can't rely on the imageIdIndex since it can be\n      // a reconstructed view that doesn't match the original slice numbers etc.\n      const { viewPlaneNormal: measurementViewPlane } = measurement.metadata;\n      imageIdIndex = referencedDisplaySet.images.findIndex(\n        i => i.SOPInstanceUID === SOPInstanceUID\n      );\n\n      const { viewPlaneNormal: viewportViewPlane } = viewport.getCamera();\n\n      // should compare abs for both planes since the direction can be flipped\n      if (\n        measurementViewPlane &&\n        !csUtils.isEqual(\n          measurementViewPlane.map(Math.abs),\n          viewportViewPlane.map(Math.abs)\n        )\n      ) {\n        viewportCameraDirectionMatch = false;\n      }\n    }\n\n    if (!viewportCameraDirectionMatch || imageIdIndex === -1) {\n      return;\n    }\n\n    cs3DTools.utilities.jumpToSlice(targetElement, {\n      imageIndex: imageIdIndex,\n    });\n\n    cs3DTools.annotation.selection.setAnnotationSelected(measurement.uid);\n    // Jump to measurement consumed, remove.\n    cacheJumpToMeasurementEvent?.consume?.();\n    cacheJumpToMeasurementEvent = null;\n  }\n}\n\n// Component displayName\nOHIFCornerstoneViewport.displayName = 'OHIFCornerstoneViewport';\n\nOHIFCornerstoneViewport.propTypes = {\n  viewportIndex: PropTypes.number.isRequired,\n  displaySets: PropTypes.array.isRequired,\n  dataSource: PropTypes.object.isRequired,\n  viewportOptions: PropTypes.object,\n  displaySetOptions: PropTypes.arrayOf(PropTypes.any),\n  servicesManager: PropTypes.object.isRequired,\n  onElementEnabled: PropTypes.func,\n  // Note: you SHOULD NOT use the initialImageIdOrIndex for manipulation\n  // of the imageData in the OHIFCornerstoneViewport. This prop is used\n  // to set the initial state of the viewport's first image to render\n  initialImageIdOrIndex: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n  ]),\n};\n\nexport default OHIFCornerstoneViewport;\n","import React, { useEffect, useState } from 'react';\n\nimport ViewportImageScrollbar from './ViewportImageScrollbar';\nimport CustomizableViewportOverlay from './CustomizableViewportOverlay';\nimport ViewportOrientationMarkers from './ViewportOrientationMarkers';\nimport ViewportImageSliceLoadingIndicator from './ViewportImageSliceLoadingIndicator';\n\nfunction CornerstoneOverlays(props) {\n  const { viewportIndex, element, scrollbarHeight, servicesManager } = props;\n  const { cornerstoneViewportService } = servicesManager.services;\n  const [imageSliceData, setImageSliceData] = useState({\n    imageIndex: 0,\n    numberOfSlices: 0,\n  });\n  const [viewportData, setViewportData] = useState(null);\n\n  useEffect(() => {\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n      props => {\n        if (props.viewportIndex !== viewportIndex) {\n          return;\n        }\n\n        setViewportData(props.viewportData);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [viewportIndex]);\n\n  if (!element) {\n    return null;\n  }\n\n  if (viewportData) {\n    const viewportInfo =\n      cornerstoneViewportService.getViewportInfoByIndex(viewportIndex);\n\n    if (viewportInfo?.viewportOptions?.customViewportProps?.hideOverlays) {\n      return null;\n    }\n  }\n\n  return (\n    <div className=\"noselect\">\n      <ViewportImageScrollbar\n        viewportIndex={viewportIndex}\n        viewportData={viewportData}\n        element={element}\n        imageSliceData={imageSliceData}\n        setImageSliceData={setImageSliceData}\n        scrollbarHeight={scrollbarHeight}\n        servicesManager={servicesManager}\n      />\n\n      <CustomizableViewportOverlay\n        imageSliceData={imageSliceData}\n        viewportData={viewportData}\n        viewportIndex={viewportIndex}\n        servicesManager={servicesManager}\n        element={element}\n      />\n\n      <ViewportImageSliceLoadingIndicator\n        viewportData={viewportData}\n        element={element}\n      />\n\n      <ViewportOrientationMarkers\n        imageSliceData={imageSliceData}\n        element={element}\n        viewportData={viewportData}\n        servicesManager={servicesManager}\n        viewportIndex={viewportIndex}\n      />\n    </div>\n  );\n}\n\nexport default CornerstoneOverlays;\n","import React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport { vec3 } from 'gl-matrix';\nimport PropTypes from 'prop-types';\nimport { metaData, Enums, utilities } from '@cornerstonejs/core';\nimport { ViewportOverlay } from '@ohif/ui';\nimport {\n  formatPN,\n  formatDICOMDate,\n  formatDICOMTime,\n  formatNumberPrecision,\n} from './utils';\nimport { InstanceMetadata } from 'platform/core/src/types';\nimport { ServicesManager } from '@ohif/core';\nimport { ImageSliceData } from '@cornerstonejs/core/dist/esm/types';\n\nimport './CustomizableViewportOverlay.css';\n\nconst EPSILON = 1e-4;\n\ninterface OverlayItemProps {\n  element: any;\n  viewportData: any;\n  imageSliceData: ImageSliceData;\n  viewportIndex: number | null;\n  servicesManager: ServicesManager;\n  instance: InstanceMetadata;\n  customization: any;\n  formatters: {\n    formatPN: (val) => string;\n    formatDate: (val) => string;\n    formatTime: (val) => string;\n    formatNumberPrecision: (val, number) => string;\n  };\n\n  // calculated values\n  voi: {\n    windowWidth: number;\n    windowCenter: number;\n  };\n  instanceNumber?: number;\n  scale?: number;\n}\n\n/**\n * Window Level / Center Overlay item\n */\nfunction VOIOverlayItem({ voi, customization }: OverlayItemProps) {\n  const { windowWidth, windowCenter } = voi;\n  if (typeof windowCenter !== 'number' || typeof windowWidth !== 'number') {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span className=\"mr-1 shrink-0\">W:</span>\n      <span className=\"ml-1 mr-2 font-light shrink-0\">\n        {windowWidth.toFixed(0)}\n      </span>\n      <span className=\"mr-1 shrink-0\">L:</span>\n      <span className=\"ml-1 font-light shrink-0\">\n        {windowCenter.toFixed(0)}\n      </span>\n    </div>\n  );\n}\n\n/**\n * Zoom Level Overlay item\n */\nfunction ZoomOverlayItem({ scale, customization }: OverlayItemProps) {\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span className=\"mr-1 shrink-0\">Zoom:</span>\n      <span className=\"font-light\">{scale.toFixed(2)}x</span>\n    </div>\n  );\n}\n\n/**\n * Instance Number Overlay Item\n */\nfunction InstanceNumberOverlayItem({\n  instanceNumber,\n  imageSliceData,\n  customization,\n}: OverlayItemProps) {\n  const { imageIndex, numberOfSlices } = imageSliceData;\n\n  return (\n    <div\n      className=\"overlay-item flex flex-row\"\n      style={{ color: (customization && customization.color) || undefined }}\n    >\n      <span className=\"mr-1 shrink-0\">I:</span>\n      <span className=\"font-light\">\n        {instanceNumber !== undefined && instanceNumber !== null\n          ? `${instanceNumber} (${imageIndex + 1}/${numberOfSlices})`\n          : `${imageIndex + 1}/${numberOfSlices}`}\n      </span>\n    </div>\n  );\n}\n\n/**\n * Customizable Viewport Overlay\n */\nfunction CustomizableViewportOverlay({\n  element,\n  viewportData,\n  imageSliceData,\n  viewportIndex,\n  servicesManager,\n}) {\n  const {\n    toolbarService,\n    cornerstoneViewportService,\n    customizationService,\n  } = servicesManager.services;\n  const [voi, setVOI] = useState({ windowCenter: null, windowWidth: null });\n  const [scale, setScale] = useState(1);\n  const [activeTools, setActiveTools] = useState([]);\n  const { imageIndex } = imageSliceData;\n\n  const topLeftCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayTopLeft'\n  );\n  const topRightCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayTopRight'\n  );\n  const bottomLeftCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayBottomLeft'\n  );\n  const bottomRightCustomization = customizationService.getModeCustomization(\n    'cornerstoneOverlayBottomRight'\n  );\n\n  const instance = useMemo(() => {\n    if (viewportData != null) {\n      return _getViewportInstance(viewportData, imageIndex);\n    } else {\n      return null;\n    }\n  }, [viewportData, imageIndex]);\n\n  const instanceNumber = useMemo(() => {\n    if (viewportData != null) {\n      return _getInstanceNumber(\n        viewportData,\n        viewportIndex,\n        imageIndex,\n        cornerstoneViewportService\n      );\n    }\n    return null;\n  }, [viewportData, viewportIndex, imageIndex, cornerstoneViewportService]);\n\n  /**\n   * Initial toolbar state\n   */\n  useEffect(() => {\n    setActiveTools(toolbarService.getActiveTools());\n  }, []);\n\n  /**\n   * Updating the VOI when the viewport changes its voi\n   */\n  useEffect(() => {\n    const updateVOI = eventDetail => {\n      const { range } = eventDetail.detail;\n\n      if (!range) {\n        return;\n      }\n\n      const { lower, upper } = range;\n      const { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n        lower,\n        upper\n      );\n\n      setVOI({ windowCenter, windowWidth });\n    };\n\n    element.addEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\n\n    return () => {\n      element.removeEventListener(Enums.Events.VOI_MODIFIED, updateVOI);\n    };\n  }, [viewportIndex, viewportData, voi, element]);\n\n  /**\n   * Updating the scale when the viewport changes its zoom\n   */\n  useEffect(() => {\n    const updateScale = eventDetail => {\n      const { previousCamera, camera } = eventDetail.detail;\n\n      if (\n        previousCamera.parallelScale !== camera.parallelScale ||\n        previousCamera.scale !== camera.scale\n      ) {\n        const viewport = cornerstoneViewportService.getCornerstoneViewportByIndex(\n          viewportIndex\n        );\n\n        if (!viewport) {\n          return;\n        }\n\n        const imageData = viewport.getImageData();\n\n        if (!imageData) {\n          return;\n        }\n\n        if (camera.scale) {\n          setScale(camera.scale);\n          return;\n        }\n\n        const { spacing } = imageData;\n        // convert parallel scale to scale\n        const scale =\n          (element.clientHeight * spacing[0] * 0.5) / camera.parallelScale;\n        setScale(scale);\n      }\n    };\n\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\n\n    return () => {\n      element.removeEventListener(Enums.Events.CAMERA_MODIFIED, updateScale);\n    };\n  }, [viewportIndex, viewportData, cornerstoneViewportService, element]);\n\n  /**\n   * Updating the active tools when the toolbar changes\n   */\n  // Todo: this should act on the toolGroups instead of the toolbar state\n  useEffect(() => {\n    const { unsubscribe } = toolbarService.subscribe(\n      toolbarService.EVENTS.TOOL_BAR_STATE_MODIFIED,\n      () => {\n        setActiveTools(toolbarService.getActiveTools());\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [toolbarService]);\n\n  const _renderOverlayItem = useCallback(\n    item => {\n      const overlayItemProps: OverlayItemProps = {\n        element,\n        viewportData,\n        imageSliceData,\n        viewportIndex,\n        servicesManager,\n        customization: item,\n        formatters: {\n          formatPN: formatPN,\n          formatDate: formatDICOMDate,\n          formatTime: formatDICOMTime,\n          formatNumberPrecision: formatNumberPrecision,\n        },\n        instance,\n        // calculated\n        voi,\n        scale,\n        instanceNumber,\n      };\n\n      if (item.customizationType === 'ohif.overlayItem.windowLevel') {\n        return <VOIOverlayItem {...overlayItemProps} />;\n      } else if (item.customizationType === 'ohif.overlayItem.zoomLevel') {\n        return <ZoomOverlayItem {...overlayItemProps} />;\n      } else if (item.customizationType === 'ohif.overlayItem.instanceNumber') {\n        return <InstanceNumberOverlayItem {...overlayItemProps} />;\n      } else {\n        const renderItem = customizationService.transform(item);\n\n        if (typeof renderItem.content === 'function') {\n          return renderItem.content(overlayItemProps);\n        }\n      }\n    },\n    [\n      element,\n      viewportData,\n      imageSliceData,\n      viewportIndex,\n      servicesManager,\n      customizationService,\n      instance,\n      voi,\n      scale,\n      instanceNumber,\n    ]\n  );\n\n  const getTopLeftContent = useCallback(() => {\n    const items = topLeftCustomization?.items || [\n      {\n        id: 'WindowLevel',\n        customizationType: 'ohif.overlayItem.windowLevel',\n      },\n    ];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`topLeftOverlayItem_${i}`}>{_renderOverlayItem(item)}</div>\n        ))}\n      </>\n    );\n  }, [topLeftCustomization, _renderOverlayItem]);\n\n  const getTopRightContent = useCallback(() => {\n    const items = topRightCustomization?.items || [\n      {\n        id: 'InstanceNmber',\n        customizationType: 'ohif.overlayItem.instanceNumber',\n      },\n    ];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`topRightOverlayItem_${i}`}>{_renderOverlayItem(item)}</div>\n        ))}\n      </>\n    );\n  }, [topRightCustomization, _renderOverlayItem]);\n\n  const getBottomLeftContent = useCallback(() => {\n    const items = bottomLeftCustomization?.items || [];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`bottomLeftOverlayItem_${i}`}>\n            {_renderOverlayItem(item)}\n          </div>\n        ))}\n      </>\n    );\n  }, [bottomLeftCustomization, _renderOverlayItem]);\n\n  const getBottomRightContent = useCallback(() => {\n    const items = bottomRightCustomization?.items || [];\n    return (\n      <>\n        {items.map((item, i) => (\n          <div key={`bottomRightOverlayItem_${i}`}>\n            {_renderOverlayItem(item)}\n          </div>\n        ))}\n      </>\n    );\n  }, [bottomRightCustomization, _renderOverlayItem]);\n\n  return (\n    <ViewportOverlay\n      topLeft={getTopLeftContent()}\n      topRight={getTopRightContent()}\n      bottomLeft={getBottomLeftContent()}\n      bottomRight={getBottomRightContent()}\n    />\n  );\n}\n\nfunction _getViewportInstance(viewportData, imageIndex) {\n  let imageId = null;\n  if (viewportData.viewportType === Enums.ViewportType.STACK) {\n    imageId = viewportData.data.imageIds[imageIndex];\n  } else if (viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC) {\n    const volumes = viewportData.volumes;\n    if (volumes && volumes.length == 1) {\n      const volume = volumes[0];\n      imageId = volume.imageIds[imageIndex];\n    }\n  }\n  return imageId ? metaData.get('instance', imageId) || {} : {};\n}\n\nfunction _getInstanceNumber(\n  viewportData,\n  viewportIndex,\n  imageIndex,\n  cornerstoneViewportService\n) {\n  let instanceNumber;\n\n  if (viewportData.viewportType === Enums.ViewportType.STACK) {\n    instanceNumber = _getInstanceNumberFromStack(viewportData, imageIndex);\n\n    if (!instanceNumber && instanceNumber !== 0) {\n      return null;\n    }\n  } else if (viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC) {\n    instanceNumber = _getInstanceNumberFromVolume(\n      viewportData,\n      imageIndex,\n      viewportIndex,\n      cornerstoneViewportService\n    );\n  }\n  return instanceNumber;\n}\n\nfunction _getInstanceNumberFromStack(viewportData, imageIndex) {\n  const imageIds = viewportData.data.imageIds;\n  const imageId = imageIds[imageIndex];\n\n  if (!imageId) {\n    return;\n  }\n\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\n  const { instanceNumber } = generalImageModule;\n\n  const stackSize = imageIds.length;\n\n  if (stackSize <= 1) {\n    return;\n  }\n\n  return parseInt(instanceNumber);\n}\n\n// Since volume viewports can be in any view direction, they can render\n// a reconstructed image which don't have imageIds; therefore, no instance and instanceNumber\n// Here we check if viewport is in the acquisition direction and if so, we get the instanceNumber\nfunction _getInstanceNumberFromVolume(\n  viewportData,\n  imageIndex,\n  viewportIndex,\n  cornerstoneViewportService\n) {\n  const volumes = viewportData.volumes;\n\n  // Todo: support fusion of acquisition plane which has instanceNumber\n  if (!volumes || volumes.length > 1) {\n    return;\n  }\n\n  const volume = volumes[0];\n  const { direction, imageIds } = volume;\n\n  const cornerstoneViewport = cornerstoneViewportService.getCornerstoneViewportByIndex(\n    viewportIndex\n  );\n\n  if (!cornerstoneViewport) {\n    return;\n  }\n\n  const camera = cornerstoneViewport.getCamera();\n  const { viewPlaneNormal } = camera;\n  // checking if camera is looking at the acquisition plane (defined by the direction on the volume)\n\n  const scanAxisNormal = direction.slice(6, 9);\n\n  // check if viewPlaneNormal is parallel to scanAxisNormal\n  const cross = vec3.cross(vec3.create(), viewPlaneNormal, scanAxisNormal);\n  const isAcquisitionPlane = vec3.length(cross) < EPSILON;\n\n  if (isAcquisitionPlane) {\n    const imageId = imageIds[imageIndex];\n\n    if (!imageId) {\n      return {};\n    }\n\n    const { instanceNumber } =\n      metaData.get('generalImageModule', imageId) || {};\n    return parseInt(instanceNumber);\n  }\n}\n\nCustomizableViewportOverlay.propTypes = {\n  viewportData: PropTypes.object,\n  imageIndex: PropTypes.number,\n  viewportIndex: PropTypes.number,\n};\n\nexport default CustomizableViewportOverlay;\n","import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Enums, Types, utilities } from '@cornerstonejs/core';\nimport { utilities as csToolsUtils } from '@cornerstonejs/tools';\nimport { ImageScrollbar } from '@ohif/ui';\nimport { ServicesManger } from '@ohif/core';\n\nfunction CornerstoneImageScrollbar({\n  viewportData,\n  viewportIndex,\n  element,\n  imageSliceData,\n  setImageSliceData,\n  scrollbarHeight,\n  servicesManager,\n}) {\n  const {\n    cineService,\n    cornerstoneViewportService,\n  } = (servicesManager as ServicesManger).services;\n\n  const onImageScrollbarChange = (imageIndex, viewportIndex) => {\n    const viewportInfo = cornerstoneViewportService.getViewportInfoByIndex(\n      viewportIndex\n    );\n\n    const viewportId = viewportInfo.getViewportId();\n    const viewport = cornerstoneViewportService.getCornerstoneViewport(\n      viewportId\n    );\n\n    const { isCineEnabled } = cineService.getState();\n\n    if (isCineEnabled) {\n      // on image scrollbar change, stop the CINE if it is playing\n      cineService.stopClip(element);\n      cineService.setCine({ id: viewportIndex, isPlaying: false });\n    }\n\n    csToolsUtils.jumpToSlice(viewport.element, {\n      imageIndex,\n      debounceLoading: true,\n    });\n  };\n\n  useEffect(() => {\n    if (!viewportData) {\n      return;\n    }\n\n    const viewport = cornerstoneViewportService.getCornerstoneViewportByIndex(\n      viewportIndex\n    );\n\n    if (!viewport) {\n      return;\n    }\n\n    if (viewportData.viewportType === Enums.ViewportType.STACK) {\n      const imageIndex = viewport.getCurrentImageIdIndex();\n\n      setImageSliceData({\n        imageIndex: imageIndex,\n        numberOfSlices: viewportData.data.imageIds.length,\n      });\n\n      return;\n    }\n\n    if (viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC) {\n      const sliceData = utilities.getImageSliceDataForVolumeViewport(\n        viewport as Types.IVolumeViewport\n      );\n\n      if (!sliceData) {\n        return;\n      }\n\n      const { imageIndex, numberOfSlices } = sliceData;\n      setImageSliceData({ imageIndex, numberOfSlices });\n    }\n  }, [viewportIndex, viewportData]);\n\n  useEffect(() => {\n    if (viewportData?.viewportType !== Enums.ViewportType.STACK) {\n      return;\n    }\n\n    const updateStackIndex = event => {\n      const { newImageIdIndex } = event.detail;\n      // find the index of imageId in the imageIds\n      setImageSliceData({\n        imageIndex: newImageIdIndex,\n        numberOfSlices: viewportData.data.imageIds.length,\n      });\n    };\n\n    element.addEventListener(\n      Enums.Events.STACK_VIEWPORT_SCROLL,\n      updateStackIndex\n    );\n\n    return () => {\n      element.removeEventListener(\n        Enums.Events.STACK_VIEWPORT_SCROLL,\n        updateStackIndex\n      );\n    };\n  }, [viewportData, element]);\n\n  useEffect(() => {\n    if (viewportData?.viewportType !== Enums.ViewportType.ORTHOGRAPHIC) {\n      return;\n    }\n\n    const updateVolumeIndex = event => {\n      const { imageIndex, numberOfSlices } = event.detail;\n      // find the index of imageId in the imageIds\n      setImageSliceData({ imageIndex, numberOfSlices });\n    };\n\n    element.addEventListener(Enums.Events.VOLUME_NEW_IMAGE, updateVolumeIndex);\n\n    return () => {\n      element.removeEventListener(\n        Enums.Events.VOLUME_NEW_IMAGE,\n        updateVolumeIndex\n      );\n    };\n  }, [viewportData, element]);\n\n  return (\n    <ImageScrollbar\n      onChange={evt => onImageScrollbarChange(evt, viewportIndex)}\n      max={\n        imageSliceData.numberOfSlices ? imageSliceData.numberOfSlices - 1 : 0\n      }\n      height={scrollbarHeight}\n      value={imageSliceData.imageIndex}\n    />\n  );\n}\n\nCornerstoneImageScrollbar.propTypes = {\n  viewportData: PropTypes.object,\n  viewportIndex: PropTypes.number.isRequired,\n  element: PropTypes.instanceOf(Element),\n  scrollbarHeight: PropTypes.string,\n  imageSliceData: PropTypes.object.isRequired,\n  setImageSliceData: PropTypes.func.isRequired,\n  servicesManager: PropTypes.object.isRequired,\n};\n\nexport default CornerstoneImageScrollbar;\n","import React, { useEffect, useState, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { Enums } from '@cornerstonejs/core';\n\nfunction ViewportImageSliceLoadingIndicator({ viewportData, element }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(false);\n\n  const loadIndicatorRef = useRef(null);\n  const imageIdToBeLoaded = useRef(null);\n\n  const setLoadingState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    loadIndicatorRef.current = setTimeout(() => {\n      setLoading(true);\n    }, 50);\n  };\n\n  const setFinishLoadingState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    setLoading(false);\n  };\n\n  const setErrorState = evt => {\n    clearTimeout(loadIndicatorRef.current);\n\n    if (imageIdToBeLoaded.current === evt.detail.imageId) {\n      setError(evt.detail.error);\n      imageIdToBeLoaded.current = null;\n    }\n  };\n\n  useEffect(() => {\n    element.addEventListener(\n      Enums.Events.STACK_VIEWPORT_SCROLL,\n      setLoadingState\n    );\n    element.addEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\n    element.addEventListener(\n      Enums.Events.STACK_NEW_IMAGE,\n      setFinishLoadingState\n    );\n\n    return () => {\n      element.removeEventListener(\n        Enums.Events.STACK_VIEWPORT_SCROLL,\n        setLoadingState\n      );\n\n      element.removeEventListener(\n        Enums.Events.STACK_NEW_IMAGE,\n        setFinishLoadingState\n      );\n\n      element.removeEventListener(Enums.Events.IMAGE_LOAD_ERROR, setErrorState);\n    };\n  }, [element, viewportData]);\n\n  if (error) {\n    return (\n      <>\n        <div className=\"bg-black opacity-50 absolute h-full w-full top-0 left-0\">\n          <div className=\"flex transparent items-center justify-center w-full h-full\">\n            <p className=\"text-primary-light text-xl font-light\">\n              <h4>Error Loading Image</h4>\n              <p>An error has occurred.</p>\n              <p>{error}</p>\n            </p>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  if (loading) {\n    return (\n      // IMPORTANT: we need to use the pointer-events-none class to prevent the loading indicator from\n      // interacting with the mouse, since scrolling should propagate to the viewport underneath\n      <div className=\"pointer-events-none bg-black opacity-50 absolute h-full w-full top-0 left-0\">\n        <div className=\"flex transparent items-center justify-center w-full h-full\">\n          <p className=\"text-primary-light text-xl font-light\">Loading...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return null;\n}\n\nViewportImageSliceLoadingIndicator.propTypes = {\n  percentComplete: PropTypes.number,\n  error: PropTypes.object,\n  element: PropTypes.object,\n};\n\nViewportImageSliceLoadingIndicator.defaultProps = {\n  percentComplete: 0,\n  error: null,\n};\n\nexport default ViewportImageSliceLoadingIndicator;\n","import React, { useEffect, useState, useMemo } from 'react';\nimport classNames from 'classnames';\nimport {\n  metaData,\n  Enums,\n  Types,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/tools';\nimport PropTypes from 'prop-types';\nimport { vec3 } from 'gl-matrix';\n\nimport './ViewportOrientationMarkers.css';\n\nconst {\n  getOrientationStringLPS,\n  invertOrientationStringLPS,\n} = utilities.orientation;\n\nfunction ViewportOrientationMarkers({\n  element,\n  viewportData,\n  imageSliceData,\n  viewportIndex,\n  servicesManager,\n  orientationMarkers = ['top', 'left'],\n}) {\n  // Rotation is in degrees\n  const [rotation, setRotation] = useState(0);\n  const [flipHorizontal, setFlipHorizontal] = useState(false);\n  const [flipVertical, setFlipVertical] = useState(false);\n  const { cornerstoneViewportService } = servicesManager.services;\n\n  useEffect(() => {\n    const cameraModifiedListener = (\n      evt: Types.EventTypes.CameraModifiedEvent\n    ) => {\n      const { rotation, previousCamera, camera } = evt.detail;\n\n      if (rotation !== undefined) {\n        setRotation(rotation);\n      }\n\n      if (\n        camera.flipHorizontal !== undefined &&\n        previousCamera.flipHorizontal !== camera.flipHorizontal\n      ) {\n        setFlipHorizontal(camera.flipHorizontal);\n      }\n\n      if (\n        camera.flipVertical !== undefined &&\n        previousCamera.flipVertical !== camera.flipVertical\n      ) {\n        setFlipVertical(camera.flipVertical);\n      }\n    };\n\n    element.addEventListener(\n      Enums.Events.CAMERA_MODIFIED,\n      cameraModifiedListener\n    );\n\n    return () => {\n      element.removeEventListener(\n        Enums.Events.CAMERA_MODIFIED,\n        cameraModifiedListener\n      );\n    };\n  }, []);\n\n  const markers = useMemo(() => {\n    if (!viewportData) {\n      return '';\n    }\n\n    let rowCosines, columnCosines;\n    if (viewportData.viewportType === 'stack') {\n      const imageIndex = imageSliceData.imageIndex;\n      const imageId = viewportData.data.imageIds?.[imageIndex];\n\n      // Workaround for below TODO stub\n      if (!imageId) {\n        return false;\n      }\n\n      ({ rowCosines, columnCosines } =\n        metaData.get('imagePlaneModule', imageId) || {});\n    } else {\n      if (!element || !getEnabledElement(element)) {\n        return '';\n      }\n\n      const { viewport } = getEnabledElement(element);\n      const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n      const viewRight = vec3.create();\n      vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n      columnCosines = [-viewUp[0], -viewUp[1], -viewUp[2]];\n      rowCosines = viewRight;\n    }\n\n    if (!rowCosines || !columnCosines || rotation === undefined) {\n      return '';\n    }\n\n    const markers = _getOrientationMarkers(\n      rowCosines,\n      columnCosines,\n      rotation,\n      flipVertical,\n      flipHorizontal\n    );\n\n    const ohifViewport = cornerstoneViewportService.getViewportInfoByIndex(\n      viewportIndex\n    );\n\n    if (!ohifViewport) {\n      console.log('ViewportOrientationMarkers::No viewport');\n      return null;\n    }\n    const backgroundColor = ohifViewport.getViewportOptions().background;\n\n    // Todo: probably this can be done in a better way in which we identify bright\n    // background\n    const isLight = backgroundColor\n      ? csUtils.isEqual(backgroundColor, [1, 1, 1])\n      : false;\n\n    return orientationMarkers.map((m, index) => (\n      <div\n        className={classNames(\n          `${m}-mid orientation-marker`,\n          isLight ? 'text-[#726F7E]' : 'text-[#ccc]'\n        )}\n        key={`${m}-mid orientation-marker`}\n      >\n        <div className=\"orientation-marker-value\">{markers[m]}</div>\n      </div>\n    ));\n  }, [\n    viewportData,\n    imageSliceData,\n    rotation,\n    flipVertical,\n    flipHorizontal,\n    orientationMarkers,\n    element,\n  ]);\n\n  return <div className=\"ViewportOrientationMarkers noselect\">{markers}</div>;\n}\n\nViewportOrientationMarkers.propTypes = {\n  percentComplete: PropTypes.number,\n  error: PropTypes.object,\n};\n\nViewportOrientationMarkers.defaultProps = {\n  percentComplete: 0,\n  error: null,\n};\n\n/**\n *\n * Computes the orientation labels on a Cornerstone-enabled Viewport element\n * when the viewport settings change (e.g. when a horizontal flip or a rotation occurs)\n *\n * @param {*} rowCosines\n * @param {*} columnCosines\n * @param {*} rotation in degrees\n * @returns\n */\nfunction _getOrientationMarkers(\n  rowCosines,\n  columnCosines,\n  rotation,\n  flipVertical,\n  flipHorizontal\n) {\n  const rowString = getOrientationStringLPS(rowCosines);\n  const columnString = getOrientationStringLPS(columnCosines);\n  const oppositeRowString = invertOrientationStringLPS(rowString);\n  const oppositeColumnString = invertOrientationStringLPS(columnString);\n\n  const markers = {\n    top: oppositeColumnString,\n    left: oppositeRowString,\n    right: rowString,\n    bottom: columnString,\n  };\n\n  // If any vertical or horizontal flips are applied, change the orientation strings ahead of\n  // the rotation applications\n  if (flipVertical) {\n    markers.top = invertOrientationStringLPS(markers.top);\n    markers.bottom = invertOrientationStringLPS(markers.bottom);\n  }\n\n  if (flipHorizontal) {\n    markers.left = invertOrientationStringLPS(markers.left);\n    markers.right = invertOrientationStringLPS(markers.right);\n  }\n\n  // Swap the labels accordingly if the viewport has been rotated\n  // This could be done in a more complex way for intermediate rotation values (e.g. 45 degrees)\n  if (rotation === 90 || rotation === -270) {\n    return {\n      top: markers.left,\n      left: invertOrientationStringLPS(markers.top),\n      right: invertOrientationStringLPS(markers.bottom),\n      bottom: markers.right, // left\n    };\n  } else if (rotation === -90 || rotation === 270) {\n    return {\n      top: invertOrientationStringLPS(markers.left),\n      left: markers.top,\n      bottom: markers.left,\n      right: markers.bottom,\n    };\n  } else if (rotation === 180 || rotation === -180) {\n    return {\n      top: invertOrientationStringLPS(markers.top),\n      left: invertOrientationStringLPS(markers.left),\n      bottom: invertOrientationStringLPS(markers.bottom),\n      right: invertOrientationStringLPS(markers.right),\n    };\n  }\n\n  return markers;\n}\n\nexport default ViewportOrientationMarkers;\n","import moment from 'moment';\nimport { metaData } from '@cornerstonejs/core';\n\n/**\n * Checks if value is valid.\n *\n * @param {number} value\n * @returns {boolean} is valid.\n */\nexport function isValidNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Formats number precision.\n *\n * @param {number} number\n * @param {number} precision\n * @returns {number} formatted number.\n */\nexport function formatNumberPrecision(number, precision = 0) {\n  if (number !== null) {\n    return parseFloat(number).toFixed(precision);\n  }\n}\n\n/**\n * Formats DICOM date.\n *\n * @param {string} date\n * @param {string} strFormat\n * @returns {string} formatted date.\n */\nexport function formatDICOMDate(date, strFormat = 'MMM D, YYYY') {\n  return moment(date, 'YYYYMMDD').format(strFormat);\n}\n\n/**\n *    DICOM Time is stored as HHmmss.SSS, where:\n *      HH 24 hour time:\n *        m mm        0..59   Minutes\n *        s ss        0..59   Seconds\n *        S SS SSS    0..999  Fractional seconds\n *\n *        Goal: '24:12:12'\n *\n * @param {*} time\n * @param {string} strFormat\n * @returns {string} formatted name.\n */\nexport function formatDICOMTime(time, strFormat = 'HH:mm:ss') {\n  return moment(time, 'HH:mm:ss').format(strFormat);\n}\n\n/**\n * Formats a patient name for display purposes\n *\n * @param {string} name\n * @returns {string} formatted name.\n */\nexport function formatPN(name) {\n  if (!name) {\n    return '';\n  }\n\n  const cleaned = name\n    .split('^')\n    .filter(s => !!s)\n    .join(', ')\n    .trim();\n  return cleaned === ',' || cleaned === '' ? '' : cleaned;\n}\n\n/**\n * Gets compression type\n *\n * @param {number} imageId\n * @returns {string} comrpession type.\n */\nexport function getCompression(imageId) {\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\n  const {\n    lossyImageCompression,\n    lossyImageCompressionRatio,\n    lossyImageCompressionMethod,\n  } = generalImageModule;\n\n  if (lossyImageCompression === '01' && lossyImageCompressionRatio !== '') {\n    const compressionMethod = lossyImageCompressionMethod || 'Lossy: ';\n    const compressionRatio = formatNumberPrecision(\n      lossyImageCompressionRatio,\n      2\n    );\n    return compressionMethod + compressionRatio + ' : 1';\n  }\n\n  return 'Lossless / Uncompressed';\n}\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".viewport-wrapper {\\n  width: 100%;\\n  height: 100%; /* MUST have `height` to prevent resize infinite loop */\\n  position: relative;\\n}\\n\\n.cornerstone-viewport-element {\\n  width: 100%;\\n  height: 100%;\\n  position: relative;\\n  background-color: black;\\n\\n  /* Prevent the blue outline in Chrome when a viewport is selected */\\n  outline: 0 !important;\\n\\n  /* Prevents the entire page from getting larger\\n     when the magnify tool is near the sides/corners of the page */\\n  overflow: hidden;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../../../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \"/*\\ncustom overlay panels: top-left, top-right, bottom-left and bottom-right\\nIf any text to be displayed on the overlay is too long to hold on a single\\nline, it will be truncated with ellipsis in the end.\\n*/\\n.viewport-overlay {\\n  max-width: 40%;\\n}\\n.viewport-overlay span {\\n  max-width: 100%;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n}\\n.viewport-overlay.left-viewport {\\n  text-align: left;\\n}\\n.viewport-overlay.right-viewport-scrollbar {\\n  text-align: right;\\n}\\n.viewport-overlay.right-viewport-scrollbar .flex.flex-row {\\n  -webkit-box-pack: end;\\n      -ms-flex-pack: end;\\n          justify-content: flex-end;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../../../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".ViewportOrientationMarkers {\\n  --marker-width: 100px;\\n  --marker-height: 100px;\\n  --scrollbar-width: 20px;\\n  pointer-events: none;\\n  font-size: 15px;\\n  line-height: 18px;\\n}\\n.ViewportOrientationMarkers .orientation-marker {\\n  position: absolute;\\n}\\n.ViewportOrientationMarkers .top-mid {\\n  top: 0.6rem;\\n  left: 50%;\\n}\\n.ViewportOrientationMarkers .left-mid {\\n  top: 47%;\\n  left: 5px;\\n}\\n.ViewportOrientationMarkers .right-mid {\\n  top: 47%;\\n  left: calc(100% - var(--marker-width) - var(--scrollbar-width));\\n}\\n.ViewportOrientationMarkers .bottom-mid {\\n  top: calc(100% - var(--marker-height) - 0.6rem);\\n  left: 47%;\\n}\\n.ViewportOrientationMarkers .right-mid .orientation-marker-value {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: end;\\n      -ms-flex-pack: end;\\n          justify-content: flex-end;\\n  min-width: var(--marker-width);\\n}\\n.ViewportOrientationMarkers .bottom-mid .orientation-marker-value {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-pack: start;\\n      -ms-flex-pack: start;\\n          justify-content: flex-start;\\n  min-height: var(--marker-height);\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: reverse;\\n      -ms-flex-direction: column-reverse;\\n          flex-direction: column-reverse;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n","var api = require(\"!../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./OHIFCornerstoneViewport.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./OHIFCornerstoneViewport.css\",\n      function () {\n        content = require(\"!!../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./OHIFCornerstoneViewport.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};","var api = require(\"!../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./CustomizableViewportOverlay.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./CustomizableViewportOverlay.css\",\n      function () {\n        content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./CustomizableViewportOverlay.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};","var api = require(\"!../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./ViewportOrientationMarkers.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./ViewportOrientationMarkers.css\",\n      function () {\n        content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./ViewportOrientationMarkers.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};"],"names":[],"sourceRoot":""}