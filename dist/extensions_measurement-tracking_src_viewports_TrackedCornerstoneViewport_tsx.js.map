{"version":3,"file":"extensions_measurement-tracking_src_viewports_TrackedCornerstoneViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AAIA;AAEA;AAEA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AAEA;AAEA;AAIA;AAEA;AACA;AAAA;AAAA;AAIA;AAGA;AACA;AAAA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AAAA;AAGA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAIA;AAAA;AAMA;AAAA;AAQA;AAEA;AAAA;AAAA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAnUA;AAEA;AA6NA;AA6DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sources":["file:////Users/smartxx/xV/DICOM/Viewers/extensions/measurement-tracking/src/viewports/TrackedCornerstoneViewport.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport OHIF, { utils } from '@ohif/core';\n\nimport { ViewportActionBar, Tooltip, Icon } from '@ohif/ui';\n\nimport { useTranslation } from 'react-i18next';\n\nimport { annotation } from '@cornerstonejs/tools';\nimport { useTrackedMeasurements } from './../getContextModule';\nimport { BaseVolumeViewport, Enums } from '@cornerstonejs/core';\n\nconst { formatDate } = utils;\n\nfunction TrackedCornerstoneViewport(props) {\n  const {\n    displaySets,\n    viewportIndex,\n    viewportLabel,\n    servicesManager,\n    extensionManager,\n    viewportOptions,\n  } = props;\n\n  const { t } = useTranslation('TrackedViewport');\n\n  const {\n    measurementService,\n    cornerstoneViewportService,\n  } = servicesManager.services;\n\n  // Todo: handling more than one displaySet on the same viewport\n  const displaySet = displaySets[0];\n\n  const [trackedMeasurements] = useTrackedMeasurements();\n  const [isTracked, setIsTracked] = useState(false);\n  const [trackedMeasurementUID, setTrackedMeasurementUID] = useState(null);\n  const [viewportElem, setViewportElem] = useState(null);\n\n  const { trackedSeries } = trackedMeasurements.context;\n  const viewportId = viewportOptions.viewportId;\n\n  const {\n    SeriesDate,\n    SeriesDescription,\n    SeriesInstanceUID,\n    SeriesNumber,\n  } = displaySet;\n\n  const {\n    PatientID,\n    PatientName,\n    PatientSex,\n    PatientAge,\n    SliceThickness,\n    SpacingBetweenSlices,\n    ManufacturerModelName,\n  } = displaySet.images[0];\n\n  const updateIsTracked = useCallback(() => {\n    const viewport = cornerstoneViewportService.getCornerstoneViewportByIndex(\n      viewportIndex\n    );\n\n    if (viewport instanceof BaseVolumeViewport) {\n      // A current image id will only exist for volume viewports that can have measurements tracked.\n      // Typically these are those volume viewports for the series of acquisition.\n      const currentImageId = viewport?.getCurrentImageId();\n\n      if (!currentImageId) {\n        if (isTracked) {\n          setIsTracked(false);\n        }\n        return;\n      }\n    }\n\n    if (trackedSeries.includes(SeriesInstanceUID) !== isTracked) {\n      setIsTracked(!isTracked);\n    }\n  }, [isTracked, trackedMeasurements, viewportIndex, SeriesInstanceUID]);\n\n  const onElementEnabled = useCallback(\n    evt => {\n      if (evt.detail.element !== viewportElem) {\n        // The VOLUME_VIEWPORT_NEW_VOLUME event allows updateIsTracked to reliably fetch the image id for a volume viewport.\n        evt.detail.element?.addEventListener(\n          Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n          updateIsTracked\n        );\n        setViewportElem(evt.detail.element);\n      }\n    },\n    [updateIsTracked, viewportElem]\n  );\n\n  const onElementDisabled = useCallback(() => {\n    viewportElem?.removeEventListener(\n      Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n      updateIsTracked\n    );\n  }, [updateIsTracked, viewportElem]);\n\n  useEffect(updateIsTracked, [updateIsTracked]);\n\n  useEffect(() => {\n    const { unsubscribe } = cornerstoneViewportService.subscribe(\n      cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED,\n      props => {\n        if (props.viewportIndex !== viewportIndex) {\n          return;\n        }\n\n        updateIsTracked();\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [updateIsTracked, viewportIndex]);\n\n  useEffect(() => {\n    if (isTracked) {\n      annotation.config.style.setViewportToolStyles(viewportId, {\n        global: {\n          lineDash: '',\n        },\n      });\n\n      cornerstoneViewportService\n        .getRenderingEngine()\n        .renderViewport(viewportId);\n\n      return;\n    }\n\n    annotation.config.style.setViewportToolStyles(viewportId, {\n      global: {\n        lineDash: '4,4',\n      },\n    });\n\n    cornerstoneViewportService.getRenderingEngine().renderViewport(viewportId);\n\n    return () => {\n      annotation.config.style.setViewportToolStyles(viewportId, {});\n    };\n  }, [isTracked]);\n\n  function switchMeasurement(direction) {\n    const newTrackedMeasurementUID = _getNextMeasurementUID(\n      direction,\n      servicesManager,\n      trackedMeasurementUID,\n      trackedMeasurements\n    );\n\n    if (!newTrackedMeasurementUID) {\n      return;\n    }\n\n    setTrackedMeasurementUID(newTrackedMeasurementUID);\n\n    measurementService.jumpToMeasurement(\n      viewportIndex,\n      newTrackedMeasurementUID\n    );\n  }\n\n  const getCornerstoneViewport = () => {\n    const { component: Component } = extensionManager.getModuleEntry(\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\n    );\n\n    return (\n      <Component\n        {...props}\n        onElementEnabled={onElementEnabled}\n        onElementDisabled={onElementDisabled}\n      />\n    );\n  };\n\n  return (\n    <>\n      <ViewportActionBar\n        onDoubleClick={evt => {\n          evt.stopPropagation();\n          evt.preventDefault();\n        }}\n        useAltStyling={isTracked}\n        onArrowsClick={direction => switchMeasurement(direction)}\n        getStatusComponent={() => _getStatusComponent(isTracked)}\n        studyData={{\n          label: viewportLabel,\n          studyDate: formatDate(SeriesDate), // TODO: This is series date. Is that ok?\n          currentSeries: SeriesNumber, // TODO - switch entire currentSeries to be UID based or actual position based\n          seriesDescription: SeriesDescription,\n          patientInformation: {\n            patientName: PatientName ? OHIF.utils.formatPN(PatientName) : '',\n            patientSex: PatientSex || '',\n            patientAge: PatientAge || '',\n            MRN: PatientID || '',\n            thickness: SliceThickness\n              ? `${parseFloat(SliceThickness).toFixed(2)}mm`\n              : '',\n            spacing:\n              SpacingBetweenSlices !== undefined\n                ? `${parseFloat(SpacingBetweenSlices).toFixed(2)}mm`\n                : '',\n            scanner: ManufacturerModelName || '',\n          },\n        }}\n      />\n      {/* TODO: Viewport interface to accept stack or layers of content like this? */}\n      <div className=\"relative flex flex-row w-full h-full overflow-hidden\">\n        {getCornerstoneViewport()}\n      </div>\n    </>\n  );\n}\n\nTrackedCornerstoneViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object.isRequired).isRequired,\n  viewportIndex: PropTypes.number.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  customProps: PropTypes.object,\n};\n\nTrackedCornerstoneViewport.defaultProps = {\n  customProps: {},\n};\n\nfunction _getNextMeasurementUID(\n  direction,\n  servicesManager,\n  trackedMeasurementId,\n  trackedMeasurements\n) {\n  const { measurementService, viewportGridService } = servicesManager.services;\n  const measurements = measurementService.getMeasurements();\n\n  const { activeViewportIndex, viewports } = viewportGridService.getState();\n  const {\n    displaySetInstanceUIDs: activeViewportDisplaySetInstanceUIDs,\n  } = viewports[activeViewportIndex];\n\n  const { trackedSeries } = trackedMeasurements.context;\n\n  // Get the potentially trackable measurements for the series of the\n  // active viewport.\n  // The measurements to jump between are the same\n  // regardless if this series is tracked or not.\n\n  const filteredMeasurements = measurements.filter(\n    m =>\n      trackedSeries.includes(m.referenceSeriesUID) &&\n      activeViewportDisplaySetInstanceUIDs.includes(m.displaySetInstanceUID)\n  );\n\n  if (!filteredMeasurements.length) {\n    // No measurements on this series.\n    return;\n  }\n\n  const measurementCount = filteredMeasurements.length;\n\n  const uids = filteredMeasurements.map(fm => fm.uid);\n  let measurementIndex = uids.findIndex(uid => uid === trackedMeasurementId);\n\n  if (measurementIndex === -1) {\n    // Not tracking a measurement, or previous measurement now deleted, revert to 0.\n    measurementIndex = 0;\n  } else {\n    if (direction === 'left') {\n      measurementIndex--;\n\n      if (measurementIndex < 0) {\n        measurementIndex = measurementCount - 1;\n      }\n    } else if (direction === 'right') {\n      measurementIndex++;\n\n      if (measurementIndex === measurementCount) {\n        measurementIndex = 0;\n      }\n    }\n  }\n\n  const newTrackedMeasurementId = uids[measurementIndex];\n\n  return newTrackedMeasurementId;\n}\n\nfunction _getStatusComponent(isTracked) {\n  const trackedIcon = isTracked ? 'status-tracked' : 'status-untracked';\n\n  return (\n    <div className=\"relative\">\n      <Tooltip\n        position=\"bottom-left\"\n        content={\n          <div className=\"flex py-2\">\n            <div className=\"flex pt-1\">\n              <Icon name=\"info-link\" className=\"w-4 text-primary-main\" />\n            </div>\n            <div className=\"flex ml-4\">\n              <span className=\"text-base text-common-light\">\n                {isTracked ? (\n                  <>\n                    Series is\n                    <span className=\"font-bold text-white\"> tracked</span> and\n                    can be viewed <br /> in the measurement panel\n                  </>\n                ) : (\n                  <>\n                    Measurements for\n                    <span className=\"font-bold text-white\"> untracked </span>\n                    series <br /> will not be shown in the <br /> measurements\n                    panel\n                  </>\n                )}\n              </span>\n            </div>\n          </div>\n        }\n      >\n        <Icon name={trackedIcon} className=\"text-primary-light\" />\n      </Tooltip>\n    </div>\n  );\n}\n\nexport default TrackedCornerstoneViewport;\n"],"names":[],"sourceRoot":""}