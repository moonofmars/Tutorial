{"version":3,"file":"vendors-node_modules_cornerstonejs_adapters_dist_cornerstonejs_adapters_es_js.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC76IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/adapters/dist/@cornerstonejs/adapters.es.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/iota-array/iota.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/is-buffer/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/ndarray/ndarray.js"],"sourcesContent":["import { utilities, derivations, normalizers, data, log } from 'dcmjs';\nimport ndarray from 'ndarray';\nimport cloneDeep from 'lodash.clonedeep';\nimport { vec3 } from 'gl-matrix';\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar toArray = function toArray(x) {\n  return Array.isArray(x) ? x : [x];\n};\nvar codeMeaningEquals = function codeMeaningEquals(codeMeaningName) {\n  return function (contentItem) {\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\n  };\n};\n\nvar TID1500$1 = utilities.TID1500,\n  addAccessors$1 = utilities.addAccessors;\nvar StructuredReport$1 = derivations.StructuredReport;\nvar Normalizer$3 = normalizers.Normalizer;\nvar TID1500MeasurementReport$1 = TID1500$1.TID1500MeasurementReport,\n  TID1501MeasurementGroup$1 = TID1500$1.TID1501MeasurementGroup;\nvar DicomMetaDictionary$3 = data.DicomMetaDictionary;\nvar FINDING$2 = {\n  CodingSchemeDesignator: \"DCM\",\n  CodeValue: \"121071\"\n};\nvar FINDING_SITE$2 = {\n  CodingSchemeDesignator: \"SCT\",\n  CodeValue: \"363698007\"\n};\nvar FINDING_SITE_OLD$1 = {\n  CodingSchemeDesignator: \"SRT\",\n  CodeValue: \"G-C0E3\"\n};\nvar codeValueMatch$1 = function codeValueMatch(group, code, oldCode) {\n  var ConceptNameCodeSequence = group.ConceptNameCodeSequence;\n  if (!ConceptNameCodeSequence) return;\n  var CodingSchemeDesignator = ConceptNameCodeSequence.CodingSchemeDesignator,\n    CodeValue = ConceptNameCodeSequence.CodeValue;\n  return CodingSchemeDesignator == code.CodingSchemeDesignator && CodeValue == code.CodeValue || oldCode && CodingSchemeDesignator == oldCode.CodingSchemeDesignator && CodeValue == oldCode.CodeValue;\n};\nfunction getTID300ContentItem$1(tool, toolType, ReferencedSOPSequence, toolClass) {\n  var args = toolClass.getTID300RepresentationArguments(tool);\n  args.ReferencedSOPSequence = ReferencedSOPSequence;\n  var TID300Measurement = new toolClass.TID300Representation(args);\n  return TID300Measurement;\n}\nfunction getMeasurementGroup$1(toolType, toolData, ReferencedSOPSequence) {\n  var toolTypeData = toolData[toolType];\n  var toolClass = MeasurementReport$1.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n  if (!toolTypeData || !toolTypeData.data || !toolTypeData.data.length || !toolClass) {\n    return;\n  }\n\n  // Loop through the array of tool instances\n  // for this tool\n  var Measurements = toolTypeData.data.map(function (tool) {\n    return getTID300ContentItem$1(tool, toolType, ReferencedSOPSequence, toolClass);\n  });\n  return new TID1501MeasurementGroup$1(Measurements);\n}\nvar MeasurementReport$1 = /*#__PURE__*/function () {\n  function MeasurementReport() {\n    _classCallCheck(this, MeasurementReport);\n  }\n  _createClass(MeasurementReport, null, [{\n    key: \"getSetupMeasurementData\",\n    value: function getSetupMeasurementData(MeasurementGroup) {\n      var ContentSequence = MeasurementGroup.ContentSequence;\n      var contentSequenceArr = toArray(ContentSequence);\n      var findingGroup = contentSequenceArr.find(function (group) {\n        return codeValueMatch$1(group, FINDING$2);\n      });\n      var findingSiteGroups = contentSequenceArr.filter(function (group) {\n        return codeValueMatch$1(group, FINDING_SITE$2, FINDING_SITE_OLD$1);\n      }) || [];\n      var NUMGroup = contentSequenceArr.find(function (group) {\n        return group.ValueType === \"NUM\";\n      });\n      var SCOORDGroup = toArray(NUMGroup.ContentSequence).find(function (group) {\n        return group.ValueType === \"SCOORD\";\n      });\n      var ReferencedSOPSequence = SCOORDGroup.ContentSequence.ReferencedSOPSequence;\n      var ReferencedSOPInstanceUID = ReferencedSOPSequence.ReferencedSOPInstanceUID,\n        ReferencedFrameNumber = ReferencedSOPSequence.ReferencedFrameNumber;\n      var defaultState = {\n        sopInstanceUid: ReferencedSOPInstanceUID,\n        frameIndex: ReferencedFrameNumber || 1,\n        complete: true,\n        finding: findingGroup ? addAccessors$1(findingGroup.ConceptCodeSequence) : undefined,\n        findingSites: findingSiteGroups.map(function (fsg) {\n          return addAccessors$1(fsg.ConceptCodeSequence);\n        })\n      };\n      if (defaultState.finding) {\n        defaultState.description = defaultState.finding.CodeMeaning;\n      }\n      var findingSite = defaultState.findingSites && defaultState.findingSites[0];\n      if (findingSite) {\n        defaultState.location = findingSite[0] && findingSite[0].CodeMeaning || findingSite.CodeMeaning;\n      }\n      return {\n        defaultState: defaultState,\n        findingGroup: findingGroup,\n        findingSiteGroups: findingSiteGroups,\n        NUMGroup: NUMGroup,\n        SCOORDGroup: SCOORDGroup,\n        ReferencedSOPSequence: ReferencedSOPSequence,\n        ReferencedSOPInstanceUID: ReferencedSOPInstanceUID,\n        ReferencedFrameNumber: ReferencedFrameNumber\n      };\n    }\n  }, {\n    key: \"generateReport\",\n    value: function generateReport(toolState, metadataProvider, options) {\n      // ToolState for array of imageIDs to a Report\n      // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n      var allMeasurementGroups = [];\n      var firstImageId = Object.keys(toolState)[0];\n      if (!firstImageId) {\n        throw new Error(\"No measurements provided.\");\n      }\n\n      /* Patient ID\n      Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n      Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n      Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n      Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n       */\n      var generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", firstImageId);\n\n      //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n      // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n      // which means that if the toolState is for multiple series, the report will have the incorrect\n      // SeriesInstanceUIDs\n      var studyInstanceUID = generalSeriesModule.studyInstanceUID,\n        seriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n\n      // Loop through each image in the toolData\n      Object.keys(toolState).forEach(function (imageId) {\n        var sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n        var frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n        var toolData = toolState[imageId];\n        var toolTypes = Object.keys(toolData);\n        var ReferencedSOPSequence = {\n          ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n          ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n        };\n        if (Normalizer$3.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)) {\n          ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n        }\n\n        // Loop through each tool type for the image\n        var measurementGroups = [];\n        toolTypes.forEach(function (toolType) {\n          var group = getMeasurementGroup$1(toolType, toolData, ReferencedSOPSequence);\n          if (group) {\n            measurementGroups.push(group);\n          }\n        });\n        allMeasurementGroups = allMeasurementGroups.concat(measurementGroups);\n      });\n      var _MeasurementReport = new TID1500MeasurementReport$1({\n        TID1501MeasurementGroups: allMeasurementGroups\n      }, options);\n\n      // TODO: what is the correct metaheader\n      // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n      // TODO: move meta creation to happen in derivations.js\n      var fileMetaInformationVersionArray = new Uint8Array(2);\n      fileMetaInformationVersionArray[1] = 1;\n      var derivationSourceDataset = {\n        StudyInstanceUID: studyInstanceUID,\n        SeriesInstanceUID: seriesInstanceUID\n        //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n        //SOPClassUID: sopClassUID,\n      };\n\n      var _meta = {\n        FileMetaInformationVersion: {\n          Value: [fileMetaInformationVersionArray.buffer],\n          vr: \"OB\"\n        },\n        //MediaStorageSOPClassUID\n        //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n        TransferSyntaxUID: {\n          Value: [\"1.2.840.10008.1.2.1\"],\n          vr: \"UI\"\n        },\n        ImplementationClassUID: {\n          Value: [DicomMetaDictionary$3.uid()],\n          // TODO: could be git hash or other valid id\n          vr: \"UI\"\n        },\n        ImplementationVersionName: {\n          Value: [\"dcmjs\"],\n          vr: \"SH\"\n        }\n      };\n      var _vrMap = {\n        PixelData: \"OW\"\n      };\n      derivationSourceDataset._meta = _meta;\n      derivationSourceDataset._vrMap = _vrMap;\n      var report = new StructuredReport$1([derivationSourceDataset]);\n      var contentItem = _MeasurementReport.contentItem(derivationSourceDataset);\n\n      // Merge the derived dataset with the content from the Measurement Report\n      report.dataset = Object.assign(report.dataset, contentItem);\n      report.dataset._meta = _meta;\n      return report;\n    }\n\n    /**\n     * Generate Cornerstone tool state from dataset\n     * @param {object} dataset dataset\n     * @param {object} hooks\n     * @param {function} hooks.getToolClass Function to map dataset to a tool class\n     * @returns\n     */\n  }, {\n    key: \"generateToolState\",\n    value: function generateToolState(dataset) {\n      var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // For now, bail out if the dataset is not a TID1500 SR with length measurements\n      if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n        throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n      }\n      var REPORT = \"Imaging Measurements\";\n      var GROUP = \"Measurement Group\";\n      var TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n      // Identify the Imaging Measurements\n      var imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n\n      // Retrieve the Measurements themselves\n      var measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n\n      // For each of the supported measurement types, compute the measurement data\n      var measurementData = {};\n      var cornerstoneToolClasses = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n      var registeredToolClasses = [];\n      Object.keys(cornerstoneToolClasses).forEach(function (key) {\n        registeredToolClasses.push(cornerstoneToolClasses[key]);\n        measurementData[key] = [];\n      });\n      measurementGroups.forEach(function (measurementGroup) {\n        var measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n        var TrackingIdentifierGroup = measurementGroupContentSequence.find(function (contentItem) {\n          return contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER;\n        });\n        var TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n        var toolClass = hooks.getToolClass ? hooks.getToolClass(measurementGroup, dataset, registeredToolClasses) : registeredToolClasses.find(function (tc) {\n          return tc.isValidCornerstoneTrackingIdentifier(TrackingIdentifierValue);\n        });\n        if (toolClass) {\n          var measurement = toolClass.getMeasurementData(measurementGroup);\n          console.log(\"=== \".concat(toolClass.toolType, \" ===\"));\n          console.log(measurement);\n          measurementData[toolClass.toolType].push(measurement);\n        }\n      });\n\n      // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n      // That is up to the consumer to derive from the SOPInstanceUIDs.\n      return measurementData;\n    }\n  }, {\n    key: \"registerTool\",\n    value: function registerTool(toolClass) {\n      MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[toolClass.utilityToolType] = toolClass;\n      MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolClass.toolType] = toolClass;\n      MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] = toolClass.utilityToolType;\n    }\n  }]);\n  return MeasurementReport;\n}();\nMeasurementReport$1.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport$1.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport$1.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\nvar CORNERSTONE_4_TAG = \"cornerstoneTools@^4.0.0\";\n\nvar TID300Length$1 = utilities.TID300.Length;\nvar LENGTH$1 = \"Length\";\nvar Length$1 = /*#__PURE__*/function () {\n  function Length() {\n    _classCallCheck(this, Length);\n  }\n  _createClass(Length, null, [{\n    key: \"getMeasurementData\",\n    value:\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        NUMGroup = _MeasurementReport$ge.NUMGroup,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup;\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        length: NUMGroup.MeasuredValueSequence.NumericValue,\n        toolType: Length.toolType,\n        handles: {\n          start: {},\n          end: {},\n          textBox: {\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          }\n        }\n      });\n      var _SCOORDGroup$GraphicD = _slicedToArray(SCOORDGroup.GraphicData, 4);\n      state.handles.start.x = _SCOORDGroup$GraphicD[0];\n      state.handles.start.y = _SCOORDGroup$GraphicD[1];\n      state.handles.end.x = _SCOORDGroup$GraphicD[2];\n      state.handles.end.y = _SCOORDGroup$GraphicD[3];\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var handles = tool.handles,\n        finding = tool.finding,\n        findingSites = tool.findingSites;\n      var point1 = handles.start;\n      var point2 = handles.end;\n      var distance = tool.length;\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n      return {\n        point1: point1,\n        point2: point2,\n        distance: distance,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return Length;\n}();\nLength$1.toolType = LENGTH$1;\nLength$1.utilityToolType = LENGTH$1;\nLength$1.TID300Representation = TID300Length$1;\nLength$1.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === LENGTH$1;\n};\nMeasurementReport$1.registerTool(Length$1);\n\nvar TID300Polyline$3 = utilities.TID300.Polyline;\nvar FreehandRoi = /*#__PURE__*/function () {\n  function FreehandRoi() {\n    _classCallCheck(this, FreehandRoi);\n  }\n  _createClass(FreehandRoi, null, [{\n    key: \"getMeasurementData\",\n    value: function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup,\n        NUMGroup = _MeasurementReport$ge.NUMGroup;\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        toolType: FreehandRoi.toolType,\n        handles: {\n          points: [],\n          textBox: {\n            active: false,\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          }\n        },\n        cachedStats: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        },\n        color: undefined,\n        invalidated: true\n      });\n      var GraphicData = SCOORDGroup.GraphicData;\n      for (var i = 0; i < GraphicData.length; i += 2) {\n        state.handles.points.push({\n          x: GraphicData[i],\n          y: GraphicData[i + 1]\n        });\n      }\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var handles = tool.handles,\n        finding = tool.finding,\n        findingSites = tool.findingSites,\n        _tool$cachedStats = tool.cachedStats,\n        cachedStats = _tool$cachedStats === void 0 ? {} : _tool$cachedStats;\n      var points = handles.points;\n      var _cachedStats$area = cachedStats.area,\n        area = _cachedStats$area === void 0 ? 0 : _cachedStats$area,\n        _cachedStats$perimete = cachedStats.perimeter,\n        perimeter = _cachedStats$perimete === void 0 ? 0 : _cachedStats$perimete;\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:FreehandRoi\";\n      return {\n        points: points,\n        area: area,\n        perimeter: perimeter,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return FreehandRoi;\n}();\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline$3;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === FreehandRoi.toolType;\n};\nMeasurementReport$1.registerTool(FreehandRoi);\n\nvar TID300Bidirectional$1 = utilities.TID300.Bidirectional;\nvar BIDIRECTIONAL$1 = \"Bidirectional\";\nvar LONG_AXIS$1 = \"Long Axis\";\nvar SHORT_AXIS$1 = \"Short Axis\";\nvar FINDING$1 = \"121071\";\nvar FINDING_SITE$1 = \"G-C0E3\";\nvar Bidirectional$1 = /*#__PURE__*/function () {\n  function Bidirectional() {\n    _classCallCheck(this, Bidirectional);\n  }\n  _createClass(Bidirectional, null, [{\n    key: \"getMeasurementData\",\n    value:\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    function getMeasurementData(MeasurementGroup) {\n      var ContentSequence = MeasurementGroup.ContentSequence;\n      var findingGroup = toArray(ContentSequence).find(function (group) {\n        return group.ConceptNameCodeSequence.CodeValue === FINDING$1;\n      });\n      var findingSiteGroups = toArray(ContentSequence).filter(function (group) {\n        return group.ConceptNameCodeSequence.CodeValue === FINDING_SITE$1;\n      });\n      var longAxisNUMGroup = toArray(ContentSequence).find(function (group) {\n        return group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS$1;\n      });\n      var longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(function (group) {\n        return group.ValueType === \"SCOORD\";\n      });\n      var shortAxisNUMGroup = toArray(ContentSequence).find(function (group) {\n        return group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS$1;\n      });\n      var shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(function (group) {\n        return group.ValueType === \"SCOORD\";\n      });\n      var ReferencedSOPSequence = longAxisSCOORDGroup.ContentSequence.ReferencedSOPSequence;\n      var ReferencedSOPInstanceUID = ReferencedSOPSequence.ReferencedSOPInstanceUID,\n        ReferencedFrameNumber = ReferencedSOPSequence.ReferencedFrameNumber;\n\n      // Long axis\n\n      var longestDiameter = String(longAxisNUMGroup.MeasuredValueSequence.NumericValue);\n      var shortestDiameter = String(shortAxisNUMGroup.MeasuredValueSequence.NumericValue);\n      var bottomRight = {\n        x: Math.max(longAxisSCOORDGroup.GraphicData[0], longAxisSCOORDGroup.GraphicData[2], shortAxisSCOORDGroup.GraphicData[0], shortAxisSCOORDGroup.GraphicData[2]),\n        y: Math.max(longAxisSCOORDGroup.GraphicData[1], longAxisSCOORDGroup.GraphicData[3], shortAxisSCOORDGroup.GraphicData[1], shortAxisSCOORDGroup.GraphicData[3])\n      };\n      var state = {\n        sopInstanceUid: ReferencedSOPInstanceUID,\n        frameIndex: ReferencedFrameNumber || 1,\n        toolType: Bidirectional.toolType,\n        active: false,\n        handles: {\n          start: {\n            x: longAxisSCOORDGroup.GraphicData[0],\n            y: longAxisSCOORDGroup.GraphicData[1],\n            drawnIndependently: false,\n            allowedOutsideImage: false,\n            active: false,\n            highlight: false,\n            index: 0\n          },\n          end: {\n            x: longAxisSCOORDGroup.GraphicData[2],\n            y: longAxisSCOORDGroup.GraphicData[3],\n            drawnIndependently: false,\n            allowedOutsideImage: false,\n            active: false,\n            highlight: false,\n            index: 1\n          },\n          perpendicularStart: {\n            x: shortAxisSCOORDGroup.GraphicData[0],\n            y: shortAxisSCOORDGroup.GraphicData[1],\n            drawnIndependently: false,\n            allowedOutsideImage: false,\n            active: false,\n            highlight: false,\n            index: 2\n          },\n          perpendicularEnd: {\n            x: shortAxisSCOORDGroup.GraphicData[2],\n            y: shortAxisSCOORDGroup.GraphicData[3],\n            drawnIndependently: false,\n            allowedOutsideImage: false,\n            active: false,\n            highlight: false,\n            index: 3\n          },\n          textBox: {\n            highlight: false,\n            hasMoved: true,\n            active: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true,\n            x: bottomRight.x + 10,\n            y: bottomRight.y + 10\n          }\n        },\n        invalidated: false,\n        isCreating: false,\n        longestDiameter: longestDiameter,\n        shortestDiameter: shortestDiameter,\n        toolName: \"Bidirectional\",\n        visible: true,\n        finding: findingGroup ? findingGroup.ConceptCodeSequence : undefined,\n        findingSites: findingSiteGroups.map(function (fsg) {\n          return fsg.ConceptCodeSequence;\n        })\n      };\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var _tool$handles = tool.handles,\n        start = _tool$handles.start,\n        end = _tool$handles.end,\n        perpendicularStart = _tool$handles.perpendicularStart,\n        perpendicularEnd = _tool$handles.perpendicularEnd;\n      var shortestDiameter = tool.shortestDiameter,\n        longestDiameter = tool.longestDiameter,\n        finding = tool.finding,\n        findingSites = tool.findingSites;\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Bidirectional\";\n      return {\n        longAxis: {\n          point1: start,\n          point2: end\n        },\n        shortAxis: {\n          point1: perpendicularStart,\n          point2: perpendicularEnd\n        },\n        longAxisLength: longestDiameter,\n        shortAxisLength: shortestDiameter,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return Bidirectional;\n}();\nBidirectional$1.toolType = BIDIRECTIONAL$1;\nBidirectional$1.utilityToolType = BIDIRECTIONAL$1;\nBidirectional$1.TID300Representation = TID300Bidirectional$1;\nBidirectional$1.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === BIDIRECTIONAL$1;\n};\nMeasurementReport$1.registerTool(Bidirectional$1);\n\nvar TID300Ellipse$1 = utilities.TID300.Ellipse;\nvar ELLIPTICALROI$1 = \"EllipticalRoi\";\nvar EllipticalRoi = /*#__PURE__*/function () {\n  function EllipticalRoi() {\n    _classCallCheck(this, EllipticalRoi);\n  }\n  _createClass(EllipticalRoi, null, [{\n    key: \"getMeasurementData\",\n    value:\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        NUMGroup = _MeasurementReport$ge.NUMGroup,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup;\n      var GraphicData = SCOORDGroup.GraphicData;\n      var majorAxis = [{\n        x: GraphicData[0],\n        y: GraphicData[1]\n      }, {\n        x: GraphicData[2],\n        y: GraphicData[3]\n      }];\n      var minorAxis = [{\n        x: GraphicData[4],\n        y: GraphicData[5]\n      }, {\n        x: GraphicData[6],\n        y: GraphicData[7]\n      }];\n\n      // Calculate two opposite corners of box defined by two axes.\n\n      var minorAxisLength = Math.sqrt(Math.pow(minorAxis[0].x - minorAxis[1].x, 2) + Math.pow(minorAxis[0].y - minorAxis[1].y, 2));\n      var minorAxisDirection = {\n        x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n        y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n      };\n      var halfMinorAxisLength = minorAxisLength / 2;\n\n      // First end point of major axis + half minor axis vector\n      var corner1 = {\n        x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n        y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n      };\n\n      // Second end point of major axis - half of minor axis vector\n      var corner2 = {\n        x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n        y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n      };\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        toolType: EllipticalRoi.toolType,\n        active: false,\n        cachedStats: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        },\n        handles: {\n          end: {\n            x: corner1.x,\n            y: corner1.y,\n            highlight: false,\n            active: false\n          },\n          initialRotation: 0,\n          start: {\n            x: corner2.x,\n            y: corner2.y,\n            highlight: false,\n            active: false\n          },\n          textBox: {\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          }\n        },\n        invalidated: true,\n        visible: true\n      });\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var _tool$cachedStats = tool.cachedStats,\n        cachedStats = _tool$cachedStats === void 0 ? {} : _tool$cachedStats,\n        handles = tool.handles,\n        finding = tool.finding,\n        findingSites = tool.findingSites;\n      var start = handles.start,\n        end = handles.end;\n      var area = cachedStats.area;\n      var halfXLength = Math.abs(start.x - end.x) / 2;\n      var halfYLength = Math.abs(start.y - end.y) / 2;\n      var points = [];\n      var center = {\n        x: (start.x + end.x) / 2,\n        y: (start.y + end.y) / 2\n      };\n      if (halfXLength > halfYLength) {\n        // X-axis major\n        // Major axis\n        points.push({\n          x: center.x - halfXLength,\n          y: center.y\n        });\n        points.push({\n          x: center.x + halfXLength,\n          y: center.y\n        });\n        // Minor axis\n        points.push({\n          x: center.x,\n          y: center.y - halfYLength\n        });\n        points.push({\n          x: center.x,\n          y: center.y + halfYLength\n        });\n      } else {\n        // Y-axis major\n        // Major axis\n        points.push({\n          x: center.x,\n          y: center.y - halfYLength\n        });\n        points.push({\n          x: center.x,\n          y: center.y + halfYLength\n        });\n        // Minor axis\n        points.push({\n          x: center.x - halfXLength,\n          y: center.y\n        });\n        points.push({\n          x: center.x + halfXLength,\n          y: center.y\n        });\n      }\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n      return {\n        area: area,\n        points: points,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return EllipticalRoi;\n}();\nEllipticalRoi.toolType = ELLIPTICALROI$1;\nEllipticalRoi.utilityToolType = ELLIPTICALROI$1;\nEllipticalRoi.TID300Representation = TID300Ellipse$1;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ELLIPTICALROI$1;\n};\nMeasurementReport$1.registerTool(EllipticalRoi);\n\nvar TID300Circle$1 = utilities.TID300.Circle;\nvar CIRCLEROI$1 = \"CircleRoi\";\nvar CircleRoi = /*#__PURE__*/function () {\n  function CircleRoi() {\n    _classCallCheck(this, CircleRoi);\n  }\n  _createClass(CircleRoi, null, [{\n    key: \"getMeasurementData\",\n    value: /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        NUMGroup = _MeasurementReport$ge.NUMGroup,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup;\n      var GraphicData = SCOORDGroup.GraphicData;\n      var center = {\n        x: GraphicData[0],\n        y: GraphicData[1]\n      };\n      var end = {\n        x: GraphicData[2],\n        y: GraphicData[3]\n      };\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        toolType: CircleRoi.toolType,\n        active: false,\n        cachedStats: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0,\n          // Dummy values to be updated by cornerstone\n          radius: 0,\n          perimeter: 0\n        },\n        handles: {\n          end: _objectSpread2(_objectSpread2({}, end), {}, {\n            highlight: false,\n            active: false\n          }),\n          initialRotation: 0,\n          start: _objectSpread2(_objectSpread2({}, center), {}, {\n            highlight: false,\n            active: false\n          }),\n          textBox: {\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          }\n        },\n        invalidated: true,\n        visible: true\n      });\n      return state;\n    }\n\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var _tool$cachedStats = tool.cachedStats,\n        cachedStats = _tool$cachedStats === void 0 ? {} : _tool$cachedStats,\n        handles = tool.handles,\n        finding = tool.finding,\n        findingSites = tool.findingSites;\n      var center = handles.start,\n        end = handles.end;\n      var area = cachedStats.area,\n        radius = cachedStats.radius;\n      var perimeter = 2 * Math.PI * radius;\n      var points = [];\n      points.push(center);\n      points.push(end);\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n      return {\n        area: area,\n        perimeter: perimeter,\n        radius: radius,\n        points: points,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return CircleRoi;\n}();\nCircleRoi.toolType = CIRCLEROI$1;\nCircleRoi.utilityToolType = CIRCLEROI$1;\nCircleRoi.TID300Representation = TID300Circle$1;\nCircleRoi.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === CIRCLEROI$1;\n};\nMeasurementReport$1.registerTool(CircleRoi);\n\nvar TID300Point$2 = utilities.TID300.Point;\nvar ARROW_ANNOTATE$1 = \"ArrowAnnotate\";\nvar CORNERSTONEFREETEXT$1 = \"CORNERSTONEFREETEXT\";\nvar ArrowAnnotate$1 = /*#__PURE__*/function () {\n  function ArrowAnnotate() {\n    _classCallCheck(this, ArrowAnnotate);\n  }\n  _createClass(ArrowAnnotate, null, [{\n    key: \"getMeasurementData\",\n    value: function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup,\n        findingGroup = _MeasurementReport$ge.findingGroup;\n      var text = findingGroup.ConceptCodeSequence.CodeMeaning;\n      var GraphicData = SCOORDGroup.GraphicData;\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        toolType: ArrowAnnotate.toolType,\n        active: false,\n        handles: {\n          start: {\n            x: GraphicData[0],\n            y: GraphicData[1],\n            highlight: true,\n            active: false\n          },\n          // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n          // use the actual endpoint.\n          end: {\n            x: GraphicData.length == 4 ? GraphicData[2] : GraphicData[0] + 20,\n            y: GraphicData.length == 4 ? GraphicData[3] : GraphicData[1] + 20,\n            highlight: true,\n            active: false\n          },\n          textBox: {\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          }\n        },\n        invalidated: true,\n        text: text,\n        visible: true\n      });\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var points = [tool.handles.start, tool.handles.end];\n      var finding = tool.finding,\n        findingSites = tool.findingSites;\n      var TID300RepresentationArguments = {\n        points: points,\n        trackingIdentifierTextValue: \"cornerstoneTools@^4.0.0:ArrowAnnotate\",\n        findingSites: findingSites || []\n      };\n\n      // If freetext finding isn't present, add it from the tool text.\n      if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT$1) {\n        finding = {\n          CodeValue: CORNERSTONEFREETEXT$1,\n          CodingSchemeDesignator: \"CST4\",\n          CodeMeaning: tool.text\n        };\n      }\n      TID300RepresentationArguments.finding = finding;\n      return TID300RepresentationArguments;\n    }\n  }]);\n  return ArrowAnnotate;\n}();\nArrowAnnotate$1.toolType = ARROW_ANNOTATE$1;\nArrowAnnotate$1.utilityToolType = ARROW_ANNOTATE$1;\nArrowAnnotate$1.TID300Representation = TID300Point$2;\nArrowAnnotate$1.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ARROW_ANNOTATE$1;\n};\nMeasurementReport$1.registerTool(ArrowAnnotate$1);\n\nvar _utilities$orientatio$1 = utilities.orientation,\n  rotateDirectionCosinesInPlane$1 = _utilities$orientatio$1.rotateDirectionCosinesInPlane,\n  flipIOP$1 = _utilities$orientatio$1.flipImageOrientationPatient,\n  flipMatrix2D$1 = _utilities$orientatio$1.flipMatrix2D,\n  rotateMatrix902D$1 = _utilities$orientatio$1.rotateMatrix902D;\nvar datasetToBlob$1 = utilities.datasetToBlob,\n  BitArray$2 = utilities.BitArray,\n  DicomMessage$1 = utilities.DicomMessage,\n  DicomMetaDictionary$2 = utilities.DicomMetaDictionary;\nvar Normalizer$2 = normalizers.Normalizer;\nvar SegmentationDerivation$1 = derivations.Segmentation;\nvar Segmentation$3 = {\n  generateSegmentation: generateSegmentation$2,\n  generateToolState: generateToolState$2\n};\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation$2(images, brushData) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  var toolState = brushData.toolState,\n    segments = brushData.segments;\n\n  // Calculate the dimensions of the data cube.\n  var image0 = images[0];\n  var dims = {\n    x: image0.columns,\n    y: image0.rows,\n    z: images.length\n  };\n  dims.xy = dims.x * dims.y;\n  var numSegments = _getSegCount(seg, segments);\n  if (!numSegments) {\n    throw new Error(\"No segments to export!\");\n  }\n  var isMultiframe = image0.imageId.includes(\"?frame\");\n  var seg = _createSegFromImages$1(images, isMultiframe, options);\n  var _getNumberOfFramesPer = _getNumberOfFramesPerSegment(toolState, images, segments),\n    referencedFramesPerSegment = _getNumberOfFramesPer.referencedFramesPerSegment,\n    segmentIndicies = _getNumberOfFramesPer.segmentIndicies;\n  var NumberOfFrames = 0;\n  for (var i = 0; i < referencedFramesPerSegment.length; i++) {\n    NumberOfFrames += referencedFramesPerSegment[i].length;\n  }\n  seg.setNumberOfFrames(NumberOfFrames);\n  for (var _i = 0; _i < segmentIndicies.length; _i++) {\n    var segmentIndex = segmentIndicies[_i];\n    var referencedFrameIndicies = referencedFramesPerSegment[_i];\n\n    // Frame numbers start from 1.\n    var referencedFrameNumbers = referencedFrameIndicies.map(function (element) {\n      return element + 1;\n    });\n    var segment = segments[segmentIndex];\n    seg.addSegment(segment, _extractCornerstoneToolsPixelData(segmentIndex, referencedFrameIndicies, toolState, images, dims), referencedFrameNumbers);\n  }\n  seg.bitPackPixelData();\n  var segBlob = datasetToBlob$1(seg.dataset);\n  return segBlob;\n}\nfunction _extractCornerstoneToolsPixelData(segmentIndex, referencedFrames, toolState, images, dims) {\n  var pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n  var pixelDataIndex = 0;\n  for (var i = 0; i < referencedFrames.length; i++) {\n    var frame = referencedFrames[i];\n    var imageId = images[frame].imageId;\n    var imageIdSpecificToolState = toolState[imageId];\n    var brushPixelData = imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n    for (var p = 0; p < brushPixelData.length; p++) {\n      pixelData[pixelDataIndex] = brushPixelData[p];\n      pixelDataIndex++;\n    }\n  }\n  return pixelData;\n}\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n  var segmentIndicies = [];\n  var referencedFramesPerSegment = [];\n  for (var i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      segmentIndicies.push(i);\n      referencedFramesPerSegment.push([]);\n    }\n  }\n  for (var z = 0; z < images.length; z++) {\n    var imageId = images[z].imageId;\n    var imageIdSpecificToolState = toolState[imageId];\n    for (var _i2 = 0; _i2 < segmentIndicies.length; _i2++) {\n      var segIdx = segmentIndicies[_i2];\n      if (imageIdSpecificToolState && imageIdSpecificToolState.brush && imageIdSpecificToolState.brush.data && imageIdSpecificToolState.brush.data[segIdx] && imageIdSpecificToolState.brush.data[segIdx].pixelData) {\n        referencedFramesPerSegment[_i2].push(z);\n      }\n    }\n  }\n  return {\n    referencedFramesPerSegment: referencedFramesPerSegment,\n    segmentIndicies: segmentIndicies\n  };\n}\nfunction _getSegCount(seg, segments) {\n  var numSegments = 0;\n  for (var i = 0; i < segments.length; i++) {\n    if (segments[i]) {\n      numSegments++;\n    }\n  }\n  return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages$1(images, isMultiframe, options) {\n  var datasets = [];\n  if (isMultiframe) {\n    var image = images[0];\n    var arrayBuffer = image.data.byteArray.buffer;\n    var dicomData = DicomMessage$1.readFile(arrayBuffer);\n    var dataset = DicomMetaDictionary$2.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary$2.namifyDataset(dicomData.meta);\n    datasets.push(dataset);\n  } else {\n    for (var i = 0; i < images.length; i++) {\n      var _image = images[i];\n      var _arrayBuffer = _image.data.byteArray.buffer;\n      var _dicomData = DicomMessage$1.readFile(_arrayBuffer);\n      var _dataset = DicomMetaDictionary$2.naturalizeDataset(_dicomData.dict);\n      _dataset._meta = DicomMetaDictionary$2.namifyDataset(_dicomData.meta);\n      datasets.push(_dataset);\n    }\n  }\n  var multiframe = Normalizer$2.normalizeToDataset(datasets);\n  return new SegmentationDerivation$1([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState$2(imageIds, arrayBuffer, metadataProvider) {\n  var dicomData = DicomMessage$1.readFile(arrayBuffer);\n  var dataset = DicomMetaDictionary$2.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary$2.namifyDataset(dicomData.meta);\n  var multiframe = Normalizer$2.normalizeToDataset([dataset]);\n  var imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  var ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [].concat(_toConsumableArray(imagePlaneModule.rowCosines), _toConsumableArray(imagePlaneModule.columnCosines)) : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  var validOrientations = getValidOrientations$1(ImageOrientationPatient);\n  var SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence;\n  var sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  var sliceLength = multiframe.Columns * multiframe.Rows;\n  var segMetadata = getSegmentMetadata$1(multiframe);\n  var pixelData = unpackPixelData$1(multiframe);\n  var PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence;\n  var toolState = {};\n  var inPlane = true;\n  for (var i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n    var PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n    var ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n    var pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength), [multiframe.Rows, multiframe.Columns]);\n    var alignedPixelDataI = alignPixelDataWithSourceData$1(pixelDataI2D, ImageOrientationPatientI, validOrientations);\n    if (!alignedPixelDataI) {\n      console.warn(\"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \");\n      inPlane = false;\n      break;\n    }\n    var segmentIndex = PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber - 1;\n    var SourceImageSequence = void 0;\n    if (SharedFunctionalGroupsSequence.DerivationImageSequence && SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence) {\n      SourceImageSequence = SharedFunctionalGroupsSequence.DerivationImageSequence.SourceImageSequence[i];\n    } else {\n      SourceImageSequence = PerFrameFunctionalGroups.DerivationImageSequence.SourceImageSequence;\n    }\n    var imageId = getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider);\n    addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, alignedPixelDataI);\n  }\n  if (!inPlane) {\n    return;\n  }\n  return {\n    toolState: toolState,\n    segMetadata: segMetadata\n  };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData$1(multiframe) {\n  var segType = multiframe.SegmentationType;\n  if (segType === \"BINARY\") {\n    return BitArray$2.unpack(multiframe.PixelData);\n  }\n  var pixelData = new Uint8Array(multiframe.PixelData);\n  var max = multiframe.MaximumFractionalValue;\n  var onlyMaxAndZero = pixelData.find(function (element) {\n    return element !== 0 && element !== max;\n  }) === undefined;\n  if (!onlyMaxAndZero) {\n    log.warn(\"This is a fractional segmentation, which is not currently supported.\");\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(toolState, imageId, segmentIndex, pixelData2D) {\n  if (!toolState[imageId]) {\n    toolState[imageId] = {};\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush) {\n    toolState[imageId].brush = {};\n    toolState[imageId].brush.data = [];\n  } else if (!toolState[imageId].brush.data) {\n    toolState[imageId].brush.data = [];\n  }\n  toolState[imageId].brush.data[segmentIndex] = {};\n  var brushDataI = toolState[imageId].brush.data[segmentIndex];\n  brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n  var cToolsPixelData = brushDataI.pixelData;\n  for (var p = 0; p < cToolsPixelData.length; p++) {\n    if (pixelData2D.data[p]) {\n      cToolsPixelData[p] = 1;\n    } else {\n      cToolsPixelData[p] = 0;\n    }\n  }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(SourceImageSequence, imageIds, metadataProvider) {\n  var ReferencedSOPInstanceUID = SourceImageSequence.ReferencedSOPInstanceUID,\n    ReferencedFrameNumber = SourceImageSequence.ReferencedFrameNumber;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame$1(ReferencedSOPInstanceUID, ReferencedFrameNumber, imageIds, metadataProvider) : getImageIdOfReferencedSingleFramedSOPInstance$1(ReferencedSOPInstanceUID, imageIds, metadataProvider);\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance$1(sopInstanceUid, imageIds, metadataProvider) {\n  return imageIds.find(function (imageId) {\n    var sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    return sopCommonModule.sopInstanceUID === sopInstanceUid;\n  });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame$1(sopInstanceUid, frameNumber, imageIds, metadataProvider) {\n  var imageId = imageIds.find(function (imageId) {\n    var sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    var imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n    return (\n      //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n      sopCommonModule.sopInstanceUID === sopInstanceUid && imageIdFrameNumber === frameNumber - 1\n    );\n  });\n  return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations$1(iop) {\n  var orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP$1.h(iop);\n  orientations[2] = flipIOP$1.v(iop);\n  var iop90 = rotateDirectionCosinesInPlane$1(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP$1.h(iop90);\n  orientations[5] = flipIOP$1.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane$1(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane$1(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData$1(pixelData2D, iop, orientations) {\n  if (compareIOP(iop, orientations[0])) {\n    //Same orientation.\n    return pixelData2D;\n  } else if (compareIOP(iop, orientations[1])) {\n    //Flipped vertically.\n    return flipMatrix2D$1.v(pixelData2D);\n  } else if (compareIOP(iop, orientations[2])) {\n    //Flipped horizontally.\n    return flipMatrix2D$1.h(pixelData2D);\n  } else if (compareIOP(iop, orientations[3])) {\n    //Rotated 90 degrees.\n    return rotateMatrix902D$1(pixelData2D);\n  } else if (compareIOP(iop, orientations[4])) {\n    //Rotated 90 degrees and fliped horizontally.\n    return flipMatrix2D$1.h(rotateMatrix902D$1(pixelData2D));\n  } else if (compareIOP(iop, orientations[5])) {\n    //Rotated 90 degrees and fliped vertically.\n    return flipMatrix2D$1.v(rotateMatrix902D$1(pixelData2D));\n  } else if (compareIOP(iop, orientations[6])) {\n    //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D$1(rotateMatrix902D$1(pixelData2D));\n  } else if (compareIOP(iop, orientations[7])) {\n    //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n    return rotateMatrix902D$1(rotateMatrix902D$1(rotateMatrix902D$1(pixelData2D)));\n  }\n}\nvar dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n  return Math.abs(iop1[0] - iop2[0]) < dx && Math.abs(iop1[1] - iop2[1]) < dx && Math.abs(iop1[2] - iop2[2]) < dx && Math.abs(iop1[3] - iop2[3]) < dx && Math.abs(iop1[4] - iop2[4]) < dx && Math.abs(iop1[5] - iop2[5]) < dx;\n}\nfunction getSegmentMetadata$1(multiframe) {\n  var data = [];\n  var segmentSequence = multiframe.SegmentSequence;\n  if (Array.isArray(segmentSequence)) {\n    for (var segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n      data.push(segmentSequence[segIdx]);\n    }\n  } else {\n    // Only one segment, will be stored as an object.\n    data.push(segmentSequence);\n  }\n  return {\n    seriesInstanceUid: multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n    data: data\n  };\n}\n\nvar _utilities$orientatio = utilities.orientation,\n  rotateDirectionCosinesInPlane = _utilities$orientatio.rotateDirectionCosinesInPlane,\n  flipIOP = _utilities$orientatio.flipImageOrientationPatient,\n  flipMatrix2D = _utilities$orientatio.flipMatrix2D,\n  rotateMatrix902D = _utilities$orientatio.rotateMatrix902D,\n  nearlyEqual = _utilities$orientatio.nearlyEqual;\nvar datasetToBlob = utilities.datasetToBlob,\n  BitArray$1 = utilities.BitArray,\n  DicomMessage = utilities.DicomMessage,\n  DicomMetaDictionary$1 = utilities.DicomMetaDictionary;\nvar Normalizer$1 = normalizers.Normalizer;\nvar SegmentationDerivation = derivations.Segmentation;\nvar _utilities$compressio = utilities.compression,\n  encode = _utilities$compressio.encode,\n  decode = _utilities$compressio.decode;\nvar Segmentation$2 = {\n  generateSegmentation: generateSegmentation$1,\n  generateToolState: generateToolState$1,\n  fillSegmentation: fillSegmentation$1\n};\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\nvar generateSegmentationDefaultOptions = {\n  includeSliceSpacing: true,\n  rleEncode: true\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation$1(images, inputLabelmaps3D) {\n  var userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var isMultiframe = images[0].imageId.includes(\"?frame\");\n  var segmentation = _createSegFromImages(images, isMultiframe, userOptions);\n  return fillSegmentation$1(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation$1(segmentation, inputLabelmaps3D) {\n  var userOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = Object.assign({}, generateSegmentationDefaultOptions, userOptions);\n\n  // Use another variable so we don't redefine labelmaps3D.\n  var labelmaps3D = Array.isArray(inputLabelmaps3D) ? inputLabelmaps3D : [inputLabelmaps3D];\n  var numberOfFrames = 0;\n  var referencedFramesPerLabelmap = [];\n  var _loop = function _loop() {\n    var labelmap3D = labelmaps3D[labelmapIndex];\n    var labelmaps2D = labelmap3D.labelmaps2D,\n      metadata = labelmap3D.metadata;\n    var referencedFramesPerSegment = [];\n    for (var i = 1; i < metadata.length; i++) {\n      if (metadata[i]) {\n        referencedFramesPerSegment[i] = [];\n      }\n    }\n    var _loop2 = function _loop2(_i) {\n      var labelmap2D = labelmaps2D[_i];\n      if (labelmaps2D[_i]) {\n        var segmentsOnLabelmap = labelmap2D.segmentsOnLabelmap;\n        segmentsOnLabelmap.forEach(function (segmentIndex) {\n          if (segmentIndex !== 0) {\n            referencedFramesPerSegment[segmentIndex].push(_i);\n            numberOfFrames++;\n          }\n        });\n      }\n    };\n    for (var _i = 0; _i < labelmaps2D.length; _i++) {\n      _loop2(_i);\n    }\n    referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n  };\n  for (var labelmapIndex = 0; labelmapIndex < labelmaps3D.length; labelmapIndex++) {\n    _loop();\n  }\n  segmentation.setNumberOfFrames(numberOfFrames);\n  for (var _labelmapIndex = 0; _labelmapIndex < labelmaps3D.length; _labelmapIndex++) {\n    var referencedFramesPerSegment = referencedFramesPerLabelmap[_labelmapIndex];\n    var labelmap3D = labelmaps3D[_labelmapIndex];\n    var metadata = labelmap3D.metadata;\n    for (var segmentIndex = 1; segmentIndex < referencedFramesPerSegment.length; segmentIndex++) {\n      var referencedFrameIndicies = referencedFramesPerSegment[segmentIndex];\n      if (referencedFrameIndicies) {\n        // Frame numbers start from 1.\n        var referencedFrameNumbers = referencedFrameIndicies.map(function (element) {\n          return element + 1;\n        });\n        var segmentMetadata = metadata[segmentIndex];\n        var labelmaps = _getLabelmapsFromRefernecedFrameIndicies(labelmap3D, referencedFrameIndicies);\n        segmentation.addSegmentFromLabelmap(segmentMetadata, labelmaps, segmentIndex, referencedFrameNumbers);\n      }\n    }\n  }\n  if (options.rleEncode) {\n    var rleEncodedFrames = encode(segmentation.dataset.PixelData, numberOfFrames, segmentation.dataset.Rows, segmentation.dataset.Columns);\n\n    // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n    // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n    // added to the standard.\n    segmentation.assignToDataset({\n      BitsAllocated: \"8\",\n      BitsStored: \"8\",\n      HighBit: \"7\",\n      SegmentationType: \"FRACTIONAL\",\n      SegmentationFractionalType: \"PROBABILITY\",\n      MaximumFractionalValue: \"255\"\n    });\n    segmentation.dataset._meta.TransferSyntaxUID = {\n      Value: [\"1.2.840.10008.1.2.5\"],\n      vr: \"UI\"\n    };\n    segmentation.dataset._vrMap.PixelData = \"OB\";\n    segmentation.dataset.PixelData = rleEncodedFrames;\n  } else {\n    // If no rleEncoding, at least bitpack the data.\n    segmentation.bitPackPixelData();\n  }\n  var segBlob = datasetToBlob(segmentation.dataset);\n  return segBlob;\n}\nfunction _getLabelmapsFromRefernecedFrameIndicies(labelmap3D, referencedFrameIndicies) {\n  var labelmaps2D = labelmap3D.labelmaps2D;\n  var labelmaps = [];\n  for (var i = 0; i < referencedFrameIndicies.length; i++) {\n    var frame = referencedFrameIndicies[i];\n    labelmaps.push(labelmaps2D[frame].pixelData);\n  }\n  return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n  var datasets = [];\n  if (isMultiframe) {\n    var image = images[0];\n    var arrayBuffer = image.data.byteArray.buffer;\n    var dicomData = DicomMessage.readFile(arrayBuffer);\n    var dataset = DicomMetaDictionary$1.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary$1.namifyDataset(dicomData.meta);\n    datasets.push(dataset);\n  } else {\n    for (var i = 0; i < images.length; i++) {\n      var _image = images[i];\n      var _arrayBuffer = _image.data.byteArray.buffer;\n      var _dicomData = DicomMessage.readFile(_arrayBuffer);\n      var _dataset = DicomMetaDictionary$1.naturalizeDataset(_dicomData.dict);\n      _dataset._meta = DicomMetaDictionary$1.namifyDataset(_dicomData.meta);\n      datasets.push(_dataset);\n    }\n  }\n  var multiframe = Normalizer$1.normalizeToDataset(datasets);\n  return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds - An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {bool} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nfunction generateToolState$1(imageIds, arrayBuffer, metadataProvider) {\n  var skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  var dicomData = DicomMessage.readFile(arrayBuffer);\n  var dataset = DicomMetaDictionary$1.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary$1.namifyDataset(dicomData.meta);\n  var multiframe = Normalizer$1.normalizeToDataset([dataset]);\n  var imagePlaneModule = metadataProvider.get(\"imagePlaneModule\", imageIds[0]);\n  var generalSeriesModule = metadataProvider.get(\"generalSeriesModule\", imageIds[0]);\n  var SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n  if (!imagePlaneModule) {\n    console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n  }\n  var ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines) ? [].concat(_toConsumableArray(imagePlaneModule.rowCosines), _toConsumableArray(imagePlaneModule.columnCosines)) : [imagePlaneModule.rowCosines.x, imagePlaneModule.rowCosines.y, imagePlaneModule.rowCosines.z, imagePlaneModule.columnCosines.x, imagePlaneModule.columnCosines.y, imagePlaneModule.columnCosines.z];\n\n  // Get IOP from ref series, compute supported orientations:\n  var validOrientations = getValidOrientations(ImageOrientationPatient);\n  var sliceLength = multiframe.Columns * multiframe.Rows;\n  var segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n  var TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n  var pixelData;\n  if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n    var rleEncodedFrames = Array.isArray(multiframe.PixelData) ? multiframe.PixelData : [multiframe.PixelData];\n    pixelData = decode(rleEncodedFrames, multiframe.Rows, multiframe.Columns);\n    if (multiframe.BitsStored === 1) {\n      console.warn(\"No implementation for rle + bitbacking.\");\n      return;\n    }\n  } else {\n    pixelData = unpackPixelData(multiframe);\n    if (!pixelData) {\n      throw new Error(\"Fractional segmentations are not yet supported\");\n    }\n  }\n  var orientation = checkOrientation(multiframe, validOrientations, [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length], tolerance);\n  var overlapping = false;\n  if (!skipOverlapping) {\n    overlapping = checkSEGsOverlapping(pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance);\n  }\n  var insertFunction;\n  switch (orientation) {\n    case \"Planar\":\n      if (overlapping) {\n        insertFunction = insertOverlappingPixelDataPlanar;\n      } else {\n        insertFunction = insertPixelDataPlanar;\n      }\n      break;\n    case \"Perpendicular\":\n      //insertFunction = insertPixelDataPerpendicular;\n      throw new Error(\"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\");\n    case \"Oblique\":\n      throw new Error(\"Segmentations oblique to the acquisition plane of the source data are not yet supported.\");\n  }\n\n  /* if SEGs are overlapping:\n  1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n  2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n  3) insertFunction will return the number of LabelMaps\n  4) generateToolState return is an array*/\n\n  var segmentsOnFrameArray = [];\n  segmentsOnFrameArray[0] = [];\n  var segmentsOnFrame = [];\n  var arrayBufferLength = sliceLength * imageIds.length * 2; // 2 bytes per label voxel in cst4.\n  var labelmapBufferArray = [];\n  labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n  insertFunction(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance);\n  return {\n    labelmapBufferArray: labelmapBufferArray,\n    segMetadata: segMetadata,\n    segmentsOnFrame: segmentsOnFrame,\n    segmentsOnFrameArray: segmentsOnFrameArray\n  };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      metadataProvider  A Cornerstone metadataProvider to query\n *                                         metadata from imageIds.\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance) {\n  var imageId = undefined;\n  if (!multiframe) {\n    return imageId;\n  }\n  var FrameOfReferenceUID = multiframe.FrameOfReferenceUID,\n    PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence,\n    SourceImageSequence = multiframe.SourceImageSequence,\n    ReferencedSeriesSequence = multiframe.ReferencedSeriesSequence;\n  if (!PerFrameFunctionalGroupsSequence || PerFrameFunctionalGroupsSequence.length === 0) {\n    return imageId;\n  }\n  var PerFrameFunctionalGroup = PerFrameFunctionalGroupsSequence[frameSegment];\n  if (!PerFrameFunctionalGroup) {\n    return imageId;\n  }\n  var frameSourceImageSequence = undefined;\n  if (SourceImageSequence && SourceImageSequence.length !== 0) {\n    frameSourceImageSequence = SourceImageSequence[frameSegment];\n  } else if (PerFrameFunctionalGroup.DerivationImageSequence) {\n    var DerivationImageSequence = PerFrameFunctionalGroup.DerivationImageSequence;\n    if (Array.isArray(DerivationImageSequence)) {\n      if (DerivationImageSequence.length !== 0) {\n        DerivationImageSequence = DerivationImageSequence[0];\n      } else {\n        DerivationImageSequence = undefined;\n      }\n    }\n    if (DerivationImageSequence) {\n      frameSourceImageSequence = DerivationImageSequence.SourceImageSequence;\n      if (Array.isArray(frameSourceImageSequence)) {\n        if (frameSourceImageSequence.length !== 0) {\n          frameSourceImageSequence = frameSourceImageSequence[0];\n        } else {\n          frameSourceImageSequence = undefined;\n        }\n      }\n    }\n  }\n  if (frameSourceImageSequence) {\n    imageId = getImageIdOfSourceImagebySourceImageSequence(frameSourceImageSequence, imageIds, metadataProvider);\n  }\n  if (imageId === undefined && ReferencedSeriesSequence) {\n    var referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence) ? ReferencedSeriesSequence[0] : ReferencedSeriesSequence;\n    var ReferencedSeriesInstanceUID = referencedSeriesSequence.SeriesInstanceUID;\n    imageId = getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance);\n  }\n  return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance) {\n  var SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence,\n    SegmentSequence = multiframe.SegmentSequence,\n    Rows = multiframe.Rows,\n    Columns = multiframe.Columns;\n  var numberOfSegs = SegmentSequence.length;\n  if (numberOfSegs < 2) {\n    return false;\n  }\n  var sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  var sliceLength = Columns * Rows;\n  var groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n  /** sort groupsLen to have all the segments for each frame in an array\n   * frame 2 : 1, 2\n   * frame 4 : 1, 3\n   * frame 5 : 4\n   */\n\n  var frameSegmentsMapping = new Map();\n  var _loop3 = function _loop3() {\n    var segmentIndex = getSegmentIndex(multiframe, frameSegment);\n    if (segmentIndex === undefined) {\n      console.warn(\"Could not retrieve the segment index for frame segment \" + frameSegment + \", skipping this frame.\");\n      return \"continue\";\n    }\n    var imageId = findReferenceSourceImageId(multiframe, frameSegment, imageIds, metadataProvider, tolerance);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + frameSegment + \".\");\n      return \"continue\";\n    }\n    var imageIdIndex = imageIds.findIndex(function (element) {\n      return element === imageId;\n    });\n    if (frameSegmentsMapping.has(imageIdIndex)) {\n      var segmentArray = frameSegmentsMapping.get(imageIdIndex);\n      if (!segmentArray.includes(frameSegment)) {\n        segmentArray.push(frameSegment);\n        frameSegmentsMapping.set(imageIdIndex, segmentArray);\n      }\n    } else {\n      frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n    }\n  };\n  for (var frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n    var _ret = _loop3();\n    if (_ret === \"continue\") continue;\n  }\n  var _iterator = _createForOfIteratorHelper(frameSegmentsMapping.entries()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        role = _step$value[1];\n      var temp2DArray = new Uint16Array(sliceLength).fill(0);\n      for (var i = 0; i < role.length; ++i) {\n        var _frameSegment = role[i];\n        var PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[_frameSegment];\n        var ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n        var pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, _frameSegment * sliceLength, sliceLength), [Rows, Columns]);\n        var alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n        if (!alignedPixelDataI) {\n          console.warn(\"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\");\n          continue;\n        }\n        var data = alignedPixelDataI.data;\n        for (var j = 0, len = data.length; j < len; ++j) {\n          if (data[j] !== 0) {\n            temp2DArray[j]++;\n            if (temp2DArray[j] > 1) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return false;\n}\nfunction insertOverlappingPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance) {\n  var SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence,\n    Rows = multiframe.Rows,\n    Columns = multiframe.Columns;\n  var sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  var sliceLength = Columns * Rows;\n  var arrayBufferLength = sliceLength * imageIds.length * 2; // 2 bytes per label voxel in cst4.\n\n  // indicate the number of labelMaps\n  var M = 1;\n\n  // indicate the current labelMap array index;\n  var m = 0;\n\n  // temp array for checking overlaps\n  var tempBuffer = labelmapBufferArray[m].slice(0);\n\n  // temp list for checking overlaps\n  var tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n\n  /** split overlapping SEGs algorithm for each segment:\n   *  A) copy the labelmapBuffer in the array with index 0\n   *  B) add the segment pixel per pixel on the copied buffer from (A)\n   *  C) if no overlap, copy the results back on the orignal array from (A)\n   *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n   */\n\n  var numberOfSegs = multiframe.SegmentSequence.length;\n  for (var segmentIndexToProcess = 1; segmentIndexToProcess <= numberOfSegs; ++segmentIndexToProcess) {\n    var _loop4 = function _loop4(_i2) {\n      var PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[_i2];\n      var segmentIndex = getSegmentIndex(multiframe, _i2);\n      if (segmentIndex === undefined) {\n        throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n      }\n      if (segmentIndex !== segmentIndexToProcess) {\n        i = _i2;\n        return \"continue\";\n      }\n      var ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n      var pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, _i2 * sliceLength, sliceLength), [Rows, Columns]);\n      var alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n      if (!alignedPixelDataI) {\n        throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n      }\n      var imageId = findReferenceSourceImageId(multiframe, _i2, imageIds, metadataProvider, tolerance);\n      if (!imageId) {\n        console.warn(\"Image not present in stack, can't import frame : \" + _i2 + \".\");\n        i = _i2;\n        return \"continue\";\n      }\n      var sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n      if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n        throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n      }\n      var imageIdIndex = imageIds.findIndex(function (element) {\n        return element === imageId;\n      });\n      var byteOffset = sliceLength * 2 * imageIdIndex; // 2 bytes/pixel\n\n      var labelmap2DView = new Uint16Array(tempBuffer, byteOffset, sliceLength);\n      var data = alignedPixelDataI.data;\n      var segmentOnFrame = false;\n      for (var j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n        if (data[j]) {\n          if (labelmap2DView[j] !== 0) {\n            m++;\n            if (m >= M) {\n              labelmapBufferArray[m] = new ArrayBuffer(arrayBufferLength);\n              segmentsOnFrameArray[m] = [];\n              M++;\n            }\n            tempBuffer = labelmapBufferArray[m].slice(0);\n            tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n            _i2 = 0;\n            break;\n          } else {\n            labelmap2DView[j] = segmentIndex;\n            segmentOnFrame = true;\n          }\n        }\n      }\n      if (segmentOnFrame) {\n        if (!tempSegmentsOnFrame[imageIdIndex]) {\n          tempSegmentsOnFrame[imageIdIndex] = [];\n        }\n        tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n        if (!segmentsOnFrame[imageIdIndex]) {\n          segmentsOnFrame[imageIdIndex] = [];\n        }\n        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n      }\n      i = _i2;\n    };\n    for (var i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length; i < groupsLen; ++i) {\n      var _ret2 = _loop4(i);\n      if (_ret2 === \"continue\") continue;\n    }\n    labelmapBufferArray[m] = tempBuffer.slice(0);\n    segmentsOnFrameArray[m] = cloneDeep(tempSegmentsOnFrame);\n\n    // reset temp variables/buffers for new segment\n    m = 0;\n    tempBuffer = labelmapBufferArray[m].slice(0);\n    tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n  }\n}\nvar getSegmentIndex = function getSegmentIndex(multiframe, frame) {\n  var PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence,\n    SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence;\n  var PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n  return PerFrameFunctionalGroups && PerFrameFunctionalGroups.SegmentIdentificationSequence ? PerFrameFunctionalGroups.SegmentIdentificationSequence.ReferencedSegmentNumber : SharedFunctionalGroupsSequence.SegmentIdentificationSequence ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence.ReferencedSegmentNumber : undefined;\n};\nfunction insertPixelDataPlanar(segmentsOnFrame, segmentsOnFrameArray, labelmapBufferArray, pixelData, multiframe, imageIds, validOrientations, metadataProvider, tolerance) {\n  var SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence,\n    Rows = multiframe.Rows,\n    Columns = multiframe.Columns;\n  var sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n  var sliceLength = Columns * Rows;\n  var _loop5 = function _loop5() {\n    var PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n    var ImageOrientationPatientI = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n    var pixelDataI2D = ndarray(new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength), [Rows, Columns]);\n    var alignedPixelDataI = alignPixelDataWithSourceData(pixelDataI2D, ImageOrientationPatientI, validOrientations, tolerance);\n    if (!alignedPixelDataI) {\n      throw new Error(\"Individual SEG frames are out of plane with respect to the first SEG frame. \" + \"This is not yet supported. Aborting segmentation loading.\");\n    }\n    var segmentIndex = getSegmentIndex(multiframe, i);\n    if (segmentIndex === undefined) {\n      throw new Error(\"Could not retrieve the segment index. Aborting segmentation loading.\");\n    }\n    var imageId = findReferenceSourceImageId(multiframe, i, imageIds, metadataProvider, tolerance);\n    if (!imageId) {\n      console.warn(\"Image not present in stack, can't import frame : \" + i + \".\");\n      return \"continue\";\n    }\n    var sourceImageMetadata = metadataProvider.get(\"instance\", imageId);\n    if (Rows !== sourceImageMetadata.Rows || Columns !== sourceImageMetadata.Columns) {\n      throw new Error(\"Individual SEG frames have different geometry dimensions (Rows and Columns) \" + \"respect to the source image reference frame. This is not yet supported. \" + \"Aborting segmentation loading. \");\n    }\n    var imageIdIndex = imageIds.findIndex(function (element) {\n      return element === imageId;\n    });\n    var byteOffset = sliceLength * 2 * imageIdIndex; // 2 bytes/pixel\n\n    var labelmap2DView = new Uint16Array(labelmapBufferArray[0], byteOffset, sliceLength);\n    var data = alignedPixelDataI.data;\n    for (var j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n      if (data[j]) {\n        for (var x = j; x < len; ++x) {\n          if (data[x]) {\n            labelmap2DView[x] = segmentIndex;\n          }\n        }\n        if (!segmentsOnFrame[imageIdIndex]) {\n          segmentsOnFrame[imageIdIndex] = [];\n        }\n        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n        break;\n      }\n    }\n  };\n  for (var i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length; i < groupsLen; ++i) {\n    var _ret3 = _loop5();\n    if (_ret3 === \"continue\") continue;\n  }\n}\nfunction checkOrientation(multiframe, validOrientations, sourceDataDimensions, tolerance) {\n  var SharedFunctionalGroupsSequence = multiframe.SharedFunctionalGroupsSequence,\n    PerFrameFunctionalGroupsSequence = multiframe.PerFrameFunctionalGroupsSequence;\n  var sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence ? SharedFunctionalGroupsSequence.PlaneOrientationSequence.ImageOrientationPatient : undefined;\n\n  // Check if in plane.\n  var PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n  var iop = sharedImageOrientationPatient || PerFrameFunctionalGroups.PlaneOrientationSequence.ImageOrientationPatient;\n  var inPlane = validOrientations.some(function (operation) {\n    return compareArrays(iop, operation, tolerance);\n  });\n  if (inPlane) {\n    return \"Planar\";\n  }\n  if (checkIfPerpendicular(iop, validOrientations[0], tolerance) && sourceDataDimensions.includes(multiframe.Rows) && sourceDataDimensions.includes(multiframe.Columns)) {\n    // Perpendicular and fits on same grid.\n    return \"Perpendicular\";\n  }\n  return \"Oblique\";\n}\n\n/**\n * checkIfPerpendicular - Returns true if iop1 and iop2 are perpendicular\n * within a tolerance.\n *\n * @param  {Number[6]} iop1 An ImageOrientationPatient array.\n * @param  {Number[6]} iop2 An ImageOrientationPatient array.\n * @param  {Number} tolerance.\n * @return {Boolean} True if iop1 and iop2 are equal.\n */\nfunction checkIfPerpendicular(iop1, iop2, tolerance) {\n  var absDotColumnCosines = Math.abs(iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]);\n  var absDotRowCosines = Math.abs(iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]);\n  return (absDotColumnCosines < tolerance || Math.abs(absDotColumnCosines - 1) < tolerance) && (absDotRowCosines < tolerance || Math.abs(absDotRowCosines - 1) < tolerance);\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n  var segType = multiframe.SegmentationType;\n  var data;\n  if (Array.isArray(multiframe.PixelData)) {\n    data = multiframe.PixelData[0];\n  } else {\n    data = multiframe.PixelData;\n  }\n  if (data === undefined) {\n    log.error(\"This segmentation pixeldata is undefined.\");\n  }\n  if (segType === \"BINARY\") {\n    return BitArray$1.unpack(data);\n  }\n  var pixelData = new Uint8Array(data);\n  var max = multiframe.MaximumFractionalValue;\n  var onlyMaxAndZero = pixelData.find(function (element) {\n    return element !== 0 && element !== max;\n  }) === undefined;\n  if (!onlyMaxAndZero) {\n    // This is a fractional segmentation, which is not currently supported.\n    return;\n  }\n  log.warn(\"This segmentation object is actually binary... processing as such.\");\n  return pixelData;\n}\n\n/**\n * getImageIdOfSourceImagebySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   metadataProvider     A Cornerstone metadataProvider to query\n *                                         metadata from imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebySourceImageSequence(SourceImageSequence, imageIds, metadataProvider) {\n  var ReferencedSOPInstanceUID = SourceImageSequence.ReferencedSOPInstanceUID,\n    ReferencedFrameNumber = SourceImageSequence.ReferencedFrameNumber;\n  return ReferencedFrameNumber ? getImageIdOfReferencedFrame(ReferencedSOPInstanceUID, ReferencedFrameNumber, imageIds, metadataProvider) : getImageIdOfReferencedSingleFramedSOPInstance(ReferencedSOPInstanceUID, imageIds, metadataProvider);\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    metadataProvider               A Cornerstone metadataProvider to query\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(ReferencedSeriesInstanceUID, FrameOfReferenceUID, PerFrameFunctionalGroup, imageIds, metadataProvider, tolerance) {\n  if (ReferencedSeriesInstanceUID === undefined || PerFrameFunctionalGroup.PlanePositionSequence === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined || PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient === undefined) {\n    return undefined;\n  }\n  for (var imageIdsIndexc = 0; imageIdsIndexc < imageIds.length; ++imageIdsIndexc) {\n    var sourceImageMetadata = metadataProvider.get(\"instance\", imageIds[imageIdsIndexc]);\n    if (sourceImageMetadata === undefined || sourceImageMetadata.ImagePositionPatient === undefined || sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID || sourceImageMetadata.SeriesInstanceUID !== ReferencedSeriesInstanceUID) {\n      continue;\n    }\n    if (compareArrays(PerFrameFunctionalGroup.PlanePositionSequence[0].ImagePositionPatient, sourceImageMetadata.ImagePositionPatient, tolerance)) {\n      return imageIds[imageIdsIndexc];\n    }\n  }\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(sopInstanceUid, imageIds, metadataProvider) {\n  return imageIds.find(function (imageId) {\n    var sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    return sopCommonModule.sopInstanceUID === sopInstanceUid;\n  });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(sopInstanceUid, frameNumber, imageIds, metadataProvider) {\n  var imageId = imageIds.find(function (imageId) {\n    var sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n    if (!sopCommonModule) {\n      return;\n    }\n    var imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n    return (\n      //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n      sopCommonModule.sopInstanceUID === sopInstanceUid && imageIdFrameNumber === frameNumber - 1\n    );\n  });\n  return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n  var orientations = [];\n\n  // [0,  1,  2]: 0,   0hf,   0vf\n  // [3,  4,  5]: 90,  90hf,  90vf\n  // [6, 7]:      180, 270\n\n  orientations[0] = iop;\n  orientations[1] = flipIOP.h(iop);\n  orientations[2] = flipIOP.v(iop);\n  var iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n  orientations[3] = iop90;\n  orientations[4] = flipIOP.h(iop90);\n  orientations[5] = flipIOP.v(iop90);\n  orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n  orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n  return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations, tolerance) {\n  if (compareArrays(iop, orientations[0], tolerance)) {\n    return pixelData2D;\n  } else if (compareArrays(iop, orientations[1], tolerance)) {\n    // Flipped vertically.\n\n    // Undo Flip\n    return flipMatrix2D.v(pixelData2D);\n  } else if (compareArrays(iop, orientations[2], tolerance)) {\n    // Flipped horizontally.\n\n    // Unfo flip\n    return flipMatrix2D.h(pixelData2D);\n  } else if (compareArrays(iop, orientations[3], tolerance)) {\n    //Rotated 90 degrees\n\n    // Rotate back\n    return rotateMatrix902D(pixelData2D);\n  } else if (compareArrays(iop, orientations[4], tolerance)) {\n    //Rotated 90 degrees and fliped horizontally.\n\n    // Undo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n  } else if (compareArrays(iop, orientations[5], tolerance)) {\n    // Rotated 90 degrees and fliped vertically\n\n    // Unfo flip and rotate back.\n    return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n  } else if (compareArrays(iop, orientations[6], tolerance)) {\n    // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n    return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n  } else if (compareArrays(iop, orientations[7], tolerance)) {\n    // Rotated 270 degrees\n\n    // Rotate back.\n    return rotateMatrix902D(rotateMatrix902D(rotateMatrix902D(pixelData2D)));\n  }\n}\n\n/**\n * compareArrays - Returns true if array1 and array2 are equal\n * within a tolerance.\n *\n * @param  {Number[]} array1 - An array.\n * @param  {Number[]} array2 - An array.\n * @param {Number} tolerance.\n * @return {Boolean} True if array1 and array2 are equal.\n */\nfunction compareArrays(array1, array2, tolerance) {\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (var i = 0; i < array1.length; ++i) {\n    if (!nearlyEqual(array1[i], array2[i], tolerance)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n  var segmentSequence = multiframe.SegmentSequence;\n  var data = [];\n  if (Array.isArray(segmentSequence)) {\n    data = [undefined].concat(_toConsumableArray(segmentSequence));\n  } else {\n    // Only one segment, will be stored as an object.\n    data = [undefined, segmentSequence];\n  }\n  return {\n    seriesInstanceUid: seriesInstanceUid,\n    data: data\n  };\n}\n\nvar Segmentation$1 = {\n  generateSegmentation: generateSegmentation,\n  generateToolState: generateToolState,\n  fillSegmentation: fillSegmentation\n};\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(images, labelmaps3DorBrushData) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  var cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation$2.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$3.generateSegmentation(images, labelmaps3DorBrushData, options);\n  }\n  console.warn(\"No generateSegmentation adapater for cornerstone version \".concat(cornerstoneToolsVersion, \", exiting.\"));\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {bool} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n  var skipOverlapping = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var tolerance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1e-3;\n  var cornerstoneToolsVersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation$2.generateToolState(imageIds, arrayBuffer, metadataProvider, skipOverlapping, tolerance);\n  }\n  if (cornerstoneToolsVersion === 3) {\n    return Segmentation$3.generateToolState(imageIds, arrayBuffer, metadataProvider);\n  }\n  console.warn(\"No generateToolState adapater for cornerstone version \".concat(cornerstoneToolsVersion, \", exiting.\"));\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    includeSliceSpacing: true\n  };\n  var cornerstoneToolsVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;\n  if (cornerstoneToolsVersion === 4) {\n    return Segmentation$2.fillSegmentation(segmentation, inputLabelmaps3D, options);\n  }\n  console.warn(\"No generateSegmentation adapater for cornerstone version \".concat(cornerstoneToolsVersion, \", exiting.\"));\n}\n\nvar TID300CobbAngle$2 = utilities.TID300.CobbAngle;\nvar COBB_ANGLE = \"CobbAngle\";\nvar CobbAngle$1 = /*#__PURE__*/function () {\n  function CobbAngle() {\n    _classCallCheck(this, CobbAngle);\n  }\n  _createClass(CobbAngle, null, [{\n    key: \"getMeasurementData\",\n    value:\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        NUMGroup = _MeasurementReport$ge.NUMGroup,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup;\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n        toolType: CobbAngle.toolType,\n        handles: {\n          start: {},\n          end: {},\n          start2: {\n            highlight: true,\n            drawnIndependently: true\n          },\n          end2: {\n            highlight: true,\n            drawnIndependently: true\n          },\n          textBox: {\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          }\n        }\n      });\n      var _SCOORDGroup$GraphicD = _slicedToArray(SCOORDGroup.GraphicData, 8);\n      state.handles.start.x = _SCOORDGroup$GraphicD[0];\n      state.handles.start.y = _SCOORDGroup$GraphicD[1];\n      state.handles.end.x = _SCOORDGroup$GraphicD[2];\n      state.handles.end.y = _SCOORDGroup$GraphicD[3];\n      state.handles.start2.x = _SCOORDGroup$GraphicD[4];\n      state.handles.start2.y = _SCOORDGroup$GraphicD[5];\n      state.handles.end2.x = _SCOORDGroup$GraphicD[6];\n      state.handles.end2.y = _SCOORDGroup$GraphicD[7];\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var handles = tool.handles,\n        finding = tool.finding,\n        findingSites = tool.findingSites;\n      var point1 = handles.start;\n      var point2 = handles.end;\n      var point3 = handles.start2;\n      var point4 = handles.end2;\n      var rAngle = tool.rAngle;\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n      return {\n        point1: point1,\n        point2: point2,\n        point3: point3,\n        point4: point4,\n        rAngle: rAngle,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return CobbAngle;\n}();\nCobbAngle$1.toolType = COBB_ANGLE;\nCobbAngle$1.utilityToolType = COBB_ANGLE;\nCobbAngle$1.TID300Representation = TID300CobbAngle$2;\nCobbAngle$1.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === COBB_ANGLE;\n};\nMeasurementReport$1.registerTool(CobbAngle$1);\n\nvar TID300Angle = utilities.TID300.Angle;\nvar ANGLE = \"Angle\";\nvar Angle$1 = /*#__PURE__*/function () {\n  function Angle() {\n    _classCallCheck(this, Angle);\n  }\n  _createClass(Angle, null, [{\n    key: \"getMeasurementData\",\n    value:\n    /**\n     * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n     */\n    function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        NUMGroup = _MeasurementReport$ge.NUMGroup,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup;\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n        toolType: Angle.toolType,\n        handles: {\n          start: {},\n          middle: {},\n          end: {},\n          textBox: {\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          }\n        }\n      });\n      var _SCOORDGroup$GraphicD = _slicedToArray(SCOORDGroup.GraphicData, 8);\n      state.handles.start.x = _SCOORDGroup$GraphicD[0];\n      state.handles.start.y = _SCOORDGroup$GraphicD[1];\n      state.handles.middle.x = _SCOORDGroup$GraphicD[2];\n      state.handles.middle.y = _SCOORDGroup$GraphicD[3];\n      state.handles.middle.x = _SCOORDGroup$GraphicD[4];\n      state.handles.middle.y = _SCOORDGroup$GraphicD[5];\n      state.handles.end.x = _SCOORDGroup$GraphicD[6];\n      state.handles.end.y = _SCOORDGroup$GraphicD[7];\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var handles = tool.handles,\n        finding = tool.finding,\n        findingSites = tool.findingSites;\n      var point1 = handles.start;\n      var point2 = handles.middle;\n      var point3 = handles.middle;\n      var point4 = handles.end;\n      var rAngle = tool.rAngle;\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n      return {\n        point1: point1,\n        point2: point2,\n        point3: point3,\n        point4: point4,\n        rAngle: rAngle,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return Angle;\n}();\nAngle$1.toolType = ANGLE;\nAngle$1.utilityToolType = ANGLE;\nAngle$1.TID300Representation = TID300Angle;\nAngle$1.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === ANGLE;\n};\nMeasurementReport$1.registerTool(Angle$1);\n\nvar TID300Polyline$2 = utilities.TID300.Polyline;\nvar RectangleRoi = /*#__PURE__*/function () {\n  function RectangleRoi() {\n    _classCallCheck(this, RectangleRoi);\n  }\n  _createClass(RectangleRoi, null, [{\n    key: \"getMeasurementData\",\n    value: function getMeasurementData(MeasurementGroup) {\n      var _MeasurementReport$ge = MeasurementReport$1.getSetupMeasurementData(MeasurementGroup),\n        defaultState = _MeasurementReport$ge.defaultState,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup,\n        NUMGroup = _MeasurementReport$ge.NUMGroup;\n      var state = _objectSpread2(_objectSpread2({}, defaultState), {}, {\n        toolType: RectangleRoi.toolType,\n        handles: {\n          start: {},\n          end: {},\n          textBox: {\n            active: false,\n            hasMoved: false,\n            movesIndependently: false,\n            drawnIndependently: true,\n            allowedOutsideImage: true,\n            hasBoundingBox: true\n          },\n          initialRotation: 0\n        },\n        cachedStats: {\n          area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        },\n        color: undefined,\n        invalidated: true\n      });\n      var _SCOORDGroup$GraphicD = _slicedToArray(SCOORDGroup.GraphicData, 6);\n      state.handles.start.x = _SCOORDGroup$GraphicD[0];\n      state.handles.start.y = _SCOORDGroup$GraphicD[1];\n      _SCOORDGroup$GraphicD[2];\n      _SCOORDGroup$GraphicD[3];\n      state.handles.end.x = _SCOORDGroup$GraphicD[4];\n      state.handles.end.y = _SCOORDGroup$GraphicD[5];\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool) {\n      var finding = tool.finding,\n        findingSites = tool.findingSites,\n        _tool$cachedStats = tool.cachedStats,\n        cachedStats = _tool$cachedStats === void 0 ? {} : _tool$cachedStats,\n        handles = tool.handles;\n      var start = handles.start,\n        end = handles.end;\n      var points = [start, {\n        x: start.x,\n        y: end.y\n      }, end, {\n        x: end.x,\n        y: start.y\n      }];\n      var area = cachedStats.area,\n        perimeter = cachedStats.perimeter;\n      var trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:RectangleRoi\";\n      return {\n        points: points,\n        area: area,\n        perimeter: perimeter,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return RectangleRoi;\n}();\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline$2;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone4Tag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n    return false;\n  }\n  return toolType === RectangleRoi.toolType;\n};\nMeasurementReport$1.registerTool(RectangleRoi);\n\nvar Cornerstone = {\n  Length: Length$1,\n  FreehandRoi: FreehandRoi,\n  Bidirectional: Bidirectional$1,\n  EllipticalRoi: EllipticalRoi,\n  CircleRoi: CircleRoi,\n  ArrowAnnotate: ArrowAnnotate$1,\n  MeasurementReport: MeasurementReport$1,\n  Segmentation: Segmentation$1,\n  CobbAngle: CobbAngle$1,\n  Angle: Angle$1,\n  RectangleRoi: RectangleRoi\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nvar CORNERSTONE_3D_TAG = \"Cornerstone3DTools@^0.1.0\";\n\n// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nvar CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nvar CodingSchemeDesignator$1 = \"CORNERSTONEJS\";\nvar CodingScheme = {\n  CodingSchemeDesignator: CodingSchemeDesignator$1,\n  codeValues: {\n    CORNERSTONEFREETEXT: CORNERSTONEFREETEXT\n  }\n};\n\nvar TID1500 = utilities.TID1500, addAccessors = utilities.addAccessors;\nvar StructuredReport = derivations.StructuredReport;\nvar Normalizer = normalizers.Normalizer;\nvar TID1500MeasurementReport = TID1500.TID1500MeasurementReport, TID1501MeasurementGroup = TID1500.TID1501MeasurementGroup;\nvar DicomMetaDictionary = data.DicomMetaDictionary;\nvar FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\nvar FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\nvar FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\nvar codeValueMatch = function (group, code, oldCode) {\n    var ConceptNameCodeSequence = group.ConceptNameCodeSequence;\n    if (!ConceptNameCodeSequence)\n        return;\n    var CodingSchemeDesignator = ConceptNameCodeSequence.CodingSchemeDesignator, CodeValue = ConceptNameCodeSequence.CodeValue;\n    return ((CodingSchemeDesignator == code.CodingSchemeDesignator &&\n        CodeValue == code.CodeValue) ||\n        (oldCode &&\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\n            CodeValue == oldCode.CodeValue));\n};\nfunction getTID300ContentItem(tool, toolType, ReferencedSOPSequence, toolClass, worldToImageCoords) {\n    var args = toolClass.getTID300RepresentationArguments(tool, worldToImageCoords);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n    var TID300Measurement = new toolClass.TID300Representation(args);\n    return TID300Measurement;\n}\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords) {\n    var toolTypeData = toolData[toolType];\n    var toolClass = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n    if (!toolTypeData ||\n        !toolTypeData.data ||\n        !toolTypeData.data.length ||\n        !toolClass) {\n        return;\n    }\n    // Loop through the array of tool instances\n    // for this tool\n    var Measurements = toolTypeData.data.map(function (tool) {\n        return getTID300ContentItem(tool, toolType, ReferencedSOPSequence, toolClass, worldToImageCoords);\n    });\n    return new TID1501MeasurementGroup(Measurements);\n}\nvar MeasurementReport = /** @class */ (function () {\n    function MeasurementReport() {\n    }\n    MeasurementReport.getCornerstoneLabelFromDefaultState = function (defaultState) {\n        var _a = defaultState.findingSites, findingSites = _a === void 0 ? [] : _a, finding = defaultState.finding;\n        var cornersoneFreeTextCodingValue = CodingScheme.codeValues.CORNERSTONEFREETEXT;\n        var freeTextLabel = findingSites.find(function (fs) { return fs.CodeValue === cornersoneFreeTextCodingValue; });\n        if (freeTextLabel) {\n            return freeTextLabel.CodeMeaning;\n        }\n        if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n            return finding.CodeMeaning;\n        }\n    };\n    MeasurementReport.generateDatasetMeta = function () {\n        // TODO: what is the correct metaheader\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n        // TODO: move meta creation to happen in derivations.js\n        var fileMetaInformationVersionArray = new Uint8Array(2);\n        fileMetaInformationVersionArray[1] = 1;\n        var _meta = {\n            FileMetaInformationVersion: {\n                Value: [fileMetaInformationVersionArray.buffer],\n                vr: \"OB\"\n            },\n            //MediaStorageSOPClassUID\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n            TransferSyntaxUID: {\n                Value: [\"1.2.840.10008.1.2.1\"],\n                vr: \"UI\"\n            },\n            ImplementationClassUID: {\n                Value: [DicomMetaDictionary.uid()],\n                vr: \"UI\"\n            },\n            ImplementationVersionName: {\n                Value: [\"dcmjs\"],\n                vr: \"SH\"\n            }\n        };\n        return _meta;\n    };\n    MeasurementReport.getSetupMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, toolType) {\n        var ContentSequence = MeasurementGroup.ContentSequence;\n        var contentSequenceArr = toArray(ContentSequence);\n        var findingGroup = contentSequenceArr.find(function (group) {\n            return codeValueMatch(group, FINDING);\n        });\n        var findingSiteGroups = contentSequenceArr.filter(function (group) {\n            return codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD);\n        }) || [];\n        var NUMGroup = contentSequenceArr.find(function (group) { return group.ValueType === \"NUM\"; });\n        var SCOORDGroup = toArray(NUMGroup.ContentSequence).find(function (group) { return group.ValueType === \"SCOORD\"; });\n        var ReferencedSOPSequence = SCOORDGroup.ContentSequence.ReferencedSOPSequence;\n        var ReferencedSOPInstanceUID = ReferencedSOPSequence.ReferencedSOPInstanceUID, ReferencedFrameNumber = ReferencedSOPSequence.ReferencedFrameNumber;\n        var referencedImageId = sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\n        var imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n        var finding = findingGroup\n            ? addAccessors(findingGroup.ConceptCodeSequence)\n            : undefined;\n        var findingSites = findingSiteGroups.map(function (fsg) {\n            return addAccessors(fsg.ConceptCodeSequence);\n        });\n        var defaultState = {\n            description: undefined,\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            annotation: {\n                annotationUID: DicomMetaDictionary.uid(),\n                metadata: {\n                    toolName: toolType,\n                    referencedImageId: referencedImageId,\n                    FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n                    label: \"\"\n                },\n                data: undefined\n            },\n            finding: finding,\n            findingSites: findingSites\n        };\n        if (defaultState.finding) {\n            defaultState.description = defaultState.finding.CodeMeaning;\n        }\n        defaultState.annotation.metadata.label =\n            MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\n        return {\n            defaultState: defaultState,\n            NUMGroup: NUMGroup,\n            SCOORDGroup: SCOORDGroup,\n            ReferencedSOPSequence: ReferencedSOPSequence,\n            ReferencedSOPInstanceUID: ReferencedSOPInstanceUID,\n            ReferencedFrameNumber: ReferencedFrameNumber\n        };\n    };\n    MeasurementReport.generateReport = function (toolState, metadataProvider, worldToImageCoords, options) {\n        // ToolState for array of imageIDs to a Report\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n        var allMeasurementGroups = [];\n        /* Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n        */\n        var sopInstanceUIDsToSeriesInstanceUIDMap = {};\n        var derivationSourceDatasets = [];\n        var _meta = MeasurementReport.generateDatasetMeta();\n        // Loop through each image in the toolData\n        Object.keys(toolState).forEach(function (imageId) {\n            var sopCommonModule = metadataProvider.get(\"sopCommonModule\", imageId);\n            var instance = metadataProvider.get(\"instance\", imageId);\n            var sopInstanceUID = sopCommonModule.sopInstanceUID, sopClassUID = sopCommonModule.sopClassUID;\n            var seriesInstanceUID = instance.SeriesInstanceUID;\n            sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] =\n                seriesInstanceUID;\n            if (!derivationSourceDatasets.find(function (dsd) { return dsd.SeriesInstanceUID === seriesInstanceUID; })) {\n                // Entry not present for series, create one.\n                var derivationSourceDataset = MeasurementReport.generateDerivationSourceDataset(instance);\n                derivationSourceDatasets.push(derivationSourceDataset);\n            }\n            var frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n            var toolData = toolState[imageId];\n            var toolTypes = Object.keys(toolData);\n            var ReferencedSOPSequence = {\n                ReferencedSOPClassUID: sopClassUID,\n                ReferencedSOPInstanceUID: sopInstanceUID,\n                ReferencedFrameNumber: undefined\n            };\n            if ((instance &&\n                instance.NumberOfFrames &&\n                instance.NumberOfFrames > 1) ||\n                Normalizer.isMultiframeSOPClassUID(sopClassUID)) {\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n            }\n            // Loop through each tool type for the image\n            var measurementGroups = [];\n            toolTypes.forEach(function (toolType) {\n                var group = getMeasurementGroup(toolType, toolData, ReferencedSOPSequence, worldToImageCoords);\n                if (group) {\n                    measurementGroups.push(group);\n                }\n            });\n            allMeasurementGroups =\n                allMeasurementGroups.concat(measurementGroups);\n        });\n        var tid1500MeasurementReport = new TID1500MeasurementReport({ TID1501MeasurementGroups: allMeasurementGroups }, options);\n        var report = new StructuredReport(derivationSourceDatasets, options);\n        var contentItem = tid1500MeasurementReport.contentItem(derivationSourceDatasets, __assign(__assign({}, options), { sopInstanceUIDsToSeriesInstanceUIDMap: sopInstanceUIDsToSeriesInstanceUIDMap }));\n        // Merge the derived dataset with the content from the Measurement Report\n        report.dataset = Object.assign(report.dataset, contentItem);\n        report.dataset._meta = _meta;\n        return report;\n    };\n    /**\n     * Generate Cornerstone tool state from dataset\n     */\n    MeasurementReport.generateToolState = function (dataset, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata, hooks) {\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n            throw new Error(\"This package can currently only interpret DICOM SR TID 1500\");\n        }\n        var REPORT = \"Imaging Measurements\";\n        var GROUP = \"Measurement Group\";\n        var TRACKING_IDENTIFIER = \"Tracking Identifier\";\n        // Identify the Imaging Measurements\n        var imagingMeasurementContent = toArray(dataset.ContentSequence).find(codeMeaningEquals(REPORT));\n        // Retrieve the Measurements themselves\n        var measurementGroups = toArray(imagingMeasurementContent.ContentSequence).filter(codeMeaningEquals(GROUP));\n        // For each of the supported measurement types, compute the measurement data\n        var measurementData = {};\n        var cornerstoneToolClasses = MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n        var registeredToolClasses = [];\n        Object.keys(cornerstoneToolClasses).forEach(function (key) {\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\n            measurementData[key] = [];\n        });\n        measurementGroups.forEach(function (measurementGroup) {\n            var _a;\n            try {\n                var measurementGroupContentSequence = toArray(measurementGroup.ContentSequence);\n                var TrackingIdentifierGroup = measurementGroupContentSequence.find(function (contentItem) {\n                    return contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                        TRACKING_IDENTIFIER;\n                });\n                var TrackingIdentifierValue_1 = TrackingIdentifierGroup.TextValue;\n                var toolClass = ((_a = hooks === null || hooks === void 0 ? void 0 : hooks.getToolClass) === null || _a === void 0 ? void 0 : _a.call(hooks, measurementGroup, dataset, registeredToolClasses)) ||\n                    registeredToolClasses.find(function (tc) {\n                        return tc.isValidCornerstoneTrackingIdentifier(TrackingIdentifierValue_1);\n                    });\n                if (toolClass) {\n                    var measurement = toolClass.getMeasurementData(measurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata);\n                    console.log(\"=== \".concat(toolClass.toolType, \" ===\"));\n                    console.log(measurement);\n                    measurementData[toolClass.toolType].push(measurement);\n                }\n            }\n            catch (e) {\n                console.warn(\"Unable to generate tool state for\", measurementGroup, e);\n            }\n        });\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\n        return measurementData;\n    };\n    /**\n     * Register a new tool type.\n     * @param toolClass to perform I/O to DICOM for this tool\n     */\n    MeasurementReport.registerTool = function (toolClass) {\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[toolClass.utilityToolType] = toolClass;\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolClass.toolType] = toolClass;\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\n            toolClass.utilityToolType;\n    };\n    MeasurementReport.CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n    MeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n    MeasurementReport.generateDerivationSourceDataset = function (instance) {\n        var _vrMap = {\n            PixelData: \"OW\"\n        };\n        var _meta = MeasurementReport.generateDatasetMeta();\n        var derivationSourceDataset = __assign(__assign({}, instance), { _meta: _meta, _vrMap: _vrMap });\n        return derivationSourceDataset;\n    };\n    return MeasurementReport;\n}());\n\nvar TID300Point$1 = utilities.TID300.Point;\nvar ARROW_ANNOTATE = \"ArrowAnnotate\";\nvar trackingIdentifierTextValue$7 = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(ARROW_ANNOTATE);\nvar codeValues = CodingScheme.codeValues,\n  CodingSchemeDesignator = CodingScheme.CodingSchemeDesignator;\nvar ArrowAnnotate = /*#__PURE__*/function () {\n  function ArrowAnnotate() {\n    _classCallCheck(this, ArrowAnnotate);\n  }\n  _createClass(ArrowAnnotate, null, [{\n    key: \"getMeasurementData\",\n    value: function getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n      var _MeasurementReport$ge = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, ArrowAnnotate.toolType),\n        defaultState = _MeasurementReport$ge.defaultState,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup,\n        ReferencedFrameNumber = _MeasurementReport$ge.ReferencedFrameNumber;\n      var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n      var text = defaultState.annotation.metadata.label;\n      var GraphicData = SCOORDGroup.GraphicData;\n      var worldCoords = [];\n      for (var i = 0; i < GraphicData.length; i += 2) {\n        var point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n        worldCoords.push(point);\n      }\n\n      // Since the arrowAnnotate measurement is just a point, to generate the tool state\n      // we derive the second point based on the image size relative to the first point.\n      if (worldCoords.length === 1) {\n        var imagePixelModule = metadata.get(\"imagePixelModule\", referencedImageId);\n        var xOffset = 10;\n        var yOffset = 10;\n        if (imagePixelModule) {\n          var columns = imagePixelModule.columns,\n            rows = imagePixelModule.rows;\n          xOffset = columns / 10;\n          yOffset = rows / 10;\n        }\n        var secondPoint = imageToWorldCoords(referencedImageId, [GraphicData[0] + xOffset, GraphicData[1] + yOffset]);\n        worldCoords.push(secondPoint);\n      }\n      var state = defaultState;\n      state.annotation.data = {\n        text: text,\n        handles: {\n          arrowFirst: true,\n          points: [worldCoords[0], worldCoords[1]],\n          activeHandleIndex: 0,\n          textBox: {\n            hasMoved: false\n          }\n        },\n        frameNumber: ReferencedFrameNumber\n      };\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool, worldToImageCoords) {\n      var data = tool.data,\n        metadata = tool.metadata;\n      var finding = tool.finding,\n        findingSites = tool.findingSites;\n      var referencedImageId = metadata.referencedImageId;\n      if (!referencedImageId) {\n        throw new Error(\"ArrowAnnotate.getTID300RepresentationArguments: referencedImageId is not defined\");\n      }\n      var _data$handles = data.handles,\n        points = _data$handles.points,\n        arrowFirst = _data$handles.arrowFirst;\n      var point;\n      if (arrowFirst) {\n        point = points[0];\n      } else {\n        point = points[1];\n      }\n      var pointImage = worldToImageCoords(referencedImageId, point);\n      var TID300RepresentationArguments = {\n        points: [{\n          x: pointImage[0],\n          y: pointImage[1]\n        }],\n        trackingIdentifierTextValue: trackingIdentifierTextValue$7,\n        findingSites: findingSites || []\n      };\n\n      // If freetext finding isn't present, add it from the tool text.\n      if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n        finding = {\n          CodeValue: codeValues.CORNERSTONEFREETEXT,\n          CodingSchemeDesignator: CodingSchemeDesignator,\n          CodeMeaning: data.text\n        };\n      }\n      TID300RepresentationArguments.finding = finding;\n      return TID300RepresentationArguments;\n    }\n  }]);\n  return ArrowAnnotate;\n}();\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point$1;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone3DTag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n    return false;\n  }\n  return toolType === ARROW_ANNOTATE;\n};\nMeasurementReport.registerTool(ArrowAnnotate);\n\nvar TID300Bidirectional = utilities.TID300.Bidirectional;\nvar BIDIRECTIONAL = \"Bidirectional\";\nvar LONG_AXIS = \"Long Axis\";\nvar SHORT_AXIS = \"Short Axis\";\nvar trackingIdentifierTextValue$6 = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(BIDIRECTIONAL);\nvar Bidirectional = /** @class */ (function () {\n    function Bidirectional() {\n    }\n    Bidirectional.getMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n        var _a;\n        var _b = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Bidirectional.toolType), defaultState = _b.defaultState, ReferencedFrameNumber = _b.ReferencedFrameNumber;\n        var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n        var ContentSequence = MeasurementGroup.ContentSequence;\n        var longAxisNUMGroup = toArray(ContentSequence).find(function (group) { return group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS; });\n        var longAxisSCOORDGroup = toArray(longAxisNUMGroup.ContentSequence).find(function (group) { return group.ValueType === \"SCOORD\"; });\n        var shortAxisNUMGroup = toArray(ContentSequence).find(function (group) { return group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS; });\n        var shortAxisSCOORDGroup = toArray(shortAxisNUMGroup.ContentSequence).find(function (group) { return group.ValueType === \"SCOORD\"; });\n        var worldCoords = [];\n        [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(function (group) {\n            var GraphicData = group.GraphicData;\n            for (var i = 0; i < GraphicData.length; i += 2) {\n                var point = imageToWorldCoords(referencedImageId, [\n                    GraphicData[i],\n                    GraphicData[i + 1]\n                ]);\n                worldCoords.push(point);\n            }\n        });\n        var state = defaultState;\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: (_a = {},\n                _a[\"imageId:\".concat(referencedImageId)] = {\n                    length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n                    width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n                },\n                _a),\n            frameNumber: ReferencedFrameNumber\n        };\n        return state;\n    };\n    Bidirectional.getTID300RepresentationArguments = function (tool, worldToImageCoords) {\n        var data = tool.data, finding = tool.finding, findingSites = tool.findingSites, metadata = tool.metadata;\n        var _a = data.cachedStats, cachedStats = _a === void 0 ? {} : _a, handles = data.handles;\n        var referencedImageId = metadata.referencedImageId;\n        if (!referencedImageId) {\n            throw new Error(\"Bidirectional.getTID300RepresentationArguments: referencedImageId is not defined\");\n        }\n        var _b = cachedStats[\"imageId:\".concat(referencedImageId)] || {}, length = _b.length, width = _b.width;\n        var points = handles.points;\n        // Find the length and width point pairs by comparing the distances of the points at 0,1 to points at 2,3\n        var firstPointPairs = [points[0], points[1]];\n        var secondPointPairs = [points[2], points[3]];\n        var firstPointPairsDistance = Math.sqrt(Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) +\n            Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) +\n            Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2));\n        var secondPointPairsDistance = Math.sqrt(Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) +\n            Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) +\n            Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2));\n        var shortAxisPoints;\n        var longAxisPoints;\n        if (firstPointPairsDistance > secondPointPairsDistance) {\n            shortAxisPoints = firstPointPairs;\n            longAxisPoints = secondPointPairs;\n        }\n        else {\n            shortAxisPoints = secondPointPairs;\n            longAxisPoints = firstPointPairs;\n        }\n        var longAxisStartImage = worldToImageCoords(referencedImageId, shortAxisPoints[0]);\n        var longAxisEndImage = worldToImageCoords(referencedImageId, shortAxisPoints[1]);\n        var shortAxisStartImage = worldToImageCoords(referencedImageId, longAxisPoints[0]);\n        var shortAxisEndImage = worldToImageCoords(referencedImageId, longAxisPoints[1]);\n        return {\n            longAxis: {\n                point1: {\n                    x: longAxisStartImage[0],\n                    y: longAxisStartImage[1]\n                },\n                point2: {\n                    x: longAxisEndImage[0],\n                    y: longAxisEndImage[1]\n                }\n            },\n            shortAxis: {\n                point1: {\n                    x: shortAxisStartImage[0],\n                    y: shortAxisStartImage[1]\n                },\n                point2: {\n                    x: shortAxisEndImage[0],\n                    y: shortAxisEndImage[1]\n                }\n            },\n            longAxisLength: length,\n            shortAxisLength: width,\n            trackingIdentifierTextValue: trackingIdentifierTextValue$6,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    };\n    Bidirectional.toolType = BIDIRECTIONAL;\n    Bidirectional.utilityToolType = BIDIRECTIONAL;\n    Bidirectional.TID300Representation = TID300Bidirectional;\n    Bidirectional.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n        var _a = TrackingIdentifier.split(\":\"), cornerstone3DTag = _a[0], toolType = _a[1];\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n        return toolType === BIDIRECTIONAL;\n    };\n    return Bidirectional;\n}());\nMeasurementReport.registerTool(Bidirectional);\n\nvar TID300CobbAngle$1 = utilities.TID300.CobbAngle;\nvar MEASUREMENT_TYPE$1 = \"Angle\";\nvar trackingIdentifierTextValue$5 = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(MEASUREMENT_TYPE$1);\nvar Angle = /** @class */ (function () {\n    function Angle() {\n    }\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    Angle.getMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n        var _a;\n        var _b = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Angle.toolType), defaultState = _b.defaultState, NUMGroup = _b.NUMGroup, SCOORDGroup = _b.SCOORDGroup, ReferencedFrameNumber = _b.ReferencedFrameNumber;\n        var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n        var GraphicData = SCOORDGroup.GraphicData;\n        var worldCoords = [];\n        for (var i = 0; i < GraphicData.length; i += 2) {\n            var point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n        var state = defaultState;\n        state.annotation.data = {\n            handles: {\n                points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: (_a = {},\n                _a[\"imageId:\".concat(referencedImageId)] = {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                },\n                _a),\n            frameNumber: ReferencedFrameNumber\n        };\n        return state;\n    };\n    Angle.getTID300RepresentationArguments = function (tool, worldToImageCoords) {\n        var data = tool.data, finding = tool.finding, findingSites = tool.findingSites, metadata = tool.metadata;\n        var _a = data.cachedStats, cachedStats = _a === void 0 ? {} : _a, handles = data.handles;\n        var referencedImageId = metadata.referencedImageId;\n        if (!referencedImageId) {\n            throw new Error(\"Angle.getTID300RepresentationArguments: referencedImageId is not defined\");\n        }\n        var start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        var middle = worldToImageCoords(referencedImageId, handles.points[1]);\n        var end = worldToImageCoords(referencedImageId, handles.points[2]);\n        var point1 = { x: start1[0], y: start1[1] };\n        var point2 = { x: middle[0], y: middle[1] };\n        var point3 = point2;\n        var point4 = { x: end[0], y: end[1] };\n        var angle = (cachedStats[\"imageId:\".concat(referencedImageId)] || {}).angle;\n        // Represented as a cobb angle\n        return {\n            point1: point1,\n            point2: point2,\n            point3: point3,\n            point4: point4,\n            rAngle: angle,\n            trackingIdentifierTextValue: trackingIdentifierTextValue$5,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    };\n    Angle.toolType = MEASUREMENT_TYPE$1;\n    Angle.utilityToolType = MEASUREMENT_TYPE$1;\n    Angle.TID300Representation = TID300CobbAngle$1;\n    Angle.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n        var _a = TrackingIdentifier.split(\":\"), cornerstone3DTag = _a[0], toolType = _a[1];\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n        return toolType === MEASUREMENT_TYPE$1;\n    };\n    return Angle;\n}());\nMeasurementReport.registerTool(Angle);\n\nvar TID300CobbAngle = utilities.TID300.CobbAngle;\nvar MEASUREMENT_TYPE = \"CobbAngle\";\nvar trackingIdentifierTextValue$4 = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(MEASUREMENT_TYPE);\nvar CobbAngle = /** @class */ (function () {\n    function CobbAngle() {\n    }\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    CobbAngle.getMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n        var _a;\n        var _b = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CobbAngle.toolType), defaultState = _b.defaultState, NUMGroup = _b.NUMGroup, SCOORDGroup = _b.SCOORDGroup, ReferencedFrameNumber = _b.ReferencedFrameNumber;\n        var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n        var GraphicData = SCOORDGroup.GraphicData;\n        var worldCoords = [];\n        for (var i = 0; i < GraphicData.length; i += 2) {\n            var point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n        var state = defaultState;\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: (_a = {},\n                _a[\"imageId:\".concat(referencedImageId)] = {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                },\n                _a),\n            frameNumber: ReferencedFrameNumber\n        };\n        return state;\n    };\n    CobbAngle.getTID300RepresentationArguments = function (tool, worldToImageCoords) {\n        var data = tool.data, finding = tool.finding, findingSites = tool.findingSites, metadata = tool.metadata;\n        var _a = data.cachedStats, cachedStats = _a === void 0 ? {} : _a, handles = data.handles;\n        var referencedImageId = metadata.referencedImageId;\n        if (!referencedImageId) {\n            throw new Error(\"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\");\n        }\n        var start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        var end1 = worldToImageCoords(referencedImageId, handles.points[1]);\n        var start2 = worldToImageCoords(referencedImageId, handles.points[2]);\n        var end2 = worldToImageCoords(referencedImageId, handles.points[3]);\n        var point1 = { x: start1[0], y: start1[1] };\n        var point2 = { x: end1[0], y: end1[1] };\n        var point3 = { x: start2[0], y: start2[1] };\n        var point4 = { x: end2[0], y: end2[1] };\n        var angle = (cachedStats[\"imageId:\".concat(referencedImageId)] || {}).angle;\n        return {\n            point1: point1,\n            point2: point2,\n            point3: point3,\n            point4: point4,\n            rAngle: angle,\n            trackingIdentifierTextValue: trackingIdentifierTextValue$4,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    };\n    CobbAngle.toolType = MEASUREMENT_TYPE;\n    CobbAngle.utilityToolType = MEASUREMENT_TYPE;\n    CobbAngle.TID300Representation = TID300CobbAngle;\n    CobbAngle.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n        var _a = TrackingIdentifier.split(\":\"), cornerstone3DTag = _a[0], toolType = _a[1];\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n        return toolType === MEASUREMENT_TYPE;\n    };\n    return CobbAngle;\n}());\nMeasurementReport.registerTool(CobbAngle);\n\nfunction isValidCornerstoneTrackingIdentifier(trackingIdentifier) {\n    if (!trackingIdentifier.includes(\":\")) {\n        return false;\n    }\n    var _a = trackingIdentifier.split(\":\"), cornerstone3DTag = _a[0], toolType = _a[1];\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n    // The following is needed since the new cornerstone3D has changed\n    // case names such as EllipticalRoi to EllipticalROI\n    return toolType.toLowerCase() === this.toolType.toLowerCase();\n}\n\nvar TID300Circle = utilities.TID300.Circle;\nvar CIRCLEROI = \"CircleROI\";\nvar CircleROI = /** @class */ (function () {\n    function CircleROI() {\n    }\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    CircleROI.getMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n        var _a;\n        var _b = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, CircleROI.toolType), defaultState = _b.defaultState, NUMGroup = _b.NUMGroup, SCOORDGroup = _b.SCOORDGroup, ReferencedFrameNumber = _b.ReferencedFrameNumber;\n        var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n        var GraphicData = SCOORDGroup.GraphicData;\n        // GraphicData is ordered as [centerX, centerY, endX, endY]\n        var pointsWorld = [];\n        for (var i = 0; i < GraphicData.length; i += 2) {\n            var worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            pointsWorld.push(worldPos);\n        }\n        var state = defaultState;\n        state.annotation.data = {\n            handles: {\n                points: __spreadArray([], pointsWorld, true),\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: (_a = {},\n                _a[\"imageId:\".concat(referencedImageId)] = {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0,\n                    // Dummy values to be updated by cornerstone\n                    radius: 0,\n                    perimeter: 0\n                },\n                _a),\n            frameNumber: ReferencedFrameNumber\n        };\n        return state;\n    };\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n    CircleROI.getTID300RepresentationArguments = function (tool, worldToImageCoords) {\n        var data = tool.data, finding = tool.finding, findingSites = tool.findingSites, metadata = tool.metadata;\n        var _a = data.cachedStats, cachedStats = _a === void 0 ? {} : _a, handles = data.handles;\n        var referencedImageId = metadata.referencedImageId;\n        if (!referencedImageId) {\n            throw new Error(\"CircleROI.getTID300RepresentationArguments: referencedImageId is not defined\");\n        }\n        var center = worldToImageCoords(referencedImageId, handles.points[0]);\n        var end = worldToImageCoords(referencedImageId, handles.points[1]);\n        var points = [];\n        points.push({ x: center[0], y: center[1] });\n        points.push({ x: end[0], y: end[1] });\n        var _b = cachedStats[\"imageId:\".concat(referencedImageId)] || {}, area = _b.area, radius = _b.radius;\n        var perimeter = 2 * Math.PI * radius;\n        return {\n            area: area,\n            perimeter: perimeter,\n            radius: radius,\n            points: points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    };\n    CircleROI.trackingIdentifierTextValue = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(CIRCLEROI);\n    CircleROI.toolType = CIRCLEROI;\n    CircleROI.utilityToolType = CIRCLEROI;\n    CircleROI.TID300Representation = TID300Circle;\n    CircleROI.isValidCornerstoneTrackingIdentifier = isValidCornerstoneTrackingIdentifier;\n    return CircleROI;\n}());\nMeasurementReport.registerTool(CircleROI);\n\nvar TID300Ellipse = utilities.TID300.Ellipse;\nvar ELLIPTICALROI = \"EllipticalROI\";\nvar EPSILON = 1e-4;\nvar EllipticalROI = /** @class */ (function () {\n    function EllipticalROI() {\n    }\n    EllipticalROI.getMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n        var _a;\n        var _b = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, EllipticalROI.toolType), defaultState = _b.defaultState, NUMGroup = _b.NUMGroup, SCOORDGroup = _b.SCOORDGroup, ReferencedFrameNumber = _b.ReferencedFrameNumber;\n        var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n        var GraphicData = SCOORDGroup.GraphicData;\n        // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\n        // But Cornerstone3D points are ordered as top, bottom, left, right for the\n        // ellipse so we need to identify if the majorAxis is horizontal or vertical\n        // in the image plane and then choose the correct points to use for the ellipse.\n        var pointsWorld = [];\n        for (var i = 0; i < GraphicData.length; i += 2) {\n            var worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            pointsWorld.push(worldPos);\n        }\n        var majorAxisStart = vec3.fromValues.apply(vec3, pointsWorld[0]);\n        var majorAxisEnd = vec3.fromValues.apply(vec3, pointsWorld[1]);\n        var minorAxisStart = vec3.fromValues.apply(vec3, pointsWorld[2]);\n        var minorAxisEnd = vec3.fromValues.apply(vec3, pointsWorld[3]);\n        var majorAxisVec = vec3.create();\n        vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n        // normalize majorAxisVec to avoid scaling issues\n        vec3.normalize(majorAxisVec, majorAxisVec);\n        var minorAxisVec = vec3.create();\n        vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n        vec3.normalize(minorAxisVec, minorAxisVec);\n        var imagePlaneModule = metadata.get(\"imagePlaneModule\", referencedImageId);\n        if (!imagePlaneModule) {\n            throw new Error(\"imageId does not have imagePlaneModule metadata\");\n        }\n        var columnCosines = imagePlaneModule.columnCosines;\n        // find which axis is parallel to the columnCosines\n        var columnCosinesVec = vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);\n        var projectedMajorAxisOnColVec = vec3.dot(columnCosinesVec, majorAxisVec);\n        var projectedMinorAxisOnColVec = vec3.dot(columnCosinesVec, minorAxisVec);\n        var absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n        var absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n        var ellipsePoints = [];\n        if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[0],\n                pointsWorld[1],\n                pointsWorld[2],\n                pointsWorld[3]\n            ];\n        }\n        else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[2],\n                pointsWorld[3],\n                pointsWorld[0],\n                pointsWorld[1]\n            ];\n        }\n        else {\n            console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\n        }\n        var state = defaultState;\n        state.annotation.data = {\n            handles: {\n                points: __spreadArray([], ellipsePoints, true),\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: (_a = {},\n                _a[\"imageId:\".concat(referencedImageId)] = {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0\n                },\n                _a),\n            frameNumber: ReferencedFrameNumber\n        };\n        return state;\n    };\n    EllipticalROI.getTID300RepresentationArguments = function (tool, worldToImageCoords) {\n        var data = tool.data, finding = tool.finding, findingSites = tool.findingSites, metadata = tool.metadata;\n        var _a = data.cachedStats, cachedStats = _a === void 0 ? {} : _a, handles = data.handles;\n        var rotation = data.initialRotation || 0;\n        var referencedImageId = metadata.referencedImageId;\n        if (!referencedImageId) {\n            throw new Error(\"EllipticalROI.getTID300RepresentationArguments: referencedImageId is not defined\");\n        }\n        var top, bottom, left, right;\n        // this way when it's restored we can assume the initial rotation is 0.\n        if (rotation == 90 || rotation == 270) {\n            bottom = worldToImageCoords(referencedImageId, handles.points[2]);\n            top = worldToImageCoords(referencedImageId, handles.points[3]);\n            left = worldToImageCoords(referencedImageId, handles.points[0]);\n            right = worldToImageCoords(referencedImageId, handles.points[1]);\n        }\n        else {\n            top = worldToImageCoords(referencedImageId, handles.points[0]);\n            bottom = worldToImageCoords(referencedImageId, handles.points[1]);\n            left = worldToImageCoords(referencedImageId, handles.points[2]);\n            right = worldToImageCoords(referencedImageId, handles.points[3]);\n        }\n        // find the major axis and minor axis\n        var topBottomLength = Math.abs(top[1] - bottom[1]);\n        var leftRightLength = Math.abs(left[0] - right[0]);\n        var points = [];\n        if (topBottomLength > leftRightLength) {\n            // major axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n            // minor axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n        }\n        else {\n            // major axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n            // minor axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n        }\n        var area = (cachedStats[\"imageId:\".concat(referencedImageId)] || {}).area;\n        return {\n            area: area,\n            points: points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    };\n    EllipticalROI.trackingIdentifierTextValue = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(ELLIPTICALROI);\n    EllipticalROI.toolType = ELLIPTICALROI;\n    EllipticalROI.utilityToolType = ELLIPTICALROI;\n    EllipticalROI.TID300Representation = TID300Ellipse;\n    EllipticalROI.isValidCornerstoneTrackingIdentifier = isValidCornerstoneTrackingIdentifier;\n    return EllipticalROI;\n}());\nMeasurementReport.registerTool(EllipticalROI);\n\nvar TID300Polyline$1 = utilities.TID300.Polyline;\nvar TOOLTYPE = \"RectangleROI\";\nvar trackingIdentifierTextValue$3 = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(TOOLTYPE);\nvar RectangleROI = /** @class */ (function () {\n    function RectangleROI() {\n    }\n    RectangleROI.getMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n        var _a;\n        var _b = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, RectangleROI.toolType), defaultState = _b.defaultState, NUMGroup = _b.NUMGroup, SCOORDGroup = _b.SCOORDGroup, ReferencedFrameNumber = _b.ReferencedFrameNumber;\n        var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n        var GraphicData = SCOORDGroup.GraphicData;\n        var worldCoords = [];\n        for (var i = 0; i < GraphicData.length; i += 2) {\n            var point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n        var state = defaultState;\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[3],\n                    worldCoords[2]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: (_a = {},\n                _a[\"imageId:\".concat(referencedImageId)] = {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                },\n                _a),\n            frameNumber: ReferencedFrameNumber\n        };\n        return state;\n    };\n    RectangleROI.getTID300RepresentationArguments = function (tool, worldToImageCoords) {\n        var data = tool.data, finding = tool.finding, findingSites = tool.findingSites, metadata = tool.metadata;\n        var _a = data.cachedStats, cachedStats = _a === void 0 ? {} : _a, handles = data.handles;\n        var referencedImageId = metadata.referencedImageId;\n        if (!referencedImageId) {\n            throw new Error(\"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\");\n        }\n        var corners = handles.points.map(function (point) {\n            return worldToImageCoords(referencedImageId, point);\n        });\n        var area = cachedStats.area, perimeter = cachedStats.perimeter;\n        return {\n            points: [\n                corners[0],\n                corners[1],\n                corners[3],\n                corners[2],\n                corners[0]\n            ],\n            area: area,\n            perimeter: perimeter,\n            trackingIdentifierTextValue: trackingIdentifierTextValue$3,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    };\n    RectangleROI.toolType = TOOLTYPE;\n    RectangleROI.utilityToolType = TOOLTYPE;\n    RectangleROI.TID300Representation = TID300Polyline$1;\n    RectangleROI.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n        var _a = TrackingIdentifier.split(\":\"), cornerstone3DTag = _a[0], toolType = _a[1];\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n        return toolType === TOOLTYPE;\n    };\n    return RectangleROI;\n}());\nMeasurementReport.registerTool(RectangleROI);\n\nvar TID300Length = utilities.TID300.Length;\nvar LENGTH = \"Length\";\nvar trackingIdentifierTextValue$2 = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(LENGTH);\nvar Length = /*#__PURE__*/function () {\n  function Length() {\n    _classCallCheck(this, Length);\n  }\n  _createClass(Length, null, [{\n    key: \"getMeasurementData\",\n    value:\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    function getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n      var _MeasurementReport$ge = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Length.toolType),\n        defaultState = _MeasurementReport$ge.defaultState,\n        NUMGroup = _MeasurementReport$ge.NUMGroup,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup,\n        ReferencedFrameNumber = _MeasurementReport$ge.ReferencedFrameNumber;\n      var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n      var GraphicData = SCOORDGroup.GraphicData;\n      var worldCoords = [];\n      for (var i = 0; i < GraphicData.length; i += 2) {\n        var point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n        worldCoords.push(point);\n      }\n      var state = defaultState;\n      state.annotation.data = {\n        handles: {\n          points: [worldCoords[0], worldCoords[1]],\n          activeHandleIndex: 0,\n          textBox: {\n            hasMoved: false\n          }\n        },\n        cachedStats: _defineProperty({}, \"imageId:\".concat(referencedImageId), {\n          length: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n        }),\n        frameNumber: ReferencedFrameNumber\n      };\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool, worldToImageCoords) {\n      var data = tool.data,\n        finding = tool.finding,\n        findingSites = tool.findingSites,\n        metadata = tool.metadata;\n      var _data$cachedStats = data.cachedStats,\n        cachedStats = _data$cachedStats === void 0 ? {} : _data$cachedStats,\n        handles = data.handles;\n      var referencedImageId = metadata.referencedImageId;\n      if (!referencedImageId) {\n        throw new Error(\"Length.getTID300RepresentationArguments: referencedImageId is not defined\");\n      }\n      var start = worldToImageCoords(referencedImageId, handles.points[0]);\n      var end = worldToImageCoords(referencedImageId, handles.points[1]);\n      var point1 = {\n        x: start[0],\n        y: start[1]\n      };\n      var point2 = {\n        x: end[0],\n        y: end[1]\n      };\n      var _ref = cachedStats[\"imageId:\".concat(referencedImageId)] || {},\n        distance = _ref.length;\n      return {\n        point1: point1,\n        point2: point2,\n        distance: distance,\n        trackingIdentifierTextValue: trackingIdentifierTextValue$2,\n        finding: finding,\n        findingSites: findingSites || []\n      };\n    }\n  }]);\n  return Length;\n}();\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone3DTag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n    return false;\n  }\n  return toolType === LENGTH;\n};\nMeasurementReport.registerTool(Length);\n\nvar TID300Polyline = utilities.TID300.Polyline;\nvar PLANARFREEHANDROI = \"PlanarFreehandROI\";\nvar trackingIdentifierTextValue$1 = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(PLANARFREEHANDROI);\nvar closedContourThreshold = 1e-5;\nvar PlanarFreehandROI = /** @class */ (function () {\n    function PlanarFreehandROI() {\n    }\n    PlanarFreehandROI.getMeasurementData = function (MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n        var _a = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, PlanarFreehandROI.toolType), defaultState = _a.defaultState, SCOORDGroup = _a.SCOORDGroup, ReferencedFrameNumber = _a.ReferencedFrameNumber;\n        var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n        var GraphicData = SCOORDGroup.GraphicData;\n        var worldCoords = [];\n        for (var i = 0; i < GraphicData.length; i += 2) {\n            var point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n        var distanceBetweenFirstAndLastPoint = vec3.distance(worldCoords[worldCoords.length - 1], worldCoords[0]);\n        var isOpenContour = true;\n        // If the contour is closed, this should have been encoded as exactly the same point, so check for a very small difference.\n        if (distanceBetweenFirstAndLastPoint < closedContourThreshold) {\n            worldCoords.pop(); // Remove the last element which is duplicated.\n            isOpenContour = false;\n        }\n        var points = [];\n        if (isOpenContour) {\n            points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n        }\n        var state = defaultState;\n        state.annotation.data = {\n            polyline: worldCoords,\n            isOpenContour: isOpenContour,\n            handles: {\n                points: points,\n                activeHandleIndex: null,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n        return state;\n    };\n    PlanarFreehandROI.getTID300RepresentationArguments = function (tool, worldToImageCoords) {\n        var data = tool.data, finding = tool.finding, findingSites = tool.findingSites, metadata = tool.metadata;\n        var isOpenContour = data.isOpenContour, polyline = data.polyline;\n        var referencedImageId = metadata.referencedImageId;\n        if (!referencedImageId) {\n            throw new Error(\"PlanarFreehandROI.getTID300RepresentationArguments: referencedImageId is not defined\");\n        }\n        var points = polyline.map(function (worldPos) {\n            return worldToImageCoords(referencedImageId, worldPos);\n        });\n        if (!isOpenContour) {\n            // Need to repeat the first point at the end of to have an explicitly closed contour.\n            var firstPoint = points[0];\n            // Explicitly expand to avoid ciruclar references.\n            points.push([firstPoint[0], firstPoint[1]]);\n        }\n        var area = 0; // TODO -> The tool doesn't have these stats yet.\n        var perimeter = 0;\n        return {\n            points: points,\n            area: area,\n            perimeter: perimeter,\n            trackingIdentifierTextValue: trackingIdentifierTextValue$1,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    };\n    PlanarFreehandROI.toolType = PLANARFREEHANDROI;\n    PlanarFreehandROI.utilityToolType = PLANARFREEHANDROI;\n    PlanarFreehandROI.TID300Representation = TID300Polyline;\n    PlanarFreehandROI.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n        var _a = TrackingIdentifier.split(\":\"), cornerstone3DTag = _a[0], toolType = _a[1];\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n        return toolType === PLANARFREEHANDROI;\n    };\n    return PlanarFreehandROI;\n}());\nMeasurementReport.registerTool(PlanarFreehandROI);\n\nvar TID300Point = utilities.TID300.Point;\nvar PROBE = \"Probe\";\nvar trackingIdentifierTextValue = \"\".concat(CORNERSTONE_3D_TAG, \":\").concat(PROBE);\nvar Probe = /*#__PURE__*/function () {\n  function Probe() {\n    _classCallCheck(this, Probe);\n  }\n  _createClass(Probe, null, [{\n    key: \"getMeasurementData\",\n    value: function getMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, imageToWorldCoords, metadata) {\n      var _MeasurementReport$ge = MeasurementReport.getSetupMeasurementData(MeasurementGroup, sopInstanceUIDToImageIdMap, metadata, Probe.toolType),\n        defaultState = _MeasurementReport$ge.defaultState,\n        SCOORDGroup = _MeasurementReport$ge.SCOORDGroup,\n        ReferencedFrameNumber = _MeasurementReport$ge.ReferencedFrameNumber;\n      var referencedImageId = defaultState.annotation.metadata.referencedImageId;\n      var GraphicData = SCOORDGroup.GraphicData;\n      var worldCoords = [];\n      for (var i = 0; i < GraphicData.length; i += 2) {\n        var point = imageToWorldCoords(referencedImageId, [GraphicData[i], GraphicData[i + 1]]);\n        worldCoords.push(point);\n      }\n      var state = defaultState;\n      state.annotation.data = {\n        handles: {\n          points: worldCoords,\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false\n          }\n        },\n        frameNumber: ReferencedFrameNumber\n      };\n      return state;\n    }\n  }, {\n    key: \"getTID300RepresentationArguments\",\n    value: function getTID300RepresentationArguments(tool, worldToImageCoords) {\n      var data = tool.data,\n        metadata = tool.metadata;\n      var finding = tool.finding,\n        findingSites = tool.findingSites;\n      var referencedImageId = metadata.referencedImageId;\n      if (!referencedImageId) {\n        throw new Error(\"Probe.getTID300RepresentationArguments: referencedImageId is not defined\");\n      }\n      var points = data.handles.points;\n      var pointsImage = points.map(function (point) {\n        var pointImage = worldToImageCoords(referencedImageId, point);\n        return {\n          x: pointImage[0],\n          y: pointImage[1]\n        };\n      });\n      var TID300RepresentationArguments = {\n        points: pointsImage,\n        trackingIdentifierTextValue: trackingIdentifierTextValue,\n        findingSites: findingSites || [],\n        finding: finding\n      };\n      return TID300RepresentationArguments;\n    }\n  }]);\n  return Probe;\n}();\nProbe.toolType = PROBE;\nProbe.utilityToolType = PROBE;\nProbe.TID300Representation = TID300Point;\nProbe.isValidCornerstoneTrackingIdentifier = function (TrackingIdentifier) {\n  if (!TrackingIdentifier.includes(\":\")) {\n    return false;\n  }\n  var _TrackingIdentifier$s = TrackingIdentifier.split(\":\"),\n    _TrackingIdentifier$s2 = _slicedToArray(_TrackingIdentifier$s, 2),\n    cornerstone3DTag = _TrackingIdentifier$s2[0],\n    toolType = _TrackingIdentifier$s2[1];\n  if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n    return false;\n  }\n  return toolType === PROBE;\n};\nMeasurementReport.registerTool(Probe);\n\nvar Cornerstone3D = {\n    Bidirectional: Bidirectional,\n    CobbAngle: CobbAngle,\n    Angle: Angle,\n    Length: Length,\n    CircleROI: CircleROI,\n    EllipticalROI: EllipticalROI,\n    RectangleROI: RectangleROI,\n    ArrowAnnotate: ArrowAnnotate,\n    Probe: Probe,\n    PlanarFreehandROI: PlanarFreehandROI,\n    MeasurementReport: MeasurementReport,\n    CodeScheme: CodingScheme,\n    CORNERSTONE_3D_TAG: CORNERSTONE_3D_TAG\n};\n\nvar Colors = data.Colors,\n  BitArray = data.BitArray;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n  var rgba = Colors.dicomlab2RGB(cielab).map(function (x) {\n    return Math.round(x * 255);\n  });\n  rgba.push(255);\n  return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n  var Zx = x[1] * y[2] - x[2] * y[1];\n  var Zy = x[2] * y[0] - x[0] * y[2];\n  var Zz = x[0] * y[1] - x[1] * y[0];\n  out[0] = Zx;\n  out[1] = Zy;\n  out[2] = Zz;\n}\nfunction norm(x) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  switch (n) {\n    case 1:\n      return Math.abs(x);\n    case 2:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n    case 3:\n      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n    default:\n      {\n        var sum = 0;\n        for (var i = 0; i < n; i++) {\n          sum += x[i] * x[i];\n        }\n        return Math.sqrt(sum);\n      }\n  }\n}\nfunction normalize(x) {\n  var den = norm(x);\n  if (den !== 0.0) {\n    x[0] /= den;\n    x[1] /= den;\n    x[2] /= den;\n  }\n  return den;\n}\nfunction subtract(a, b, out) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n  var geometry = {};\n  var pixelMeasures = dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n  var planeOrientation = dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n  // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n  //\n  // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n  // sort them to obtain the first and last position along the acquisition axis.\n  var firstFunctionalGroup = PerFrameFunctionalGroups[0];\n  var lastFunctionalGroup = PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n  var firstPosition = firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  var lastPosition = lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(Number);\n  geometry.origin = firstPosition;\n\n  // NB: DICOM PixelSpacing is defined as Row then Column,\n  // unlike ImageOrientationPatient\n  geometry.spacing = [pixelMeasures.PixelSpacing[1], pixelMeasures.PixelSpacing[0], pixelMeasures.SpacingBetweenSlices].map(Number);\n  geometry.dimensions = [dataset.Columns, dataset.Rows, PerFrameFunctionalGroups.length].map(Number);\n  var orientation = planeOrientation.ImageOrientationPatient.map(Number);\n  var columnStepToPatient = orientation.slice(0, 3);\n  var rowStepToPatient = orientation.slice(3, 6);\n  geometry.planeNormal = [];\n  cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n  geometry.sliceStep = [];\n  subtract(lastPosition, firstPosition, geometry.sliceStep);\n  normalize(geometry.sliceStep);\n  geometry.direction = columnStepToPatient.concat(rowStepToPatient).concat(geometry.sliceStep);\n  return geometry;\n}\nvar Segmentation = /*#__PURE__*/function () {\n  function Segmentation() {\n    _classCallCheck(this, Segmentation);\n  }\n\n  /**\n   * Produces an array of Segments from an input DICOM Segmentation dataset\n   *\n   * Segments are returned with Geometry values that can be used to create\n   * VTK Image Data objects.\n   *\n   * @example Example usage to create VTK Volume actors from each segment:\n   *\n   * const actors = [];\n   * const segments = generateToolState(dataset);\n   * segments.forEach(segment => {\n   *   // now make actors using the segment information\n   *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n   *        name: \"Scalars\",\n   *        numberOfComponents: 1,\n   *        values: segment.pixelData,\n   *    });\n   *\n   *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n   *    imageData.getPointData().setScalars(scalarArray);\n   *    imageData.setDimensions(geometry.dimensions);\n   *    imageData.setSpacing(geometry.spacing);\n   *    imageData.setOrigin(geometry.origin);\n   *    imageData.setDirection(geometry.direction);\n   *\n   *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n   *    mapper.setInputData(imageData);\n   *    mapper.setSampleDistance(2.);\n   *\n   *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n   *    actor.setMapper(mapper);\n   *\n   *    actors.push(actor);\n   * });\n   *\n   * @param dataset\n   * @return {{}}\n   */\n  _createClass(Segmentation, null, [{\n    key: \"generateSegments\",\n    value: function generateSegments(dataset) {\n      if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n        dataset.SegmentSequence = [dataset.SegmentSequence];\n      }\n      dataset.SegmentSequence.forEach(function (segment) {\n        // TODO: other interesting fields could be extracted from the segment\n        // TODO: Read SegmentsOverlay field\n        // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n        // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n        // Why was this example converting to RGBA with 0-255 values?\n        var color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n        segments[segment.SegmentNumber] = {\n          color: color,\n          functionalGroups: [],\n          offset: null,\n          size: null,\n          pixelData: null\n        };\n      });\n\n      // make a list of functional groups per segment\n      dataset.PerFrameFunctionalGroupsSequence.forEach(function (functionalGroup) {\n        var segmentNumber = functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\n        segments[segmentNumber].functionalGroups.push(functionalGroup);\n      });\n\n      // determine per-segment index into the pixel data\n      // TODO: only handles one-bit-per pixel\n      var frameSize = Math.ceil(dataset.Rows * dataset.Columns / 8);\n      var nextOffset = 0;\n      Object.keys(segments).forEach(function (segmentNumber) {\n        var segment = segments[segmentNumber];\n        segment.numberOfFrames = segment.functionalGroups.length;\n        segment.size = segment.numberOfFrames * frameSize;\n        segment.offset = nextOffset;\n        nextOffset = segment.offset + segment.size;\n        var packedSegment = dataset.PixelData.slice(segment.offset, nextOffset);\n        segment.pixelData = BitArray.unpack(packedSegment);\n        var geometry = geometryFromFunctionalGroups(dataset, segment.functionalGroups);\n        segment.geometry = geometry;\n      });\n      return segments;\n    }\n  }]);\n  return Segmentation;\n}();\n\nvar VTKjs = {\n  Segmentation: Segmentation\n};\n\nvar adapters = {\n  Cornerstone: Cornerstone,\n  Cornerstone3D: Cornerstone3D,\n  VTKjs: VTKjs\n};\n\nexport { adapters as adaptersSR, adapters as default };\n//# sourceMappingURL=adapters.es.js.map\n","\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n"],"names":[],"sourceRoot":""}