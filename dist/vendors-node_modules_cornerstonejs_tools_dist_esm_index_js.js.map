{"version":3,"file":"vendors-node_modules_cornerstonejs_tools_dist_esm_index_js.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClQA;AACA;AACA;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC53CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACxdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9EA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClCA;AACA;AACA;;;;;;;;;;;;;;;;ACFA;AACA;AACA;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/constants/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_setAttributesIfNecessary.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_setNewAttributesIfValid.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/enums/AnnotationStyleStates.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/enums/Events.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/enums/SegmentationRepresentations.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/enums/ToolBindings.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/enums/ToolModes.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/enums/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyDown.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardEventHandlers/keyUp.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseClick.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDoubleClick.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDown.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDownActivate.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseDrag.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseMove.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseUp.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseEventHandlers/mouseWheel.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/customCallbackHandler.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForKeyboardEvent.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForMouseEvent.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getActiveToolForTouchEvent.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForMouseEvent.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getToolsWithModesForTouchEvent.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchDrag.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchEnd.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchPress.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStart.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchStartActivate.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchEventHandlers/touchTap.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/keyboard/keyDownListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/getMouseEventPoints.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDoubleClickListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseDownListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/mouseMoveListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/getTouchEventPoints.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/preventGhostClick.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/touchStartListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/normalizeWheel.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/wheelListener.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/init.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentations.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationConfig.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/validateSegmentationInput.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationsFromToolGroup.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/triggerSegmentationEvents.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/filterMoveableAnnotationTools.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithAnnotationsForElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/filterToolsWithMoveableHandles.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/state.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar%20.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/stackImageSyncCallback.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createStackImageSynchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollToolMouseWheelTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateMouseWheelTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/base/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/addContourSetsToElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/addOrUpdateContourSets.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfigCache.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/removeContourFromElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/updateContourSets.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/utils.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/validateRepresentationData.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/SegmentationDisplayTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseRectangle.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/types/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/clip.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/getModalityUnit.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/angle/angleBetweenLines.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleCorners.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/getCanvasCircleRadius.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/circle/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/getCanvasEllipseCorners.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/ellipse/pointInEllipse.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/midPoint.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/calculateAreaOfPoints.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getIntersectionWithPolyline.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/liangBarksyClip.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolateAnnotation.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolatePoints.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInShapeCallback.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/scroll.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getDefaultRepresentationConfig.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isValidRepresentationConfig.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/triggerSegmentationRender.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/state.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/jumpToSlice.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/jumpToWorld.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/index.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/@kitware/vtk.js/Filters/General/AppendPolyData.js","file:////Users/smartxx/xV/DICOM/Viewers/node_modules/lodash.get/index.js"],"sourcesContent":["const CORNERSTONE_COLOR_LUT = [\n    [0, 0, 0, 0],\n    [221, 84, 84, 255],\n    [77, 228, 121, 255],\n    [166, 70, 235, 255],\n    [189, 180, 116, 255],\n    [109, 182, 196, 255],\n    [204, 101, 157, 255],\n    [123, 211, 94, 255],\n    [93, 87, 218, 255],\n    [225, 128, 80, 255],\n    [73, 232, 172, 255],\n    [181, 119, 186, 255],\n    [176, 193, 112, 255],\n    [105, 153, 200, 255],\n    [208, 97, 120, 255],\n    [90, 215, 101, 255],\n    [135, 83, 222, 255],\n    [229, 178, 76, 255],\n    [122, 183, 181, 255],\n    [190, 115, 171, 255],\n    [149, 197, 108, 255],\n    [100, 118, 205, 255],\n    [212, 108, 93, 255],\n    [86, 219, 141, 255],\n    [183, 79, 226, 255],\n    [233, 233, 72, 255],\n    [118, 167, 187, 255],\n    [194, 111, 146, 255],\n    [116, 201, 104, 255],\n    [115, 96, 209, 255],\n    [216, 147, 89, 255],\n    [82, 223, 188, 255],\n    [230, 75, 224, 255],\n    [163, 184, 121, 255],\n    [114, 143, 191, 255],\n    [198, 107, 114, 255],\n    [99, 206, 122, 255],\n    [153, 92, 213, 255],\n    [220, 192, 85, 255],\n    [78, 215, 227, 255],\n    [234, 71, 173, 255],\n    [141, 188, 117, 255],\n    [110, 113, 195, 255],\n    [202, 128, 103, 255],\n    [95, 210, 157, 255],\n    [195, 88, 217, 255],\n    [206, 224, 81, 255],\n    [74, 166, 231, 255],\n    [185, 120, 139, 255],\n    [113, 192, 113, 255],\n    [133, 106, 199, 255],\n    [207, 162, 98, 255],\n    [91, 214, 198, 255],\n    [221, 84, 198, 255],\n    [159, 228, 77, 255],\n    [70, 111, 235, 255],\n    [189, 119, 116, 255],\n    [109, 196, 138, 255],\n    [165, 101, 204, 255],\n    [211, 201, 94, 255],\n    [87, 191, 218, 255],\n    [225, 80, 153, 255],\n    [106, 232, 73, 255],\n    [124, 119, 186, 255],\n    [193, 142, 112, 255],\n    [105, 200, 168, 255],\n    [203, 97, 208, 255],\n    [184, 215, 90, 255],\n    [83, 147, 222, 255],\n    [229, 76, 101, 255],\n    [122, 183, 130, 255],\n    [146, 115, 190, 255],\n    [197, 171, 108, 255],\n    [100, 205, 205, 255],\n    [212, 93, 177, 255],\n    [141, 219, 86, 255],\n    [79, 97, 226, 255],\n    [233, 99, 72, 255],\n    [118, 187, 150, 255],\n    [173, 111, 194, 255],\n    [197, 201, 104, 255],\n    [96, 171, 209, 255],\n    [216, 89, 137, 255],\n    [94, 223, 82, 255],\n    [107, 75, 230, 255],\n    [184, 153, 121, 255],\n    [114, 191, 175, 255],\n    [198, 107, 191, 255],\n    [166, 206, 99, 255],\n    [92, 132, 213, 255],\n    [220, 85, 91, 255],\n    [78, 227, 115, 255],\n    [159, 71, 234, 255],\n    [188, 176, 117, 255],\n    [110, 185, 195, 255],\n    [202, 103, 161, 255],\n    [129, 210, 95, 255],\n    [88, 88, 217, 255],\n    [224, 123, 81, 255],\n    [74, 231, 166, 255],\n    [177, 120, 185, 255],\n    [179, 192, 113, 255],\n    [106, 156, 199, 255],\n    [207, 98, 125, 255],\n    [91, 214, 96, 255],\n    [130, 84, 221, 255],\n    [228, 171, 77, 255],\n    [70, 235, 221, 255],\n    [189, 116, 174, 255],\n    [153, 196, 109, 255],\n    [101, 123, 204, 255],\n    [211, 104, 94, 255],\n    [87, 218, 136, 255],\n    [177, 80, 225, 255],\n    [232, 225, 73, 255],\n    [119, 169, 186, 255],\n    [193, 112, 149, 255],\n    [121, 200, 105, 255],\n    [111, 97, 208, 255],\n    [215, 142, 90, 255],\n    [83, 222, 181, 255],\n    [229, 76, 229, 255],\n    [165, 183, 122, 255],\n    [115, 146, 190, 255],\n    [197, 108, 119, 255],\n    [100, 205, 118, 255],\n    [148, 93, 212, 255],\n    [219, 186, 86, 255],\n    [79, 220, 226, 255],\n    [233, 72, 179, 255],\n    [144, 187, 118, 255],\n    [111, 118, 194, 255],\n    [201, 124, 104, 255],\n    [96, 209, 153, 255],\n    [189, 89, 216, 255],\n    [211, 223, 82, 255],\n    [75, 172, 230, 255],\n    [184, 121, 142, 255],\n    [117, 191, 114, 255],\n    [130, 107, 198, 255],\n    [206, 157, 99, 255],\n    [92, 213, 193, 255],\n    [220, 85, 203, 255],\n    [165, 227, 78, 255],\n    [71, 118, 234, 255],\n    [188, 117, 117, 255],\n    [110, 195, 135, 255],\n    [161, 103, 202, 255],\n    [210, 195, 95, 255],\n    [88, 195, 217, 255],\n    [224, 81, 158, 255],\n    [113, 231, 74, 255],\n    [123, 120, 185, 255],\n    [192, 139, 113, 255],\n    [106, 199, 164, 255],\n    [198, 98, 207, 255],\n    [188, 214, 91, 255],\n    [84, 153, 221, 255],\n    [228, 77, 108, 255],\n    [70, 235, 84, 255],\n    [143, 116, 189, 255],\n    [196, 167, 109, 255],\n    [101, 204, 199, 255],\n    [211, 94, 182, 255],\n    [147, 218, 87, 255],\n    [80, 104, 225, 255],\n    [232, 93, 73, 255],\n    [119, 186, 147, 255],\n    [170, 112, 193, 255],\n    [200, 200, 105, 255],\n    [97, 175, 208, 255],\n    [215, 90, 142, 255],\n    [100, 222, 83, 255],\n    [101, 76, 229, 255],\n    [183, 150, 122, 255],\n    [115, 190, 171, 255],\n    [197, 108, 194, 255],\n    [170, 205, 100, 255],\n    [93, 138, 212, 255],\n    [219, 86, 97, 255],\n    [79, 226, 110, 255],\n    [153, 72, 233, 255],\n    [187, 173, 118, 255],\n    [111, 187, 194, 255],\n    [201, 104, 165, 255],\n    [134, 209, 96, 255],\n    [89, 95, 216, 255],\n    [223, 117, 82, 255],\n    [75, 230, 159, 255],\n    [174, 121, 184, 255],\n    [182, 191, 114, 255],\n    [107, 160, 198, 255],\n    [206, 99, 130, 255],\n    [92, 213, 92, 255],\n    [124, 85, 220, 255],\n    [227, 165, 78, 255],\n    [71, 234, 214, 255],\n    [188, 117, 176, 255],\n    [156, 195, 110, 255],\n    [103, 128, 202, 255],\n    [210, 100, 95, 255],\n    [88, 217, 131, 255],\n    [170, 81, 224, 255],\n    [231, 218, 74, 255],\n    [120, 172, 185, 255],\n    [192, 113, 153, 255],\n    [125, 199, 106, 255],\n    [107, 98, 207, 255],\n    [214, 137, 91, 255],\n    [84, 221, 175, 255],\n    [222, 77, 228, 255],\n    [194, 235, 70, 255],\n    [116, 149, 189, 255],\n    [196, 109, 123, 255],\n    [101, 204, 114, 255],\n    [143, 94, 211, 255],\n    [218, 180, 87, 255],\n    [80, 225, 225, 255],\n    [232, 73, 186, 255],\n    [147, 186, 119, 255],\n    [112, 122, 193, 255],\n    [200, 121, 105, 255],\n    [97, 208, 148, 255],\n    [184, 90, 215, 255],\n    [216, 222, 83, 255],\n    [76, 178, 229, 255],\n    [183, 122, 145, 255],\n    [121, 190, 115, 255],\n    [126, 108, 197, 255],\n    [205, 153, 100, 255],\n    [93, 212, 187, 255],\n    [219, 86, 208, 255],\n    [171, 226, 79, 255],\n    [72, 126, 233, 255],\n    [187, 118, 121, 255],\n    [111, 194, 132, 255],\n    [157, 104, 201, 255],\n    [209, 190, 96, 255],\n    [89, 200, 216, 255],\n    [223, 82, 164, 255],\n    [120, 230, 75, 255],\n    [121, 121, 184, 255],\n    [191, 136, 114, 255],\n    [107, 198, 160, 255],\n    [192, 99, 206, 255],\n    [193, 213, 92, 255],\n    [85, 158, 220, 255],\n    [227, 78, 115, 255],\n    [71, 234, 78, 255],\n    [141, 117, 188, 255],\n    [195, 163, 110, 255],\n    [103, 202, 194, 255],\n    [210, 95, 186, 255],\n    [153, 217, 88, 255],\n    [81, 111, 224, 255],\n];\nexport default CORNERSTONE_COLOR_LUT;\n//# sourceMappingURL=COLOR_LUT.js.map","import COLOR_LUT from './COLOR_LUT';\nexport { COLOR_LUT };\n//# sourceMappingURL=index.js.map","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\nconst DEFAULT_NAME = 'image-cursor';\nexport default class ImageMouseCursor extends MouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);\n        this.url = url;\n        this.x = Number(x) || 0;\n        this.y = Number(y) || 0;\n    }\n    getStyleProperty() {\n        const { url, x, y } = this;\n        let style = `url('${url}')`;\n        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n            style += ` ${x} ${y}`;\n        }\n        return this.addFallbackStyleProperty(style);\n    }\n    static getUniqueInstanceName(prefix) {\n        return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n    }\n}\n//# sourceMappingURL=ImageMouseCursor.js.map","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n    'alias',\n    'all-scroll',\n    'auto',\n    'cell',\n    'col-resize',\n    'context-menu',\n    'copy',\n    'crosshair',\n    'default',\n    'e-resize',\n    'ew-resize',\n    'grab',\n    'grabbing',\n    'help',\n    'move',\n    'ne-resize',\n    'nesw-resize',\n    'no-drop',\n    'none',\n    'not-allowed',\n    'n-resize',\n    'ns-resize',\n    'nw-resize',\n    'nwse-resize',\n    'pointer',\n    'progress',\n    'row-resize',\n    'se-resize',\n    's-resize',\n    'sw-resize',\n    'text',\n    'vertical-text',\n    'wait',\n    'w-resize',\n    'zoom-in',\n    'zoom-out',\n]);\nexport default class MouseCursor {\n    constructor(name, fallback) {\n        this.name = name + '';\n        this.fallback = fallback;\n    }\n    getName() {\n        return this.name + '';\n    }\n    addFallbackStyleProperty(style) {\n        const { fallback } = this;\n        if (fallback instanceof MouseCursor) {\n            return `${style}, ${fallback.getStyleProperty()}`;\n        }\n        return style + '';\n    }\n    getStyleProperty() {\n        return this.addFallbackStyleProperty(this.name) + '';\n    }\n    static getDefinedCursor(name) {\n        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n        let mouseCursor = definedCursors.get(name);\n        if (mouseCursor instanceof MouseCursor) {\n            return mouseCursor;\n        }\n        if (STANDARD_CURSORS.has(name)) {\n            mouseCursor = new MouseCursor(name);\n            definedCursors.set(name, mouseCursor);\n            return mouseCursor;\n        }\n    }\n    static setDefinedCursor(name, cursor) {\n        if (cursor instanceof MouseCursor) {\n            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n            definedCursors.set(name, cursor);\n            return true;\n        }\n        return false;\n    }\n}\nfunction getDefinedCursors(context, symbol) {\n    let definedCursors = context[symbol];\n    if (!(definedCursors instanceof Map)) {\n        definedCursors = new Map();\n        Object.defineProperty(context, symbol, { value: definedCursors });\n    }\n    return definedCursors;\n}\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n//# sourceMappingURL=MouseCursor.js.map","const BASE = {\n    iconContent: '',\n    iconSize: 16,\n    viewBox: {\n        x: 16,\n        y: 16,\n    },\n    mousePoint: {\n        x: 8,\n        y: 8,\n    },\n    mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n    x: 127,\n    y: 60,\n};\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CursorSVG = {\n    Angle: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    ArrowAnnotate: extend(BASE, {\n        iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Bidirectional: extend(BASE, {\n        iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n        viewBox: {\n            x: 48,\n            y: 48,\n        },\n    }),\n    CobbAngle: extend(BASE, {\n        iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    CircleROI: extend(BASE, {\n        iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    EllipticalROI: extend(BASE, {\n        iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    FreehandROI: extend(BASE, {\n        iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    FreehandROISculptor: extend(BASE, {\n        iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Length: extend(BASE, {\n        iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Probe: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    RectangleROI: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    TextMarker: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Crosshairs: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Eraser: extend(BASE, {\n        iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n        viewBox: {\n            x: 2048,\n            y: 1792,\n        },\n    }),\n    Magnify: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n        viewBox: {\n            x: 512,\n            y: 512,\n        },\n    }),\n    Pan: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Rotate: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    StackScroll: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n        viewBox: {\n            x: 24,\n            y: 28,\n        },\n    }),\n    WindowLevelRegion: extend(BASE, {\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    WindowLevel: extend(BASE, {\n        iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Zoom: extend(BASE, {\n        iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n        viewBox: {\n            x: 640,\n            y: 512,\n        },\n    }),\n    SegmentationFreeHandEraseInside: extend(BASE, {\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillInside: extend(BASE, {\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandEraseOutside: extend(BASE, {\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillOutside: extend(BASE, {\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationRectangleEraseInside: extend(BASE, {\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    RectangleScissor: extend(BASE, {\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_INSIDE': extend(BASE, {\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    CircleScissor: extend(BASE, {\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_INSIDE': extend(BASE, {\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n};\nfunction extend(base, values) {\n    return Object.assign(Object.create(base), values);\n}\nfunction registerCursor(toolName, iconContent, viewBox) {\n    CursorSVG[toolName] = extend(BASE, {\n        iconContent,\n        viewBox,\n    });\n}\nfunction getDefinedSVGCursorDescriptor(name) {\n    if (Object.prototype.hasOwnProperty.call(CursorSVG, name)) {\n        return CursorSVG[name];\n    }\n}\nconst svgCursorNames = Object.keys(CursorSVG);\nexport { getDefinedSVGCursorDescriptor, registerCursor, svgCursorNames, CursorSVG, };\n//# sourceMappingURL=SVGCursorDescriptor.js.map","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\nexport default class SVGMouseCursor extends ImageMouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(url, x, y, name, fallback);\n    }\n    static getDefinedCursor(name, pointer = false, color) {\n        if (!color) {\n            color = getStyleProperty(PROPERTY, {}, STATE, MODE);\n        }\n        const urn = getCursorURN(name, pointer, color);\n        let cursor = super.getDefinedCursor(urn);\n        if (!cursor) {\n            const descriptor = getDefinedSVGCursorDescriptor(name);\n            if (descriptor) {\n                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, super.getDefinedCursor('default'));\n                super.setDefinedCursor(urn, cursor);\n            }\n        }\n        return cursor;\n    }\n}\nfunction format(template, dictionary) {\n    const dict = Object(dictionary);\n    const defined = Object.prototype.hasOwnProperty.bind(dict);\n    return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n        return defined(key) ? dict[key] + '' : '';\n    });\n}\nfunction getCursorURN(name, pointer, color) {\n    const type = pointer ? 'pointer' : 'cursor';\n    return `${type}:${name}/${color}`;\n}\nfunction createSVGMouseCursor(descriptor, name, pointer, color, fallback) {\n    const { x, y } = descriptor.mousePoint;\n    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color }), x, y, name, fallback);\n}\nfunction createSVGIconUrl(descriptor, pointer, options) {\n    return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\nfunction createSVGIconBlob(descriptor, pointer, options) {\n    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);\n    return new Blob([svgString], { type: 'image/svg+xml' });\n}\nfunction createSVGIcon(descriptor, options) {\n    const { iconContent, iconSize, viewBox } = descriptor;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n    return format(svgString, options);\n}\nfunction createSVGIconWithPointer(descriptor, options) {\n    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;\n    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n    const svgSize = 16 + iconSize;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n    return format(svgString, options);\n}\n//# sourceMappingURL=SVGMouseCursor.js.map","import { MouseCursor } from '.';\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\nfunction initElementCursor(element, cursor) {\n    _getElementCursors(element)[0] = cursor;\n    _setElementCursor(element, cursor);\n}\nfunction _setElementCursor(element, cursor) {\n    const cursors = _getElementCursors(element);\n    cursors[1] = cursors[0];\n    cursors[0] = cursor;\n    element.style.cursor = (cursor instanceof MouseCursor\n        ? cursor\n        : MouseCursor.getDefinedCursor('auto')).getStyleProperty();\n}\nfunction resetElementCursor(element) {\n    _setElementCursor(element, _getElementCursors(element)[1]);\n}\nfunction hideElementCursor(element) {\n    _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\nfunction _getElementCursors(element) {\n    let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n    if (!(map instanceof WeakMap)) {\n        map = new WeakMap();\n        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n            value: map,\n        });\n    }\n    let cursors = map.get(element);\n    if (!cursors) {\n        cursors = [null, null];\n        map.set(element, cursors);\n    }\n    return cursors;\n}\nexport { initElementCursor, resetElementCursor, hideElementCursor, _setElementCursor as setElementCursor, };\n//# sourceMappingURL=elementCursor.js.map","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport { registerCursor, svgCursorNames, CursorSVG, } from './SVGCursorDescriptor';\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\nexport { MouseCursor, ImageMouseCursor, SVGMouseCursor, elementCursor, registerCursor, CursorNames, CursorSVG, setCursorForElement, };\n//# sourceMappingURL=index.js.map","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nfunction setCursorForElement(element, cursorName) {\n    let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n    if (!cursor) {\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    if (!cursor) {\n        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    setElementCursor(element, cursor);\n}\nexport default setCursorForElement;\n//# sourceMappingURL=setCursorForElement.js.map","function _getHash(annotationUID, drawingElementType, nodeUID) {\n    return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\nexport default _getHash;\n//# sourceMappingURL=_getHash.js.map","export function _setAttributesIfNecessary(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const currentValue = svgNode.getAttribute(key);\n        const newValue = attributes[key];\n        if (newValue === undefined || newValue === '') {\n            svgNode.removeAttribute(key);\n        }\n        else if (currentValue !== newValue) {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default _setAttributesIfNecessary;\n//# sourceMappingURL=_setAttributesIfNecessary.js.map","export function _setNewAttributesIfValid(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const newValue = attributes[key];\n        if (newValue !== undefined && newValue !== '') {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default _setNewAttributesIfValid;\n//# sourceMappingURL=_setNewAttributesIfValid.js.map","import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n//# sourceMappingURL=draw.js.map","import drawLine from './drawLine';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n    });\n}\n//# sourceMappingURL=drawArrow.js.map","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash } = Object.assign({\n        color: 'dodgerblue',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingCircleElement) {\n        _setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        _setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n//# sourceMappingURL=drawCircle.js.map","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nfunction drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const w = Math.abs(corner1[0] - corner2[0]);\n    const h = Math.abs(corner1[1] - corner2[1]);\n    const xMin = Math.min(corner1[0], corner2[0]);\n    const yMin = Math.min(corner1[1], corner2[1]);\n    const center = [xMin + w / 2, yMin + h / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        _setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        _setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipse;\n//# sourceMappingURL=drawEllipse.js.map","import _getHash from './_getHash';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({\n        color: 'dodgerblue',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    for (let i = 0; i < handlePoints.length; i++) {\n        const handle = handlePoints[i];\n        const svgns = 'http://www.w3.org/2000/svg';\n        const svgNodeHash = _getHash(annotationUID, 'handle', `hg-${handleGroupUID}-index-${i}`);\n        let attributes;\n        if (type === 'circle') {\n            attributes = {\n                cx: `${handle[0]}`,\n                cy: `${handle[1]}`,\n                r: handleRadius,\n                stroke: color,\n                fill,\n                'stroke-width': strokeWidth,\n                opacity: opacity,\n            };\n        }\n        else if (type === 'rect') {\n            const handleRadiusFloat = parseFloat(handleRadius);\n            const side = handleRadiusFloat * 1.5;\n            const x = handle[0] - side * 0.5;\n            const y = handle[1] - side * 0.5;\n            attributes = {\n                x: `${x}`,\n                y: `${y}`,\n                width: `${side}`,\n                height: `${side}`,\n                stroke: color,\n                fill,\n                'stroke-width': strokeWidth,\n                rx: `${side * 0.1}`,\n                opacity: opacity,\n            };\n        }\n        else {\n            throw new Error(`Unsupported handle type: ${type}`);\n        }\n        const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n        if (existingHandleElement) {\n            _setAttributesIfNecessary(attributes, existingHandleElement);\n            svgDrawingHelper.setNodeTouched(svgNodeHash);\n        }\n        else {\n            const newHandleElement = document.createElementNS(svgns, type);\n            _setNewAttributesIfValid(attributes, newHandleElement);\n            svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n        }\n    }\n}\nexport default drawHandles;\n//# sourceMappingURL=drawHandles.js.map","import _getHash from './_getHash';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nexport default function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash, shadow } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n        shadow: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const dropShadowStyle = shadow\n        ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n        : '';\n    const attributes = {\n        x1: `${start[0]}`,\n        y1: `${start[1]}`,\n        x2: `${end[0]}`,\n        y2: `${end[1]}`,\n        stroke: color,\n        style: dropShadowStyle,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingLine) {\n        _setAttributesIfNecessary(attributes, existingLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newLine = document.createElementNS(svgns, 'line');\n        if (dataId !== '') {\n            newLine.setAttribute('data-id', dataId);\n        }\n        _setNewAttributesIfValid(attributes, newLine);\n        svgDrawingHelper.appendNode(newLine, svgNodeHash);\n    }\n}\n//# sourceMappingURL=drawLine.js.map","import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n//# sourceMappingURL=drawLink.js.map","import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n//# sourceMappingURL=drawLinkedTextBox.js.map","import _getHash from './_getHash';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nexport default function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {\n    if (points.length < 2) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n        connectLastToFirst: false,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (const point of points) {\n        pointsAttribute += `${point[0]}, ${point[1]} `;\n    }\n    if (options.connectLastToFirst) {\n        const firstPoint = points[0];\n        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n    }\n    const attributes = {\n        points: pointsAttribute,\n        stroke: color,\n        fill: 'none',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingPolyLine) {\n        _setAttributesIfNecessary(attributes, existingPolyLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newPolyLine = document.createElementNS(svgns, 'polyline');\n        _setNewAttributesIfValid(attributes, newPolyLine);\n        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n    }\n}\n//# sourceMappingURL=drawPolyline.js.map","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './_setNewAttributesIfValid';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'dodgerblue',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    const attributes = {\n        x: `${tlhc[0]}`,\n        y: `${tlhc[1]}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'transparent',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        _setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        if (dataId !== '') {\n            svgRectElement.setAttribute('data-id', dataId);\n        }\n        _setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n//# sourceMappingURL=drawRect.js.map","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './_setAttributesIfNecessary';\nfunction drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {\n    const mergedOptions = Object.assign({\n        fontFamily: 'Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        color: 'rgb(255, 255, 0)',\n        background: '',\n        padding: 25,\n        centerX: false,\n        centerY: true,\n    }, options);\n    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);\n    return textGroupBoundingBox;\n}\nfunction _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {\n    const { padding, color, fontFamily, fontSize, background } = options;\n    let textGroupBoundingBox;\n    const [x, y] = [position[0] + padding, position[1] + padding];\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingTextGroup) {\n        const textElement = existingTextGroup.querySelector('text');\n        const textSpans = Array.from(textElement.children);\n        for (let i = 0; i < textSpans.length; i++) {\n            const textSpanElement = textSpans[i];\n            const text = textLines[i] || '';\n            textSpanElement.textContent = text;\n        }\n        if (textLines.length > textSpans.length) {\n            for (let i = 0; i < textLines.length - textSpans.length; i++) {\n                const textLine = textLines[i + textSpans.length];\n                const textSpan = _createTextSpan(textLine);\n                textElement.appendChild(textSpan);\n            }\n            existingTextGroup.appendChild(textElement);\n            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n        }\n        const textAttributes = {\n            fill: color,\n            'font-size': fontSize,\n            'font-family': fontFamily,\n        };\n        const textGroupAttributes = {\n            transform: `translate(${x} ${y})`,\n        };\n        _setAttributesIfNecessary(textAttributes, textElement);\n        _setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n        textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const textGroup = document.createElementNS(svgns, 'g');\n        textGroup.setAttribute('transform', `translate(${x} ${y})`);\n        const textElement = _createTextElement(svgDrawingHelper, options);\n        for (let i = 0; i < textLines.length; i++) {\n            const textLine = textLines[i];\n            const textSpan = _createTextSpan(textLine);\n            textElement.appendChild(textSpan);\n        }\n        textGroup.appendChild(textElement);\n        svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n        textGroupBoundingBox = _drawTextBackground(textGroup, background);\n    }\n    return Object.assign({}, textGroupBoundingBox, {\n        x,\n        y,\n        height: textGroupBoundingBox.height + padding,\n        width: textGroupBoundingBox.width + padding,\n    });\n}\nfunction _createTextElement(svgDrawingHelper, options) {\n    const { color, fontFamily, fontSize } = options;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textElement = document.createElementNS(svgns, 'text');\n    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n    textElement.setAttribute('x', '0');\n    textElement.setAttribute('y', '0');\n    textElement.setAttribute('fill', color);\n    textElement.setAttribute('font-family', fontFamily);\n    textElement.setAttribute('font-size', fontSize);\n    textElement.setAttribute('style', combinedStyle);\n    return textElement;\n}\nfunction _createTextSpan(text) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textSpanElement = document.createElementNS(svgns, 'tspan');\n    textSpanElement.setAttribute('x', '0');\n    textSpanElement.setAttribute('dy', '1.2em');\n    textSpanElement.textContent = text;\n    return textSpanElement;\n}\nfunction _drawTextBackground(group, color) {\n    let element = group.querySelector('rect.background');\n    if (!color) {\n        if (element) {\n            group.removeChild(element);\n        }\n        return group.getBBox();\n    }\n    if (!element) {\n        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        element.setAttribute('class', 'background');\n        group.insertBefore(element, group.firstChild);\n    }\n    const bBox = group.getBBox();\n    const attributes = {\n        x: `${bBox.x}`,\n        y: `${bBox.y}`,\n        width: `${bBox.width}`,\n        height: `${bBox.height}`,\n        fill: color,\n    };\n    _setAttributesIfNecessary(attributes, element);\n    return bBox;\n}\nexport default drawTextBox;\n//# sourceMappingURL=drawTextBox.js.map","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement.querySelector('.svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n//# sourceMappingURL=getSvgDrawingHelper.js.map","import draw from './draw';\nimport drawCircle from './drawCircle';\nimport drawEllipse from './drawEllipse';\nimport drawHandles from './drawHandles';\nimport drawLine from './drawLine';\nimport drawPolyline from './drawPolyline';\nimport drawLinkedTextBox from './drawLinkedTextBox';\nimport drawRect from './drawRect';\nimport drawTextBox from './drawTextBox';\nimport drawArrow from './drawArrow';\nexport { draw, drawCircle, drawEllipse, drawHandles, drawLine, drawPolyline, drawLinkedTextBox, drawRect, drawTextBox, drawArrow, };\n//# sourceMappingURL=index.js.map","var AnnotationStyleStates;\n(function (AnnotationStyleStates) {\n    AnnotationStyleStates[\"Default\"] = \"\";\n    AnnotationStyleStates[\"Highlighted\"] = \"Highlighted\";\n    AnnotationStyleStates[\"Selected\"] = \"Selected\";\n    AnnotationStyleStates[\"Locked\"] = \"Locked\";\n})(AnnotationStyleStates || (AnnotationStyleStates = {}));\nexport default AnnotationStyleStates;\n//# sourceMappingURL=AnnotationStyleStates.js.map","var Events;\n(function (Events) {\n    Events[\"ANNOTATION_ADDED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_ADDED\";\n    Events[\"ANNOTATION_COMPLETED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_COMPLETED\";\n    Events[\"ANNOTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_MODIFIED\";\n    Events[\"ANNOTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_REMOVED\";\n    Events[\"ANNOTATION_SELECTION_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE\";\n    Events[\"ANNOTATION_LOCK_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE\";\n    Events[\"ANNOTATION_VISIBILITY_CHANGE\"] = \"CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE\";\n    Events[\"ANNOTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_ANNOTATION_RENDERED\";\n    Events[\"SEGMENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_RENDERED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_RENDERED\";\n    Events[\"SEGMENTATION_REPRESENTATION_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED\";\n    Events[\"SEGMENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REMOVED\";\n    Events[\"SEGMENTATION_REPRESENTATION_REMOVED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED\";\n    Events[\"SEGMENTATION_DATA_MODIFIED\"] = \"CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED\";\n    Events[\"KEY_DOWN\"] = \"CORNERSTONE_TOOLS_KEY_DOWN\";\n    Events[\"KEY_UP\"] = \"CORNERSTONE_TOOLS_KEY_UP\";\n    Events[\"MOUSE_DOWN\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN\";\n    Events[\"MOUSE_UP\"] = \"CORNERSTONE_TOOLS_MOUSE_UP\";\n    Events[\"MOUSE_DOWN_ACTIVATE\"] = \"CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE\";\n    Events[\"MOUSE_DRAG\"] = \"CORNERSTONE_TOOLS_MOUSE_DRAG\";\n    Events[\"MOUSE_MOVE\"] = \"CORNERSTONE_TOOLS_MOUSE_MOVE\";\n    Events[\"MOUSE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_CLICK\";\n    Events[\"MOUSE_DOUBLE_CLICK\"] = \"CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK\";\n    Events[\"MOUSE_WHEEL\"] = \"CORNERSTONE_TOOLS_MOUSE_WHEEL\";\n    Events[\"TOUCH_START\"] = \"CORNERSTONE_TOOLS_TOUCH_START\";\n    Events[\"TOUCH_START_ACTIVATE\"] = \"CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE\";\n    Events[\"TOUCH_PRESS\"] = \"CORNERSTONE_TOOLS_TOUCH_PRESS\";\n    Events[\"TOUCH_DRAG\"] = \"CORNERSTONE_TOOLS_TOUCH_DRAG\";\n    Events[\"TOUCH_END\"] = \"CORNERSTONE_TOOLS_TOUCH_END\";\n    Events[\"TOUCH_TAP\"] = \"CORNERSTONE_TOOLS_TAP\";\n    Events[\"TOUCH_SWIPE\"] = \"CORNERSTONE_TOOLS_SWIPE\";\n})(Events || (Events = {}));\nexport default Events;\n//# sourceMappingURL=Events.js.map","var SegmentationRepresentations;\n(function (SegmentationRepresentations) {\n    SegmentationRepresentations[\"Labelmap\"] = \"LABELMAP\";\n    SegmentationRepresentations[\"Contour\"] = \"CONTOUR\";\n})(SegmentationRepresentations || (SegmentationRepresentations = {}));\nexport default SegmentationRepresentations;\n//# sourceMappingURL=SegmentationRepresentations.js.map","var MouseBindings;\n(function (MouseBindings) {\n    MouseBindings[MouseBindings[\"Primary\"] = 1] = \"Primary\";\n    MouseBindings[MouseBindings[\"Secondary\"] = 2] = \"Secondary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary\"] = 3] = \"Primary_And_Secondary\";\n    MouseBindings[MouseBindings[\"Auxiliary\"] = 4] = \"Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Auxiliary\"] = 5] = \"Primary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Secondary_And_Auxiliary\"] = 6] = \"Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Primary_And_Secondary_And_Auxiliary\"] = 7] = \"Primary_And_Secondary_And_Auxiliary\";\n    MouseBindings[MouseBindings[\"Fourth_Button\"] = 8] = \"Fourth_Button\";\n    MouseBindings[MouseBindings[\"Fifth_Button\"] = 16] = \"Fifth_Button\";\n})(MouseBindings || (MouseBindings = {}));\nvar KeyboardBindings;\n(function (KeyboardBindings) {\n    KeyboardBindings[KeyboardBindings[\"Shift\"] = 16] = \"Shift\";\n    KeyboardBindings[KeyboardBindings[\"Ctrl\"] = 17] = \"Ctrl\";\n    KeyboardBindings[KeyboardBindings[\"Alt\"] = 18] = \"Alt\";\n    KeyboardBindings[KeyboardBindings[\"Meta\"] = 91] = \"Meta\";\n    KeyboardBindings[KeyboardBindings[\"ShiftCtrl\"] = 1617] = \"ShiftCtrl\";\n    KeyboardBindings[KeyboardBindings[\"ShiftAlt\"] = 1618] = \"ShiftAlt\";\n    KeyboardBindings[KeyboardBindings[\"ShiftMeta\"] = 1691] = \"ShiftMeta\";\n    KeyboardBindings[KeyboardBindings[\"CtrlAlt\"] = 1718] = \"CtrlAlt\";\n    KeyboardBindings[KeyboardBindings[\"CtrlMeta\"] = 1791] = \"CtrlMeta\";\n    KeyboardBindings[KeyboardBindings[\"AltMeta\"] = 1891] = \"AltMeta\";\n})(KeyboardBindings || (KeyboardBindings = {}));\nexport { MouseBindings, KeyboardBindings };\n//# sourceMappingURL=ToolBindings.js.map","var ToolModes;\n(function (ToolModes) {\n    ToolModes[\"Active\"] = \"Active\";\n    ToolModes[\"Passive\"] = \"Passive\";\n    ToolModes[\"Enabled\"] = \"Enabled\";\n    ToolModes[\"Disabled\"] = \"Disabled\";\n})(ToolModes || (ToolModes = {}));\nexport default ToolModes;\n//# sourceMappingURL=ToolModes.js.map","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n//# sourceMappingURL=Touch.js.map","import { MouseBindings, KeyboardBindings } from './ToolBindings';\nimport ToolModes from './ToolModes';\nimport AnnotationStyleStates from './AnnotationStyleStates';\nimport Events from './Events';\nimport SegmentationRepresentations from './SegmentationRepresentations';\nimport { Swipe } from './Touch';\nexport { MouseBindings, KeyboardBindings, ToolModes, AnnotationStyleStates, Events, SegmentationRepresentations, Swipe, };\n//# sourceMappingURL=index.js.map","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraModified = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onCameraModified) {\n            tool.onCameraModified(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nexport default {\n    enable,\n    disable,\n};\n//# sourceMappingURL=cameraModifiedEventDispatcher.js.map","import { Enums } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\nconst onImageRendered = function (evt) {\n    triggerAnnotationRender(evt.detail.element);\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nexport default {\n    enable,\n    disable,\n};\n//# sourceMappingURL=imageRenderedEventDispatcher.js.map","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onImageSpacingCalibrated = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onImageSpacingCalibrated) {\n            tool.onImageSpacingCalibrated(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nexport default {\n    enable,\n    disable,\n};\n//# sourceMappingURL=imageSpacingCalibratedEventDispatcher.js.map","import imageRenderedEventDispatcher from './imageRenderedEventDispatcher';\nimport mouseToolEventDispatcher from './mouseToolEventDispatcher';\nimport keyboardToolEventDispatcher from './keyboardToolEventDispatcher';\nimport cameraModifiedEventDispatcher from './cameraModifiedEventDispatcher';\nimport imageSpacingCalibratedEventDispatcher from './imageSpacingCalibratedEventDispatcher';\nimport touchToolEventDispatcher from './touchToolEventDispatcher';\nexport { imageRenderedEventDispatcher, mouseToolEventDispatcher, keyboardToolEventDispatcher, cameraModifiedEventDispatcher, imageSpacingCalibratedEventDispatcher, touchToolEventDispatcher, };\n//# sourceMappingURL=index.js.map","import keyDown from './keyDown';\nimport keyUp from './keyUp';\nexport { keyDown, keyUp };\n//# sourceMappingURL=index.js.map","import { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nexport default function keyDown(evt) {\n    const activeTool = getActiveToolForKeyboardEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    const toolName = activeTool.getToolName();\n    if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n        toolGroup.setViewportsCursorByToolName(toolName);\n    }\n}\n//# sourceMappingURL=keyDown.js.map","import { resetModifierKey } from '../../eventListeners/keyboard/keyDownListener';\nimport { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nexport default function keyUp(evt) {\n    const activeTool = getActiveToolForKeyboardEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    resetModifierKey();\n    const toolName = activeTool.getToolName();\n    if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n        toolGroup.setViewportsCursorByToolName(toolName);\n    }\n}\n//# sourceMappingURL=keyUp.js.map","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.KEY_DOWN, keyDown);\n    element.addEventListener(Events.KEY_UP, keyUp);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.KEY_DOWN, keyDown);\n    element.removeEventListener(Events.KEY_UP, keyUp);\n};\nconst keyboardToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default keyboardToolEventDispatcher;\n//# sourceMappingURL=keyboardToolEventDispatcher.js.map","import mouseClick from './mouseClick';\nimport mouseDoubleClick from './mouseDoubleClick';\nimport mouseDown from './mouseDown';\nimport mouseDownActivate from './mouseDownActivate';\nimport mouseDrag from './mouseDrag';\nimport mouseMove from './mouseMove';\nimport mouseUp from './mouseUp';\nimport mouseWheel from './mouseWheel';\nexport { mouseClick, mouseDown, mouseDownActivate, mouseDoubleClick, mouseDrag, mouseMove, mouseUp, mouseWheel, };\n//# sourceMappingURL=index.js.map","import customCallbackHandler from '../shared/customCallbackHandler';\nconst mouseClick = customCallbackHandler.bind(null, 'Mouse', 'mouseClickCallback');\nexport default mouseClick;\n//# sourceMappingURL=mouseClick.js.map","import customCallbackHandler from '../shared/customCallbackHandler';\nconst mouseDoubleClick = customCallbackHandler.bind(null, 'Mouse', 'doubleClickCallback');\nexport default mouseDoubleClick;\n//# sourceMappingURL=mouseDoubleClick.js.map","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { setAnnotationSelected, isAnnotationSelected, } from '../../stateManagement/annotation/annotationSelection';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive } = ToolModes;\nexport default function mouseDown(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForMouseEvent(evt);\n    if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {\n        const consumedEvent = activeTool.preMouseDownCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n    const isPrimaryClick = evt.detail.event.buttons === 1;\n    const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(evt, [Active], evt.detail.event.buttons);\n    const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick\n        ? getToolsWithModesForMouseEvent(evt, [Passive])\n        : undefined;\n    const applicableTools = [\n        ...(activeToolsWithEventBinding || []),\n        ...(passiveToolsIfEventWasPrimaryMouseButton || []),\n    ];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, applicableTools);\n    const canvasCoords = eventDetail.currentPoints.canvas;\n    const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(element, annotationToolsWithAnnotations, canvasCoords, 'mouse');\n    const isMultiSelect = !!evt.detail.event.shiftKey;\n    if (annotationToolsWithMoveableHandles.length > 0) {\n        const { tool, annotation, handle } = getAnnotationForSelection(annotationToolsWithMoveableHandles);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');\n        return;\n    }\n    const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords, 'mouse');\n    if (moveableAnnotationTools.length > 0) {\n        const { tool, annotation } = getAnnotationForSelection(moveableAnnotationTools);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.toolSelectedCallback(evt, annotation, 'Mouse');\n        return;\n    }\n    if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {\n        const consumedEvent = activeTool.postMouseDownCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n}\nfunction getAnnotationForSelection(toolsWithMovableHandles) {\n    return ((toolsWithMovableHandles.length > 1 &&\n        toolsWithMovableHandles.find((item) => !isAnnotationLocked(item.annotation) &&\n            isAnnotationVisible(item.annotation.annotationUID))) ||\n        toolsWithMovableHandles[0]);\n}\nfunction toggleAnnotationSelection(annotationUID, isMultiSelect = false) {\n    if (isMultiSelect) {\n        if (isAnnotationSelected(annotationUID)) {\n            setAnnotationSelected(annotationUID, false);\n        }\n        else {\n            const preserveSelected = true;\n            setAnnotationSelected(annotationUID, true, preserveSelected);\n        }\n    }\n    else {\n        const preserveSelected = false;\n        setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n}\n//# sourceMappingURL=mouseDown.js.map","import { state } from '../../store';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nexport default function mouseDownActivate(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForMouseEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    if (state.isMultiPartToolActive) {\n        return;\n    }\n    if (activeTool.addNewAnnotation) {\n        const annotation = activeTool.addNewAnnotation(evt, 'mouse');\n        setAnnotationSelected(annotation.annotationUID);\n    }\n}\n//# sourceMappingURL=mouseDownActivate.js.map","import getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { state } from '../../store';\nexport default function mouseDrag(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForMouseEvent(evt);\n    const noFoundToolOrDoesNotHaveMouseDragCallback = !activeTool || typeof activeTool.mouseDragCallback !== 'function';\n    if (noFoundToolOrDoesNotHaveMouseDragCallback) {\n        return;\n    }\n    activeTool.mouseDragCallback(evt);\n}\n//# sourceMappingURL=mouseDrag.js.map","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nconst { Active, Passive } = ToolModes;\nexport default function mouseMove(evt) {\n    if (state.isInteractingWithTool || state.isMultiPartToolActive) {\n        return;\n    }\n    const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n    ]);\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const toolsWithAnnotations = filterToolsWithAnnotationsForElement(element, activeAndPassiveTools);\n    const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {\n        const doesNotHaveAnnotations = !toolsWithAnnotations.some((toolAndAnnotation) => toolAndAnnotation.tool.getToolName() === tool.getToolName());\n        return doesNotHaveAnnotations;\n    });\n    let annotationsNeedToBeRedrawn = false;\n    for (const { tool, annotations } of toolsWithAnnotations) {\n        if (typeof tool.mouseMoveCallback === 'function') {\n            annotationsNeedToBeRedrawn =\n                tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;\n        }\n    }\n    toolsWithoutAnnotations.forEach((tool) => {\n        if (typeof tool.mouseMoveCallback === 'function') {\n            tool.mouseMoveCallback(evt);\n        }\n    });\n    if (annotationsNeedToBeRedrawn === true) {\n        triggerAnnotationRender(element);\n    }\n}\n//# sourceMappingURL=mouseMove.js.map","import customCallbackHandler from '../shared/customCallbackHandler';\nconst mouseUp = customCallbackHandler.bind(null, 'Mouse', 'mouseUpCallback');\nexport default mouseUp;\n//# sourceMappingURL=mouseUp.js.map","import customCallbackHandler from '../shared/customCallbackHandler';\nconst mouseWheel = customCallbackHandler.bind(null, 'MouseWheel', 'mouseWheelCallback');\nexport default mouseWheel;\n//# sourceMappingURL=mouseWheel.js.map","import Events from '../enums/Events';\nimport { mouseClick, mouseDown, mouseDownActivate, mouseDoubleClick, mouseDrag, mouseMove, mouseUp, mouseWheel, } from './mouseEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.addEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.addEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.addEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.addEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.addEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.addEventListener(Events.MOUSE_UP, mouseUp);\n    element.addEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.removeEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.removeEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.removeEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.removeEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.removeEventListener(Events.MOUSE_UP, mouseUp);\n    element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst mouseToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default mouseToolEventDispatcher;\n//# sourceMappingURL=mouseToolEventDispatcher.js.map","import { state, ToolGroupManager } from '../../store';\nimport ToolModes from '../../enums/ToolModes';\nconst { Active } = ToolModes;\nexport default function customCallbackHandler(handlerType, customFunction, evt) {\n    if (state.isInteractingWithTool) {\n        return false;\n    }\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return false;\n    }\n    let activeTool;\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.toolOptions[toolName];\n        const toolInstance = toolGroup.getToolInstance(toolName);\n        if (tool.mode === Active &&\n            typeof toolInstance[customFunction] === 'function') {\n            activeTool = toolGroup.getToolInstance(toolName);\n            break;\n        }\n    }\n    if (!activeTool) {\n        return;\n    }\n    activeTool[customFunction](evt);\n}\n//# sourceMappingURL=customCallbackHandler.js.map","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { getMouseButton } from '../../eventListeners/mouse/mouseDownListener';\nconst { Active } = ToolModes;\nexport default function getActiveToolForKeyboardEvent(evt) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const mouseButton = getMouseButton();\n    const modifierKey = keyEventListener.getModifierKey();\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        const correctBinding = toolOptions.bindings.length &&\n            toolOptions.bindings.some((binding) => binding.mouseButton === (mouseButton ?? defaultMousePrimary) &&\n                binding.modifierKey === modifierKey);\n        if (toolOptions.mode === Active && correctBinding) {\n            return toolGroup.getToolInstance(toolName);\n        }\n    }\n}\n//# sourceMappingURL=getActiveToolForKeyboardEvent.js.map","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport getMouseModifier from './getMouseModifier';\nconst { Active } = ToolModes;\nexport default function getActiveToolForMouseEvent(evt) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const mouseEvent = evt.detail.event;\n    const modifierKey = getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        const correctBinding = toolOptions.bindings.length &&\n            toolOptions.bindings.some((binding) => {\n                return (binding.mouseButton ===\n                    (mouseEvent ? mouseEvent.buttons : defaultMousePrimary) &&\n                    binding.modifierKey === modifierKey);\n            });\n        if (toolOptions.mode === Active && correctBinding) {\n            return toolGroup.getToolInstance(toolName);\n        }\n    }\n}\n//# sourceMappingURL=getActiveToolForMouseEvent.js.map","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport getMouseModifier from './getMouseModifier';\nimport { keyEventListener } from '../../eventListeners';\nconst { Active } = ToolModes;\nexport default function getActiveToolForTouchEvent(evt) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const touchEvent = evt.detail.event;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    const numTouchPoints = Object.keys(touchEvent.touches).length;\n    const modifierKey = getMouseModifier(touchEvent) || keyEventListener.getModifierKey();\n    const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        const correctBinding = toolOptions.bindings.length &&\n            toolOptions.bindings.some((binding) => (binding.numTouchPoints === numTouchPoints ||\n                (numTouchPoints === 1 &&\n                    binding.mouseButton === defaultMousePrimary)) &&\n                binding.modifierKey === modifierKey);\n        if (toolOptions.mode === Active && correctBinding) {\n            return toolGroup.getToolInstance(toolName);\n        }\n    }\n}\n//# sourceMappingURL=getActiveToolForTouchEvent.js.map","import { KeyboardBindings as kb } from '../../enums';\nconst getMouseModifierKey = (evt) => {\n    if (evt.shiftKey) {\n        if (evt.ctrlKey)\n            return kb.ShiftCtrl;\n        if (evt.altKey)\n            return kb.ShiftAlt;\n        if (evt.metaKey)\n            return kb.ShiftMeta;\n        return kb.Shift;\n    }\n    if (evt.ctrlKey) {\n        if (evt.altKey)\n            return kb.CtrlAlt;\n        if (evt.metaKey)\n            return kb.CtrlMeta;\n        return kb.Ctrl;\n    }\n    if (evt.altKey) {\n        return (evt.metaKey && kb.AltMeta) || kb.Alt;\n    }\n    if (evt.metaKey) {\n        return kb.Meta;\n    }\n    return undefined;\n};\nexport default getMouseModifierKey;\n//# sourceMappingURL=getMouseModifier.js.map","import { ToolGroupManager } from '../../store';\nexport default function getToolsWithModesForMouseEvent(evt, modesFilter, evtButton) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return [];\n    }\n    const enabledTools = [];\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.toolOptions[toolName];\n        const correctBinding = evtButton != null &&\n            tool.bindings.length &&\n            tool.bindings.some((binding) => binding.mouseButton === evtButton);\n        if (modesFilter.includes(tool.mode) &&\n            (!evtButton || correctBinding)) {\n            const toolInstance = toolGroup.getToolInstance(toolName);\n            enabledTools.push(toolInstance);\n        }\n    }\n    return enabledTools;\n}\n//# sourceMappingURL=getToolsWithModesForMouseEvent.js.map","import { ToolGroupManager } from '../../store';\nexport default function getToolsWithModesForTouchEvent(evt, modesFilter, numTouchPoints) {\n    const { renderingEngineId, viewportId } = evt.detail;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return [];\n    }\n    const enabledTools = [];\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const tool = toolGroup.toolOptions[toolName];\n        const correctBinding = numTouchPoints != null &&\n            tool.bindings.length &&\n            tool.bindings.some((binding) => binding.numTouchPoints === numTouchPoints);\n        if (modesFilter.includes(tool.mode) &&\n            (!numTouchPoints || correctBinding)) {\n            const toolInstance = toolGroup.getToolInstance(toolName);\n            enabledTools.push(toolInstance);\n        }\n    }\n    return enabledTools;\n}\n//# sourceMappingURL=getToolsWithModesForTouchEvent.js.map","import touchStart from './touchStart';\nimport touchStartActivate from './touchStartActivate';\nimport touchDrag from './touchDrag';\nimport touchEnd from './touchEnd';\nimport touchTap from './touchTap';\nimport touchPress from './touchPress';\nexport { touchStart, touchStartActivate, touchDrag, touchEnd, touchTap, touchPress, };\n//# sourceMappingURL=index.js.map","import getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport { state } from '../../store';\nexport default function touchDrag(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForTouchEvent(evt);\n    const noFoundToolOrDoesNotHaveTouchDragCallback = !activeTool || typeof activeTool.touchDragCallback !== 'function';\n    if (noFoundToolOrDoesNotHaveTouchDragCallback) {\n        return;\n    }\n    activeTool.touchDragCallback(evt);\n}\n//# sourceMappingURL=touchDrag.js.map","import customCallbackHandler from '../shared/customCallbackHandler';\nconst touchEnd = customCallbackHandler.bind(null, 'Touch', 'touchEndCallback');\nexport default touchEnd;\n//# sourceMappingURL=touchEnd.js.map","import customCallbackHandler from '../shared/customCallbackHandler';\nconst touchPress = customCallbackHandler.bind(null, 'Touch', 'touchPressCallback');\nexport default touchPress;\n//# sourceMappingURL=touchPress.js.map","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { setAnnotationSelected, isAnnotationSelected, } from '../../stateManagement/annotation/annotationSelection';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport getToolsWithModesForTouchEvent from '../shared/getToolsWithModesForTouchEvent';\nconst { Active, Passive } = ToolModes;\nexport default function touchStart(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForTouchEvent(evt);\n    if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {\n        const consumedEvent = activeTool.preTouchStartCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n    const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;\n    const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(evt, [Active], Object.keys(evt.detail.event.touches).length);\n    const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick\n        ? getToolsWithModesForTouchEvent(evt, [Passive])\n        : undefined;\n    const applicableTools = [\n        ...(activeToolsWithEventBinding || []),\n        ...(passiveToolsIfEventWasPrimaryTouchButton || []),\n        activeTool,\n    ];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(element, applicableTools);\n    const canvasCoords = eventDetail.currentPoints.canvas;\n    const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(element, annotationToolsWithAnnotations, canvasCoords, 'touch');\n    const isMultiSelect = false;\n    if (annotationToolsWithMoveableHandles.length > 0) {\n        const { tool, annotation, handle } = getAnnotationForSelection(annotationToolsWithMoveableHandles);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.handleSelectedCallback(evt, annotation, handle, 'Touch');\n        return;\n    }\n    const moveableAnnotationTools = filterMoveableAnnotationTools(element, annotationToolsWithAnnotations, canvasCoords, 'touch');\n    if (moveableAnnotationTools.length > 0) {\n        const { tool, annotation } = getAnnotationForSelection(moveableAnnotationTools);\n        toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n        tool.toolSelectedCallback(evt, annotation, 'Touch');\n        return;\n    }\n    if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {\n        const consumedEvent = activeTool.postTouchStartCallback(evt);\n        if (consumedEvent) {\n            return;\n        }\n    }\n}\nfunction getAnnotationForSelection(toolsWithMovableHandles) {\n    return ((toolsWithMovableHandles.length > 1 &&\n        toolsWithMovableHandles.find((item) => !isAnnotationLocked(item.annotation) &&\n            isAnnotationVisible(item.annotation.annotationUID))) ||\n        toolsWithMovableHandles[0]);\n}\nfunction toggleAnnotationSelection(annotationUID, isMultiSelect = false) {\n    if (isMultiSelect) {\n        if (isAnnotationSelected(annotationUID)) {\n            setAnnotationSelected(annotationUID, false);\n        }\n        else {\n            const preserveSelected = true;\n            setAnnotationSelected(annotationUID, true, preserveSelected);\n        }\n    }\n    else {\n        const preserveSelected = false;\n        setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n}\n//# sourceMappingURL=touchStart.js.map","import { state } from '../../store';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nexport default function touchStartActivate(evt) {\n    if (state.isInteractingWithTool) {\n        return;\n    }\n    const activeTool = getActiveToolForTouchEvent(evt);\n    if (!activeTool) {\n        return;\n    }\n    if (state.isMultiPartToolActive) {\n        return;\n    }\n    if (activeTool.addNewAnnotation) {\n        const annotation = activeTool.addNewAnnotation(evt, 'touch');\n        setAnnotationSelected(annotation.annotationUID);\n    }\n}\n//# sourceMappingURL=touchStartActivate.js.map","import customCallbackHandler from '../shared/customCallbackHandler';\nconst touchTap = customCallbackHandler.bind(null, 'Touch', 'touchTapCallback');\nexport default touchTap;\n//# sourceMappingURL=touchTap.js.map","import Events from '../enums/Events';\nimport { touchStart, touchStartActivate, touchDrag, touchEnd, touchTap, touchPress, } from './touchEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.TOUCH_START, touchStart);\n    element.addEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.addEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.addEventListener(Events.TOUCH_END, touchEnd);\n    element.addEventListener(Events.TOUCH_TAP, touchTap);\n    element.addEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.TOUCH_START, touchStart);\n    element.removeEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.removeEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.removeEventListener(Events.TOUCH_END, touchEnd);\n    element.removeEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst touchToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default touchToolEventDispatcher;\n//# sourceMappingURL=touchToolEventDispatcher.js.map","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nfunction annotationModifiedListener(evt) {\n    const { viewportId, renderingEngineId } = evt.detail;\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\nexport default annotationModifiedListener;\n//# sourceMappingURL=annotationModifiedListener.js.map","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nfunction annotationSelectionListener(evt) {\n    const deselectedAnnotation = evt.detail.removed;\n    if (!deselectedAnnotation.length) {\n        return;\n    }\n    const renderingEngines = getRenderingEngines();\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getViewports();\n        const viewportIds = viewports.map((vp) => vp.id);\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n    });\n}\nexport default annotationSelectionListener;\n//# sourceMappingURL=annotationSelectionListener.js.map","import annotationSelectionListener from './annotationSelectionListener';\nimport annotationModifiedListener from './annotationModifiedListener';\nexport { annotationSelectionListener, annotationModifiedListener };\n//# sourceMappingURL=index.js.map","import mouseEventListeners from './mouse';\nimport touchEventListeners from './touch';\nimport wheelEventListener from './wheel';\nimport keyEventListener from './keyboard';\nimport { segmentationDataModifiedEventListener, segmentationRepresentationModifiedEventListener, segmentationRepresentationRemovedEventListener, segmentationModifiedListener, } from './segmentation';\nimport { annotationSelectionListener, annotationModifiedListener, } from './annotations';\nexport { mouseEventListeners, touchEventListeners, wheelEventListener, keyEventListener, segmentationRepresentationModifiedEventListener, segmentationModifiedListener, segmentationRepresentationRemovedEventListener, segmentationDataModifiedEventListener, annotationSelectionListener, annotationModifiedListener, };\n//# sourceMappingURL=index.js.map","import keyDownListener, { getModifierKey } from './keyDownListener';\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('keydown', keyDownListener);\n}\nfunction disable(element) {\n    element.removeEventListener('keydown', keyDownListener);\n}\nexport default {\n    enable,\n    disable,\n    getModifierKey,\n};\n//# sourceMappingURL=index.js.map","import _cloneDeep from 'lodash.clonedeep';\nimport { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nconst defaultState = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    key: undefined,\n    keyCode: undefined,\n    element: null,\n};\nlet state = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    key: undefined,\n    keyCode: undefined,\n    element: null,\n};\nfunction keyListener(evt) {\n    state.element = evt.currentTarget;\n    const enabledElement = getEnabledElement(state.element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    state.renderingEngineId = renderingEngineId;\n    state.viewportId = viewportId;\n    state.key = evt.key;\n    state.keyCode = evt.keyCode;\n    evt.preventDefault();\n    const eventDetail = {\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        element: state.element,\n        key: state.key,\n        keyCode: state.keyCode,\n    };\n    triggerEvent(eventDetail.element, Events.KEY_DOWN, eventDetail);\n    document.addEventListener('keyup', _onKeyUp);\n    state.element.removeEventListener('keydown', keyListener);\n}\nfunction _onKeyUp(evt) {\n    const eventDetail = {\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        element: state.element,\n        key: state.key,\n        keyCode: state.keyCode,\n    };\n    document.removeEventListener('keyup', _onKeyUp);\n    state.element.addEventListener('keydown', keyListener);\n    state = _cloneDeep(defaultState);\n    triggerEvent(eventDetail.element, Events.KEY_UP, eventDetail);\n}\nexport function getModifierKey() {\n    return state.keyCode;\n}\nexport function resetModifierKey() {\n    state.keyCode = undefined;\n}\nexport default keyListener;\n//# sourceMappingURL=keyDownListener.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nexport default function getMouseEventPoints(evt, element) {\n    const elementToUse = element || evt.currentTarget;\n    const { viewport } = getEnabledElement(elementToUse);\n    const clientPoint = _clientToPoint(evt);\n    const pagePoint = _pageToPoint(evt);\n    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return {\n        page: pagePoint,\n        client: clientPoint,\n        canvas: canvasPoint,\n        world: worldPoint,\n    };\n}\nfunction _pagePointsToCanvasPoints(element, pagePoint) {\n    const rect = element.getBoundingClientRect();\n    return [\n        pagePoint[0] - rect.left - window.pageXOffset,\n        pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n}\nfunction _pageToPoint(evt) {\n    return [evt.pageX, evt.pageY];\n}\nfunction _clientToPoint(evt) {\n    return [evt.clientX, evt.clientY];\n}\n//# sourceMappingURL=getMouseEventPoints.js.map","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, { mouseDoubleClickIgnoreListener, } from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\nfunction disable(element) {\n    element.removeEventListener('dblclick', mouseDoubleClickListener);\n    element.removeEventListener('mousedown', mouseDownListener);\n    element.removeEventListener('mousemove', mouseMoveListener);\n    element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('dblclick', mouseDoubleClickListener);\n    element.addEventListener('mousedown', mouseDownListener);\n    element.addEventListener('mousemove', mouseMoveListener);\n    element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n//# sourceMappingURL=index.js.map","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nfunction mouseDoubleClickListener(evt) {\n    const element = evt.currentTarget;\n    const { viewportId, renderingEngineId } = getEnabledElement(element);\n    const startPoints = getMouseEventPoints(evt, element);\n    const deltaPoints = {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    };\n    const eventDetail = {\n        event: evt,\n        eventName: Events.MOUSE_DOUBLE_CLICK,\n        viewportId,\n        renderingEngineId,\n        camera: {},\n        element,\n        startPoints,\n        lastPoints: startPoints,\n        currentPoints: startPoints,\n        deltaPoints,\n    };\n    const consumed = !triggerEvent(element, Events.MOUSE_DOUBLE_CLICK, eventDetail);\n    if (consumed) {\n        evt.stopImmediatePropagation();\n        evt.preventDefault();\n    }\n}\nexport default mouseDoubleClickListener;\n//# sourceMappingURL=mouseDoubleClickListener.js.map","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport mouseMoveListener from './mouseMoveListener';\nimport getMouseEventPoints from './getMouseEventPoints';\nconst { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } = Events;\nconst DOUBLE_CLICK_TOLERANCE_MS = 400;\nconst MULTI_BUTTON_TOLERANCE_MS = 150;\nconst DOUBLE_CLICK_DRAG_TOLERANCE = 3;\nconst defaultState = {\n    mouseButton: undefined,\n    element: null,\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    isClickEvent: true,\n    clickDelay: 200,\n    preventClickTimeout: null,\n    startPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n    lastPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n};\nlet state = {\n    mouseButton: undefined,\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    isClickEvent: true,\n    clickDelay: 200,\n    element: null,\n    preventClickTimeout: null,\n    startPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n    lastPoints: {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    },\n};\nconst doubleClickState = {\n    doubleClickTimeout: null,\n    mouseDownEvent: null,\n    mouseUpEvent: null,\n    ignoreDoubleClick: false,\n};\nfunction mouseDownListener(evt) {\n    if (doubleClickState.doubleClickTimeout) {\n        if (evt.buttons === doubleClickState.mouseDownEvent.buttons)\n            return;\n        doubleClickState.mouseDownEvent = evt;\n        _doStateMouseDownAndUp();\n        return;\n    }\n    doubleClickState.doubleClickTimeout = setTimeout(_doStateMouseDownAndUp, evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS);\n    doubleClickState.mouseDownEvent = evt;\n    doubleClickState.ignoreDoubleClick = false;\n    state.element = evt.currentTarget;\n    state.mouseButton = evt.buttons;\n    const enabledElement = getEnabledElement(state.element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    state.renderingEngineId = renderingEngineId;\n    state.viewportId = viewportId;\n    state.preventClickTimeout = setTimeout(_preventClickHandler, state.clickDelay);\n    state.element.removeEventListener('mousemove', mouseMoveListener);\n    const startPoints = getMouseEventPoints(evt, state.element);\n    state.startPoints = _copyPoints(startPoints);\n    state.lastPoints = _copyPoints(startPoints);\n    document.addEventListener('mouseup', _onMouseUp);\n    document.addEventListener('mousemove', _onMouseDrag);\n}\nfunction _doMouseDown(evt) {\n    const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);\n    const eventDetail = {\n        event: evt,\n        eventName: MOUSE_DOWN,\n        element: state.element,\n        mouseButton: state.mouseButton,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        startPoints: state.startPoints,\n        lastPoints: state.startPoints,\n        currentPoints: state.startPoints,\n        deltaPoints,\n    };\n    state.lastPoints = _copyPoints(eventDetail.lastPoints);\n    const notConsumed = triggerEvent(eventDetail.element, MOUSE_DOWN, eventDetail);\n    if (notConsumed) {\n        triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);\n    }\n}\nfunction _onMouseDrag(evt) {\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const lastPoints = _updateMouseEventsLastPoints(state.element, state.lastPoints);\n    const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n    if (doubleClickState.doubleClickTimeout) {\n        if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n            _doStateMouseDownAndUp();\n        }\n        else {\n            return;\n        }\n    }\n    const eventDetail = {\n        event: evt,\n        eventName: MOUSE_DRAG,\n        mouseButton: state.mouseButton,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        startPoints: _copyPoints(state.startPoints),\n        lastPoints: _copyPoints(lastPoints),\n        currentPoints,\n        deltaPoints,\n    };\n    triggerEvent(state.element, MOUSE_DRAG, eventDetail);\n    state.lastPoints = _copyPoints(currentPoints);\n}\nfunction _onMouseUp(evt) {\n    clearTimeout(state.preventClickTimeout);\n    if (doubleClickState.doubleClickTimeout) {\n        if (!doubleClickState.mouseUpEvent) {\n            doubleClickState.mouseUpEvent = evt;\n            state.element.addEventListener('mousemove', _onMouseMove);\n        }\n        else {\n            _cleanUp();\n        }\n    }\n    else {\n        const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;\n        const currentPoints = getMouseEventPoints(evt, state.element);\n        const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);\n        const eventDetail = {\n            event: evt,\n            eventName,\n            mouseButton: state.mouseButton,\n            element: state.element,\n            renderingEngineId: state.renderingEngineId,\n            viewportId: state.viewportId,\n            camera: {},\n            startPoints: _copyPoints(state.startPoints),\n            lastPoints: _copyPoints(state.lastPoints),\n            currentPoints,\n            deltaPoints,\n        };\n        triggerEvent(eventDetail.element, eventName, eventDetail);\n        _cleanUp();\n    }\n    document.removeEventListener('mousemove', _onMouseDrag);\n}\nfunction _onMouseMove(evt) {\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const lastPoints = _updateMouseEventsLastPoints(state.element, state.lastPoints);\n    const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n    if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n        return;\n    }\n    _doStateMouseDownAndUp();\n    mouseMoveListener(evt);\n}\nfunction _isDragPastDoubleClickTolerance(delta) {\n    return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;\n}\nfunction _preventClickHandler() {\n    state.isClickEvent = false;\n}\nfunction _doStateMouseDownAndUp() {\n    doubleClickState.ignoreDoubleClick = true;\n    const mouseDownEvent = doubleClickState.mouseDownEvent;\n    const mouseUpEvent = doubleClickState.mouseUpEvent;\n    _clearDoubleClickTimeoutAndEvents();\n    _doMouseDown(mouseDownEvent);\n    if (mouseUpEvent) {\n        _onMouseUp(mouseUpEvent);\n    }\n}\nfunction _clearDoubleClickTimeoutAndEvents() {\n    if (doubleClickState.doubleClickTimeout) {\n        clearTimeout(doubleClickState.doubleClickTimeout);\n        doubleClickState.doubleClickTimeout = null;\n    }\n    doubleClickState.mouseDownEvent = null;\n    doubleClickState.mouseUpEvent = null;\n}\nfunction _cleanUp() {\n    document.removeEventListener('mouseup', _onMouseUp);\n    state.element?.removeEventListener('mousemove', _onMouseMove);\n    state.element?.addEventListener('mousemove', mouseMoveListener);\n    _clearDoubleClickTimeoutAndEvents();\n    state = JSON.parse(JSON.stringify(defaultState));\n}\nfunction _copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction _updateMouseEventsLastPoints(element, lastPoints) {\n    const { viewport } = getEnabledElement(element);\n    const world = viewport.canvasToWorld(lastPoints.canvas);\n    return {\n        page: lastPoints.page,\n        client: lastPoints.client,\n        canvas: lastPoints.canvas,\n        world,\n    };\n}\nfunction _getDeltaPoints(currentPoints, lastPoints) {\n    return {\n        page: _subtractPoints2D(currentPoints.page, lastPoints.page),\n        client: _subtractPoints2D(currentPoints.client, lastPoints.client),\n        canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),\n        world: _subtractPoints3D(currentPoints.world, lastPoints.world),\n    };\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nexport function getMouseButton() {\n    return state.mouseButton;\n}\nexport function mouseDoubleClickIgnoreListener(evt) {\n    if (doubleClickState.ignoreDoubleClick) {\n        doubleClickState.ignoreDoubleClick = false;\n        evt.stopImmediatePropagation();\n        evt.preventDefault();\n    }\n    else {\n        _cleanUp();\n    }\n}\nexport default mouseDownListener;\n//# sourceMappingURL=mouseDownListener.js.map","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nconst eventName = Events.MOUSE_MOVE;\nfunction mouseMoveListener(evt) {\n    const element = evt.currentTarget;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    const currentPoints = getMouseEventPoints(evt);\n    const eventDetail = {\n        renderingEngineId,\n        viewportId,\n        camera: {},\n        element,\n        currentPoints,\n        eventName,\n        event: evt,\n    };\n    triggerEvent(element, eventName, eventDetail);\n}\nexport default mouseMoveListener;\n//# sourceMappingURL=mouseMoveListener.js.map","import segmentationRepresentationModifiedEventListener from './segmentationRepresentationModifiedEventListener';\nimport segmentationDataModifiedEventListener from './segmentationDataModifiedEventListener';\nimport segmentationRepresentationRemovedEventListener from './segmentationRepresentationRemovedEventListener';\nimport segmentationModifiedListener from './segmentationModifiedEventListener';\nexport { segmentationRepresentationModifiedEventListener, segmentationDataModifiedEventListener, segmentationRepresentationRemovedEventListener, segmentationModifiedListener, };\n//# sourceMappingURL=index.js.map","import { cache } from '@cornerstonejs/core';\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nconst onSegmentationDataModified = function (evt) {\n    const { segmentationId, modifiedSlicesToUse } = evt.detail;\n    const { representationData, type } = SegmentationState.getSegmentation(segmentationId);\n    let toolGroupIds;\n    if (type === SegmentationRepresentations.Labelmap) {\n        const segmentationVolume = cache.getVolume(representationData[type].volumeId);\n        if (!segmentationVolume) {\n            console.warn('segmentation not found in cache');\n            return;\n        }\n        const { imageData, vtkOpenGLTexture } = segmentationVolume;\n        let slicesToUpdate;\n        if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n            slicesToUpdate = modifiedSlicesToUse;\n        }\n        else {\n            const numSlices = imageData.getDimensions()[2];\n            slicesToUpdate = [...Array(numSlices).keys()];\n        }\n        slicesToUpdate.forEach((i) => {\n            vtkOpenGLTexture.setUpdatedFrame(i);\n        });\n        imageData.modified();\n        toolGroupIds =\n            SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n    }\n    else {\n        throw new Error(`onSegmentationDataModified: representationType ${type} not supported yet`);\n    }\n    toolGroupIds.forEach((toolGroupId) => {\n        triggerSegmentationRender(toolGroupId);\n    });\n};\nexport default onSegmentationDataModified;\n//# sourceMappingURL=segmentationDataModifiedEventListener.js.map","import { getToolGroupIdsWithSegmentation, getSegmentationRepresentations, } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nconst segmentationModifiedListener = function (evt) {\n    const { segmentationId } = evt.detail;\n    const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n    toolGroupIds.forEach((toolGroupId) => {\n        const segRepresentations = getSegmentationRepresentations(toolGroupId);\n        segRepresentations.forEach((representation) => {\n            if (representation.segmentationId === segmentationId) {\n                triggerSegmentationRepresentationModified(toolGroupId, representation.segmentationRepresentationUID);\n            }\n        });\n    });\n};\nexport default segmentationModifiedListener;\n//# sourceMappingURL=segmentationModifiedEventListener.js.map","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nconst segmentationRepresentationModifiedListener = function (evt) {\n    const { toolGroupId } = evt.detail;\n    triggerSegmentationRender(toolGroupId);\n};\nexport default segmentationRepresentationModifiedListener;\n//# sourceMappingURL=segmentationRepresentationModifiedEventListener.js.map","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nconst segmentationRepresentationRemovedEventListener = function (evt) {\n    const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n    triggerSegmentationRender(toolGroupId);\n};\nexport default segmentationRepresentationRemovedEventListener;\n//# sourceMappingURL=segmentationRepresentationRemovedEventListener.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nexport default function getTouchEventPoints(evt, element) {\n    const elementToUse = element || evt.currentTarget;\n    const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;\n    return Object.keys(touches).map((i) => {\n        const clientPoint = _clientToPoint(touches[i]);\n        const pagePoint = _pageToPoint(touches[i]);\n        const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n        const { viewport } = getEnabledElement(elementToUse);\n        const worldPoint = viewport.canvasToWorld(canvasPoint);\n        return {\n            page: pagePoint,\n            client: clientPoint,\n            canvas: canvasPoint,\n            world: worldPoint,\n            touch: {\n                identifier: i,\n                radiusX: touches[i].radiusX,\n                radiusY: touches[i].radiusY,\n                force: touches[i].force,\n                rotationAngle: touches[i].rotationAngle,\n            },\n        };\n    });\n}\nfunction _pagePointsToCanvasPoints(element, pagePoint) {\n    const rect = element.getBoundingClientRect();\n    return [\n        pagePoint[0] - rect.left - window.pageXOffset,\n        pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n}\nfunction _pageToPoint(touch) {\n    return [touch.pageX, touch.pageY];\n}\nfunction _clientToPoint(touch) {\n    return [touch.clientX, touch.clientY];\n}\n//# sourceMappingURL=getTouchEventPoints.js.map","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\nfunction disable(element) {\n    preventGhostClick.disable(element);\n    element.removeEventListener('touchstart', touchStartListener);\n}\nfunction enable(element) {\n    disable(element);\n    preventGhostClick.enable(element);\n    element.addEventListener('touchstart', touchStartListener, {\n        passive: false,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n//# sourceMappingURL=index.js.map","const antiGhostDelay = 2000, pointerType = {\n    mouse: 0,\n    touch: 1,\n};\nlet lastInteractionType, lastInteractionTime;\nfunction handleTap(type, e) {\n    const now = Date.now();\n    if (type !== lastInteractionType) {\n        if (now - lastInteractionTime <= antiGhostDelay) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n            return false;\n        }\n        lastInteractionType = type;\n    }\n    lastInteractionTime = now;\n}\nconst handleTapMouse = handleTap.bind(null, pointerType.mouse);\nconst handleTapTouch = handleTap.bind(null, pointerType.touch);\nfunction attachEvents(element, eventList, interactionType) {\n    const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n    eventList.forEach(function (eventName) {\n        element.addEventListener(eventName, tapHandler, { passive: false });\n    });\n}\nfunction removeEvents(element, eventList, interactionType) {\n    const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n    eventList.forEach(function (eventName) {\n        element.removeEventListener(eventName, tapHandler);\n    });\n}\nconst mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\nconst touchEvents = ['touchstart', 'touchend'];\nfunction disable(element) {\n    removeEvents(element, mouseEvents, pointerType.mouse);\n    removeEvents(element, touchEvents, pointerType.touch);\n}\nfunction enable(element) {\n    disable(element);\n    attachEvents(element, mouseEvents, pointerType.mouse);\n    attachEvents(element, touchEvents, pointerType.touch);\n}\nexport default {\n    enable,\n    disable,\n};\n//# sourceMappingURL=preventGhostClick.js.map","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { Swipe } from '../../enums/Touch';\nimport getTouchEventPoints from './getTouchEventPoints';\nimport { copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaDistance, getDeltaPoints, getMeanTouchPoints, } from '../../utilities/touch';\nimport { Settings } from '@cornerstonejs/core';\nconst runtimeSettings = Settings.getRuntimeSettings();\nconst { TOUCH_START, TOUCH_START_ACTIVATE, TOUCH_PRESS, TOUCH_DRAG, TOUCH_END, TOUCH_TAP, TOUCH_SWIPE, } = Events;\nconst zeroIPoint = {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n};\nconst zeroIDistance = {\n    page: 0,\n    client: 0,\n    canvas: 0,\n    world: 0,\n};\nconst defaultState = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    element: null,\n    startPointsList: [\n        {\n            ...zeroIPoint,\n            touch: null,\n        },\n    ],\n    lastPointsList: [\n        {\n            ...zeroIPoint,\n            touch: null,\n        },\n    ],\n    isTouchStart: false,\n    startTime: null,\n    pressTimeout: null,\n    pressDelay: 700,\n    pressMaxDistance: 5,\n    accumulatedDistance: zeroIDistance,\n    swipeDistanceThreshold: 48,\n    swiped: false,\n    swipeToleranceMs: 300,\n};\nconst defaultTapState = {\n    renderingEngineId: undefined,\n    viewportId: undefined,\n    element: null,\n    startPointsList: [\n        {\n            ...zeroIPoint,\n            touch: null,\n        },\n    ],\n    taps: 0,\n    tapTimeout: null,\n    tapMaxDistance: 24,\n    tapToleranceMs: 300,\n};\nlet state = JSON.parse(JSON.stringify(defaultState));\nlet tapState = JSON.parse(JSON.stringify(defaultTapState));\nfunction triggerEventCallback(ele, name, eventDetail) {\n    if (runtimeSettings.get('debug')) {\n        if (name === 'CORNERSTONE_TOOLS_TOUCH_DRAG') {\n            console.debug(name);\n        }\n        else {\n            console.debug(name, eventDetail);\n        }\n    }\n    return triggerEvent(ele, name, eventDetail);\n}\nfunction touchStartListener(evt) {\n    state.element = evt.currentTarget;\n    const enabledElement = getEnabledElement(state.element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    state.renderingEngineId = renderingEngineId;\n    state.viewportId = viewportId;\n    if (state.isTouchStart)\n        return;\n    clearTimeout(state.pressTimeout);\n    state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);\n    _onTouchStart(evt);\n    document.addEventListener('touchmove', _onTouchDrag);\n    document.addEventListener('touchend', _onTouchEnd);\n}\nfunction _onTouchPress(evt) {\n    const totalDistance = state.accumulatedDistance.canvas;\n    if (totalDistance > state.pressMaxDistance)\n        return;\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_PRESS,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        startPointsList: copyPointsList(state.startPointsList),\n        lastPointsList: copyPointsList(state.lastPointsList),\n        startPoints: copyPoints(getMeanTouchPoints(state.startPointsList)),\n        lastPoints: copyPoints(getMeanTouchPoints(state.lastPointsList)),\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);\n}\nfunction _onTouchStart(evt) {\n    state.isTouchStart = true;\n    state.startTime = new Date();\n    const startPointsList = getTouchEventPoints(evt, state.element);\n    const startPoints = getMeanTouchPoints(startPointsList);\n    const deltaPoints = zeroIPoint;\n    const deltaDistance = zeroIDistance;\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_START,\n        element: state.element,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        startPointsList: startPointsList,\n        lastPointsList: startPointsList,\n        currentPointsList: startPointsList,\n        startPoints: startPoints,\n        lastPoints: startPoints,\n        currentPoints: startPoints,\n        deltaPoints,\n        deltaDistance,\n    };\n    state.startPointsList = copyPointsList(eventDetail.startPointsList);\n    state.lastPointsList = copyPointsList(eventDetail.lastPointsList);\n    const eventDidPropagate = triggerEventCallback(eventDetail.element, TOUCH_START, eventDetail);\n    if (eventDidPropagate) {\n        triggerEventCallback(eventDetail.element, TOUCH_START_ACTIVATE, eventDetail);\n    }\n}\nfunction _onTouchDrag(evt) {\n    const currentPointsList = getTouchEventPoints(evt, state.element);\n    const lastPointsList = _updateTouchEventsLastPoints(state.element, state.lastPointsList);\n    const deltaPoints = currentPointsList.length === lastPointsList.length\n        ? getDeltaPoints(currentPointsList, lastPointsList)\n        : zeroIPoint;\n    const deltaDistance = currentPointsList.length === lastPointsList.length\n        ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n        : zeroIDistance;\n    const totalDistance = currentPointsList.length === lastPointsList.length\n        ? getDeltaDistance(currentPointsList, state.lastPointsList)\n        : zeroIDistance;\n    state.accumulatedDistance = {\n        page: state.accumulatedDistance.page + totalDistance.page,\n        client: state.accumulatedDistance.client + totalDistance.client,\n        canvas: state.accumulatedDistance.canvas + totalDistance.canvas,\n        world: state.accumulatedDistance.world + totalDistance.world,\n    };\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_DRAG,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        startPoints: getMeanTouchPoints(state.startPointsList),\n        lastPoints: getMeanTouchPoints(lastPointsList),\n        currentPoints: getMeanTouchPoints(currentPointsList),\n        startPointsList: copyPointsList(state.startPointsList),\n        lastPointsList: copyPointsList(lastPointsList),\n        currentPointsList,\n        deltaPoints: deltaPoints,\n        deltaDistance: deltaDistance,\n    };\n    triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);\n    _checkTouchSwipe(evt, deltaPoints);\n    state.lastPointsList = copyPointsList(currentPointsList);\n}\nfunction _onTouchEnd(evt) {\n    clearTimeout(state.pressTimeout);\n    const currentPointsList = getTouchEventPoints(evt, state.element);\n    const lastPointsList = _updateTouchEventsLastPoints(state.element, state.lastPointsList);\n    const deltaPoints = currentPointsList.length === lastPointsList.length\n        ? getDeltaPoints(currentPointsList, lastPointsList)\n        : getDeltaPoints(currentPointsList, currentPointsList);\n    const deltaDistance = currentPointsList.length === lastPointsList.length\n        ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n        : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_END,\n        element: state.element,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        startPointsList: copyPointsList(state.startPointsList),\n        lastPointsList: copyPointsList(lastPointsList),\n        currentPointsList,\n        startPoints: getMeanTouchPoints(state.startPointsList),\n        lastPoints: getMeanTouchPoints(lastPointsList),\n        currentPoints: getMeanTouchPoints(currentPointsList),\n        deltaPoints,\n        deltaDistance,\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);\n    _checkTouchTap(evt);\n    state = JSON.parse(JSON.stringify(defaultState));\n    document.removeEventListener('touchmove', _onTouchDrag);\n    document.removeEventListener('touchend', _onTouchEnd);\n}\nfunction _checkTouchTap(evt) {\n    const currentTime = new Date().getTime();\n    const startTime = state.startTime.getTime();\n    if (currentTime - startTime > tapState.tapToleranceMs)\n        return;\n    if (tapState.taps === 0) {\n        tapState.element = state.element;\n        tapState.renderingEngineId = state.renderingEngineId;\n        tapState.viewportId = state.viewportId;\n        tapState.startPointsList = state.startPointsList;\n    }\n    if (tapState.taps > 0 &&\n        !(tapState.element == state.element &&\n            tapState.renderingEngineId == state.renderingEngineId &&\n            tapState.viewportId == state.viewportId)) {\n        return;\n    }\n    const currentPointsList = getTouchEventPoints(evt, tapState.element);\n    const distanceFromStart = getDeltaDistance(currentPointsList, tapState.startPointsList).canvas;\n    if (distanceFromStart > tapState.tapMaxDistance)\n        return;\n    clearTimeout(tapState.tapTimeout);\n    tapState.taps += 1;\n    tapState.tapTimeout = setTimeout(() => {\n        const eventDetail = {\n            event: evt,\n            eventName: TOUCH_TAP,\n            element: tapState.element,\n            renderingEngineId: tapState.renderingEngineId,\n            viewportId: tapState.viewportId,\n            camera: {},\n            currentPointsList,\n            currentPoints: getMeanTouchPoints(currentPointsList),\n            taps: tapState.taps,\n        };\n        triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);\n        tapState = JSON.parse(JSON.stringify(defaultTapState));\n    }, tapState.tapToleranceMs);\n}\nfunction _checkTouchSwipe(evt, deltaPoints) {\n    const currentTime = new Date().getTime();\n    const startTime = state.startTime.getTime();\n    if (state.swiped || currentTime - startTime > state.swipeToleranceMs)\n        return;\n    const [x, y] = deltaPoints.canvas;\n    const eventDetail = {\n        event: evt,\n        eventName: TOUCH_SWIPE,\n        renderingEngineId: state.renderingEngineId,\n        viewportId: state.viewportId,\n        camera: {},\n        element: state.element,\n        swipe: null,\n    };\n    if (Math.abs(x) > state.swipeDistanceThreshold) {\n        eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;\n        triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n        state.swiped = true;\n    }\n    if (Math.abs(y) > state.swipeDistanceThreshold) {\n        eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;\n        triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n        state.swiped = true;\n    }\n}\nfunction _updateTouchEventsLastPoints(element, lastPoints) {\n    const { viewport } = getEnabledElement(element);\n    return lastPoints.map((lp) => {\n        const world = viewport.canvasToWorld(lp.canvas);\n        return {\n            page: lp.page,\n            client: lp.client,\n            canvas: lp.canvas,\n            world,\n            touch: lp.touch,\n        };\n    });\n}\nexport default touchStartListener;\n//# sourceMappingURL=touchStartListener.js.map","import wheelListener from './wheelListener';\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('wheel', wheelListener, { passive: false });\n}\nfunction disable(element) {\n    element.removeEventListener('wheel', wheelListener);\n}\nexport default {\n    enable,\n    disable,\n};\n//# sourceMappingURL=index.js.map","const PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nexport default function normalizeWheel(event) {\n    let spinX = 0, spinY = 0, pixelX = 0, pixelY = 0;\n    if ('detail' in event) {\n        spinY = event.detail;\n    }\n    if ('wheelDelta' in event) {\n        spinY = -event.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in event) {\n        spinY = -event.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in event) {\n        spinX = -event.wheelDeltaX / 120;\n    }\n    pixelX = spinX * PIXEL_STEP;\n    pixelY = spinY * PIXEL_STEP;\n    if ('deltaY' in event) {\n        pixelY = event.deltaY;\n    }\n    if ('deltaX' in event) {\n        pixelX = event.deltaX;\n    }\n    if ((pixelX || pixelY) && event.deltaMode) {\n        if (event.deltaMode === 1) {\n            pixelX *= LINE_HEIGHT;\n            pixelY *= LINE_HEIGHT;\n        }\n        else {\n            pixelX *= PAGE_HEIGHT;\n            pixelY *= PAGE_HEIGHT;\n        }\n    }\n    if (pixelX && !spinX) {\n        spinX = pixelX < 1 ? -1 : 1;\n    }\n    if (pixelY && !spinY) {\n        spinY = pixelY < 1 ? -1 : 1;\n    }\n    return {\n        spinX,\n        spinY,\n        pixelX,\n        pixelY,\n    };\n}\n//# sourceMappingURL=normalizeWheel.js.map","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport normalizeWheel from './normalizeWheel';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from '../mouse/getMouseEventPoints';\nfunction wheelListener(evt) {\n    const element = evt.currentTarget;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    if (evt.deltaY > -1 && evt.deltaY < 1) {\n        return;\n    }\n    evt.preventDefault();\n    const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);\n    const direction = spinY < 0 ? -1 : 1;\n    const eventDetail = {\n        event: evt,\n        eventName: Events.MOUSE_WHEEL,\n        renderingEngineId,\n        viewportId,\n        element,\n        camera: {},\n        detail: evt,\n        wheel: {\n            spinX,\n            spinY,\n            pixelX,\n            pixelY,\n            direction,\n        },\n        points: getMouseEventPoints(evt),\n    };\n    triggerEvent(element, Events.MOUSE_WHEEL, eventDetail);\n}\nexport default wheelListener;\n//# sourceMappingURL=wheelListener.js.map","import { init, destroy } from './init';\nimport { addTool, removeTool, state, ToolGroupManager, SynchronizerManager, Synchronizer, cancelActiveManipulations, } from './store';\nimport * as CONSTANTS from './constants';\nimport * as synchronizers from './synchronizers';\nimport * as drawing from './drawingSvg';\nimport * as utilities from './utilities';\nimport * as cursors from './cursors';\nimport * as Types from './types';\nimport * as annotation from './stateManagement/annotation';\nimport * as segmentation from './stateManagement/segmentation';\nimport { BaseTool, AnnotationTool, PanTool, TrackballRotateTool, DragProbeTool, WindowLevelTool, ZoomTool, StackScrollTool, PlanarRotateTool, StackScrollMouseWheelTool, VolumeRotateMouseWheelTool, MIPJumpToClickTool, LengthTool, ProbeTool, RectangleROITool, EllipticalROITool, CircleROITool, BidirectionalTool, PlanarFreehandROITool, ArrowAnnotateTool, CrosshairsTool, ReferenceLinesTool, RectangleScissorsTool, CircleScissorsTool, SphereScissorsTool, RectangleROIThresholdTool, RectangleROIStartEndThresholdTool, SegmentationDisplayTool, BrushTool, AngleTool, CobbAngleTool, MagnifyTool, ReferenceCursors, ReferenceLines, PaintFillTool, ScaleOverlayTool, } from './tools';\nimport * as Enums from './enums';\nexport { init, destroy, addTool, removeTool, cancelActiveManipulations, BaseTool, AnnotationTool, PanTool, TrackballRotateTool, DragProbeTool, WindowLevelTool, ZoomTool, StackScrollTool, PlanarRotateTool, StackScrollMouseWheelTool, VolumeRotateMouseWheelTool, MIPJumpToClickTool, LengthTool, CrosshairsTool, ReferenceLinesTool, ProbeTool, RectangleROITool, EllipticalROITool, CircleROITool, BidirectionalTool, PlanarFreehandROITool, ArrowAnnotateTool, AngleTool, CobbAngleTool, MagnifyTool, ReferenceCursors, ReferenceLines, ScaleOverlayTool, SegmentationDisplayTool, RectangleScissorsTool, CircleScissorsTool, SphereScissorsTool, RectangleROIThresholdTool, RectangleROIStartEndThresholdTool, BrushTool, synchronizers, Synchronizer, SynchronizerManager, PaintFillTool, Types, state, ToolGroupManager, Enums, CONSTANTS, drawing, annotation, segmentation, utilities, cursors, };\n//# sourceMappingURL=index.js.map","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport { annotationSelectionListener, segmentationDataModifiedEventListener, segmentationRepresentationModifiedEventListener, segmentationRepresentationRemovedEventListener, segmentationModifiedListener, annotationModifiedListener, } from './eventListeners';\nimport * as ToolGroupManager from './store/ToolGroupManager';\nlet csToolsInitialized = false;\nexport function init(defaultConfiguration = {}) {\n    if (csToolsInitialized) {\n        return;\n    }\n    _addCornerstoneEventListeners();\n    _addCornerstoneToolsEventListeners();\n    csToolsInitialized = true;\n}\nexport function destroy() {\n    _removeCornerstoneEventListeners();\n    _removeCornerstoneToolsEventListeners();\n    ToolGroupManager.destroy();\n    resetCornerstoneToolsState();\n    const annotationManager = getAnnotationManager();\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    annotationManager.restoreAnnotations({});\n    segmentationStateManager.resetState();\n    csToolsInitialized = false;\n}\nfunction _addCornerstoneEventListeners() {\n    _removeCornerstoneEventListeners();\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n}\nfunction _removeCornerstoneEventListeners() {\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n}\nfunction _addCornerstoneToolsEventListeners() {\n    _removeCornerstoneToolsEventListeners();\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedEventListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED, segmentationRepresentationRemovedEventListener);\n}\nfunction _removeCornerstoneToolsEventListeners() {\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedEventListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED, segmentationRepresentationRemovedEventListener);\n}\nexport default init;\n//# sourceMappingURL=init.js.map","import cloneDeep from 'lodash.clonedeep';\nimport { Enums, eventTarget, getEnabledElement, utilities, } from '@cornerstonejs/core';\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\nclass FrameOfReferenceSpecificAnnotationManager {\n    constructor(uid) {\n        this.getGroupKey = (annotationGroupSelector) => {\n            if (typeof annotationGroupSelector === 'string') {\n                return annotationGroupSelector;\n            }\n            const element = annotationGroupSelector;\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');\n            }\n            return enabledElement.FrameOfReferenceUID;\n        };\n        this._imageVolumeModifiedHandler = (evt) => {\n            const eventDetail = evt.detail;\n            const { FrameOfReferenceUID } = eventDetail;\n            const annotations = this.annotations;\n            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];\n            if (!frameOfReferenceSpecificAnnotations) {\n                return;\n            }\n            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                toolSpecificAnnotations.forEach((annotation) => {\n                    const invalidated = annotation.invalidated;\n                    if (invalidated !== undefined) {\n                        annotation.invalidated = true;\n                    }\n                });\n            });\n        };\n        this.getFramesOfReference = () => {\n            return Object.keys(this.annotations);\n        };\n        this.getAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (!annotations[groupKey]) {\n                return [];\n            }\n            if (toolName) {\n                return annotations[groupKey][toolName];\n            }\n            return annotations[groupKey];\n        };\n        this.getAnnotation = (annotationUID) => {\n            const annotations = this.annotations;\n            for (const frameOfReferenceUID in annotations) {\n                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n                for (const toolName in frameOfReferenceAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n                    for (const annotation of toolSpecificAnnotations) {\n                        if (annotationUID === annotation.annotationUID) {\n                            return annotation;\n                        }\n                    }\n                }\n            }\n        };\n        this.getNumberOfAnnotations = (groupKey, toolName) => {\n            const annotations = this.getAnnotations(groupKey, toolName);\n            if (!annotations.length) {\n                return 0;\n            }\n            if (toolName) {\n                return annotations.length;\n            }\n            let total = 0;\n            for (const toolName in annotations) {\n                total += annotations[toolName].length;\n            }\n            return total;\n        };\n        this.addAnnotation = (annotation, groupKey) => {\n            const { metadata } = annotation;\n            const { FrameOfReferenceUID, toolName } = metadata;\n            groupKey = groupKey || FrameOfReferenceUID;\n            const annotations = this.annotations;\n            let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            if (!frameOfReferenceSpecificAnnotations) {\n                annotations[groupKey] = {};\n                frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            }\n            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            if (!toolSpecificAnnotations) {\n                frameOfReferenceSpecificAnnotations[toolName] = [];\n                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            }\n            toolSpecificAnnotations.push(annotation);\n            checkAndDefineIsLockedProperty(annotation);\n            checkAndDefineIsVisibleProperty(annotation);\n        };\n        this.removeAnnotation = (annotationUID) => {\n            const { annotations } = this;\n            for (const groupKey in annotations) {\n                const groupAnnotations = annotations[groupKey];\n                for (const toolName in groupAnnotations) {\n                    const toolAnnotations = groupAnnotations[toolName];\n                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);\n                    if (index !== -1) {\n                        toolAnnotations.splice(index, 1);\n                        if (toolAnnotations.length === 0) {\n                            delete groupAnnotations[toolName];\n                        }\n                    }\n                }\n                if (Object.keys(groupAnnotations).length === 0) {\n                    delete annotations[groupKey];\n                }\n            }\n        };\n        this.removeAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (annotations[groupKey]) {\n                if (toolName) {\n                    delete annotations[groupKey][toolName];\n                }\n                else {\n                    delete annotations[groupKey];\n                }\n            }\n        };\n        this.saveAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    return;\n                }\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                return cloneDeep(toolSpecificAnnotations);\n            }\n            else if (groupKey) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                return cloneDeep(frameOfReferenceSpecificAnnotations);\n            }\n            return cloneDeep(annotations);\n        };\n        this.restoreAnnotations = (state, groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    annotations[groupKey] = {};\n                    frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                }\n                frameOfReferenceSpecificAnnotations[toolName] = state;\n            }\n            else if (groupKey) {\n                annotations[groupKey] = state;\n            }\n            else {\n                this.annotations = cloneDeep(state);\n            }\n        };\n        this.getNumberOfAllAnnotations = () => {\n            let count = 0;\n            const annotations = this.annotations;\n            for (const groupKey in annotations) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                for (const toolName in frameOfReferenceSpecificAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                    count += toolSpecificAnnotations.length;\n                }\n            }\n            return count;\n        };\n        this.removeAllAnnotations = () => {\n            this.annotations = {};\n        };\n        if (!uid) {\n            uid = utilities.uuidv4();\n        }\n        this.annotations = {};\n        this.uid = uid;\n        eventTarget.addEventListener(Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);\n    }\n}\nconst defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n//# sourceMappingURL=FrameOfReferenceSpecificAnnotationManager.js.map","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nconst globalLockedAnnotationsSet = new Set();\nfunction setAnnotationLocked(annotation, locked = true) {\n    const detail = makeEventDetail();\n    if (annotation) {\n        if (locked) {\n            lock(annotation, globalLockedAnnotationsSet, detail);\n        }\n        else {\n            unlock(annotation, globalLockedAnnotationsSet, detail);\n        }\n    }\n    publish(detail, globalLockedAnnotationsSet);\n}\nfunction unlockAllAnnotations() {\n    const detail = makeEventDetail();\n    clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n    publish(detail, globalLockedAnnotationsSet);\n}\nfunction getAnnotationsLocked() {\n    return Array.from(globalLockedAnnotationsSet);\n}\nfunction isAnnotationLocked(annotation) {\n    return globalLockedAnnotationsSet.has(annotation);\n}\nfunction getAnnotationsLockedCount() {\n    return globalLockedAnnotationsSet.size;\n}\nfunction checkAndDefineIsLockedProperty(annotation) {\n    if (annotation) {\n        const isLocked = !!annotation.isLocked;\n        if (shouldDefineIsLockedProperty(annotation)) {\n            Object.defineProperty(annotation, 'isLocked', {\n                configurable: false,\n                enumerable: true,\n                set: setIsLocked,\n                get: getIsLocked,\n            });\n        }\n        setAnnotationLocked(annotation, isLocked);\n    }\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        locked: [],\n    });\n}\nfunction lock(annotation, lockedAnnotationsSet, detail) {\n    if (!lockedAnnotationsSet.has(annotation)) {\n        lockedAnnotationsSet.add(annotation);\n        detail.added.push(annotation);\n    }\n}\nfunction unlock(annotation, lockedAnnotationsSet, detail) {\n    if (lockedAnnotationsSet.delete(annotation)) {\n        detail.removed.push(annotation);\n    }\n}\nfunction clearLockedAnnotationsSet(lockedAnnotationsSet, detail) {\n    lockedAnnotationsSet.forEach((annotation) => {\n        unlock(annotation, lockedAnnotationsSet, detail);\n    });\n}\nfunction publish(detail, lockedAnnotationsSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n    }\n}\nfunction shouldDefineIsLockedProperty(annotation) {\n    const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n    if (descriptor) {\n        return (descriptor.configurable &&\n            (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked));\n    }\n    return Object.isExtensible(annotation);\n}\nfunction setIsLocked(locked) {\n    setAnnotationLocked(this, locked);\n}\nfunction getIsLocked() {\n    return isAnnotationLocked(this);\n}\nexport { setAnnotationLocked, getAnnotationsLocked, getAnnotationsLockedCount, unlockAllAnnotations, isAnnotationLocked, checkAndDefineIsLockedProperty, };\n//# sourceMappingURL=annotationLocking.js.map","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './annotationState';\nconst selectedAnnotationUIDs = new Set();\nfunction setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {\n    if (selected) {\n        selectAnnotation(annotationUID, preserveSelected);\n    }\n    else {\n        deselectAnnotation(annotationUID);\n    }\n}\nfunction selectAnnotation(annotationUID, preserveSelected = false) {\n    const detail = makeEventDetail();\n    if (!preserveSelected) {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n    }\n    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n        selectedAnnotationUIDs.add(annotationUID);\n        detail.added.push(annotationUID);\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction deselectAnnotation(annotationUID) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (selectedAnnotationUIDs.delete(annotationUID)) {\n            detail.removed.push(annotationUID);\n        }\n    }\n    else {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelected() {\n    return Array.from(selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelectedByToolName(toolName) {\n    return getAnnotationsSelected().filter((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        return annotation.metadata.toolName === toolName;\n    });\n}\nfunction isAnnotationSelected(annotationUID) {\n    return selectedAnnotationUIDs.has(annotationUID);\n}\nfunction getAnnotationsSelectedCount() {\n    return selectedAnnotationUIDs.size;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        selection: [],\n    });\n}\nfunction clearSelectionSet(selectionSet, detail) {\n    selectionSet.forEach((value) => {\n        if (selectionSet.delete(value)) {\n            detail.removed.push(value);\n        }\n    });\n}\nfunction publish(detail, selectionSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        selectionSet.forEach((item) => void detail.selection.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n    }\n}\nexport { setAnnotationSelected, getAnnotationsSelected, getAnnotationsSelectedByToolName, getAnnotationsSelectedCount, deselectAnnotation, isAnnotationSelected, };\n//# sourceMappingURL=annotationSelection.js.map","import { triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, } from './helpers/state';\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nfunction getAnnotationManager() {\n    return defaultManager;\n}\nfunction setAnnotationManager(annotationManager) {\n    defaultManager = annotationManager;\n}\nfunction resetAnnotationManager() {\n    defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\nfunction getAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getAnnotations(groupKey, toolName);\n}\nfunction addAnnotation(annotation, annotationGroupSelector) {\n    if (annotation.annotationUID === undefined) {\n        annotation.annotationUID = csUtils.uuidv4();\n    }\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    manager.addAnnotation(annotation, groupKey);\n    if (annotationGroupSelector instanceof HTMLDivElement) {\n        triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n    }\n    else {\n        triggerAnnotationAddedForFOR(annotation);\n    }\n    return annotation.annotationUID;\n}\nfunction getNumberOfAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getNumberOfAnnotations(groupKey, toolName);\n}\nfunction removeAnnotation(annotationUID) {\n    const manager = getAnnotationManager();\n    const annotation = manager.getAnnotation(annotationUID);\n    if (!annotation) {\n        return;\n    }\n    manager.removeAnnotation(annotationUID);\n    const eventType = Events.ANNOTATION_REMOVED;\n    const eventDetail = {\n        annotation,\n        annotationManagerUID: manager.uid,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction getAnnotation(annotationUID) {\n    const manager = getAnnotationManager();\n    const annotation = manager.getAnnotation(annotationUID);\n    return annotation;\n}\nfunction removeAllAnnotations() {\n    const manager = getAnnotationManager();\n    manager.removeAllAnnotations();\n}\nexport { getAnnotations, getNumberOfAnnotations, addAnnotation, getAnnotation, removeAnnotation, removeAllAnnotations, setAnnotationManager, getAnnotationManager, resetAnnotationManager, };\n//# sourceMappingURL=annotationState.js.map","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { isAnnotationSelected, deselectAnnotation, } from './annotationSelection';\nconst globalHiddenAnnotationUIDsSet = new Set();\nfunction setAnnotationVisibility(annotationUID, visible = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (visible) {\n            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n        else {\n            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail);\n}\nfunction showAllAnnotations() {\n    const detail = makeEventDetail();\n    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    });\n    publish(detail);\n}\nfunction isAnnotationVisible(annotationUID) {\n    const annotation = getAnnotation(annotationUID);\n    if (annotation) {\n        return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    }\n}\nfunction checkAndDefineIsVisibleProperty(annotation) {\n    if (annotation) {\n        const isVisible = annotation.isVisible ?? true;\n        if (shouldDefineIsVisibleProperty(annotation)) {\n            Object.defineProperty(annotation, 'isVisible', {\n                configurable: false,\n                enumerable: true,\n                set: setIsVisible,\n                get: getIsVisible,\n            });\n        }\n        setAnnotationVisibility(annotation.annotationUID, isVisible);\n    }\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        lastVisible: [],\n        lastHidden: [],\n        hidden: [],\n    });\n}\nfunction show(annotationUID, annotationUIDsSet, detail) {\n    if (annotationUIDsSet.delete(annotationUID)) {\n        detail.lastVisible.push(annotationUID);\n    }\n}\nfunction hide(annotationUID, annotationUIDsSet, detail) {\n    if (!annotationUIDsSet.has(annotationUID)) {\n        annotationUIDsSet.add(annotationUID);\n        if (isAnnotationSelected(annotationUID)) {\n            deselectAnnotation(annotationUID);\n        }\n        detail.lastHidden.push(annotationUID);\n    }\n}\nfunction publish(detail) {\n    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n    }\n}\nfunction shouldDefineIsVisibleProperty(annotation) {\n    const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n    if (descriptor) {\n        return (descriptor.configurable &&\n            (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible));\n    }\n    return Object.isExtensible(annotation);\n}\nfunction setIsVisible(hidden) {\n    setAnnotationVisibility(this.annotationUID, hidden);\n}\nfunction getIsVisible() {\n    return isAnnotationVisible(this.annotationUID);\n}\nexport { setAnnotationVisibility, showAllAnnotations, isAnnotationVisible, checkAndDefineIsVisibleProperty, };\n//# sourceMappingURL=annotationVisibility.js.map","class ToolStyle {\n    constructor() {\n        const defaultConfig = {\n            color: 'rgb(255, 255, 0)',\n            colorHighlighted: 'rgb(0, 255, 0)',\n            colorSelected: 'rgb(0, 220, 0)',\n            colorLocked: 'rgb(255, 255, 0)',\n            lineWidth: '1',\n            lineDash: '',\n            shadow: true,\n            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            textBoxFontSize: '14px',\n            textBoxColor: 'rgb(255, 255, 0)',\n            textBoxColorHighlighted: 'rgb(0, 255, 0)',\n            textBoxColorSelected: 'rgb(0, 255, 0)',\n            textBoxColorLocked: 'rgb(255, 255, 0)',\n            textBoxBackground: '',\n            textBoxLinkLineWidth: '1',\n            textBoxLinkLineDash: '2,3',\n            textBoxShadow: true,\n        };\n        this._initializeConfig(defaultConfig);\n    }\n    getAnnotationToolStyles(annotationUID) {\n        return this.config.annotations && this.config.annotations[annotationUID];\n    }\n    getViewportToolStyles(viewportId) {\n        return this.config.viewports && this.config.viewports[viewportId];\n    }\n    getToolGroupToolStyles(toolGroupId) {\n        return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n    }\n    getDefaultToolStyles() {\n        return this.config.default;\n    }\n    setAnnotationStyles(annotationUID, styles) {\n        let annotationSpecificStyles = this.config.annotations;\n        if (!annotationSpecificStyles) {\n            this.config = {\n                ...this.config,\n                annotations: {},\n            };\n            annotationSpecificStyles = this.config.annotations;\n        }\n        annotationSpecificStyles[annotationUID] = styles;\n    }\n    setViewportToolStyles(viewportId, styles) {\n        let viewportSpecificStyles = this.config.viewports;\n        if (!viewportSpecificStyles) {\n            this.config = {\n                ...this.config,\n                viewports: {},\n            };\n            viewportSpecificStyles = this.config.viewports;\n        }\n        viewportSpecificStyles[viewportId] = styles;\n    }\n    setToolGroupToolStyles(toolGroupId, styles) {\n        let toolGroupSpecificStyles = this.config.toolGroups;\n        if (!toolGroupSpecificStyles) {\n            this.config = {\n                ...this.config,\n                toolGroups: {},\n            };\n            toolGroupSpecificStyles = this.config.toolGroups;\n        }\n        toolGroupSpecificStyles[toolGroupId] = styles;\n    }\n    setDefaultToolStyles(styles) {\n        this.config.default = styles;\n    }\n    getStyleProperty(toolStyle, specifications) {\n        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);\n    }\n    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {\n        if (annotationUID) {\n            const styles = this.getAnnotationToolStyles(annotationUID);\n            if (styles) {\n                if (styles[property]) {\n                    return styles[property];\n                }\n            }\n        }\n        if (viewportId) {\n            const styles = this.getViewportToolStyles(viewportId);\n            if (styles) {\n                if (styles[toolName] && styles[toolName][property]) {\n                    return styles[toolName][property];\n                }\n                if (styles.global && styles.global[property]) {\n                    return styles.global[property];\n                }\n            }\n        }\n        if (toolGroupId) {\n            const styles = this.getToolGroupToolStyles(toolGroupId);\n            if (styles) {\n                if (styles[toolName] && styles[toolName][property]) {\n                    return styles[toolName][property];\n                }\n                if (styles.global && styles.global[property]) {\n                    return styles.global[property];\n                }\n            }\n        }\n        const globalStyles = this.getDefaultToolStyles();\n        if (globalStyles[toolName] && globalStyles[toolName][property]) {\n            return globalStyles[toolName][property];\n        }\n        if (globalStyles.global && globalStyles.global[property]) {\n            return globalStyles.global[property];\n        }\n    }\n    _initializeConfig(config) {\n        const toolStyles = {};\n        for (const name in config) {\n            toolStyles[name] = config[name];\n        }\n        this.config = {\n            default: {\n                global: toolStyles,\n            },\n        };\n    }\n}\nconst toolStyle = new ToolStyle();\nexport default toolStyle;\n//# sourceMappingURL=ToolStyle.js.map","import { getStyleProperty } from './helpers';\nfunction getFont(styleSpecifier, state, mode) {\n    const fontSize = getStyleProperty('textBoxFontSize', styleSpecifier, state, mode);\n    const fontFamily = getStyleProperty('textBoxFontFamily', styleSpecifier, state, mode);\n    return `${fontSize}px ${fontFamily}`;\n}\nexport default getFont;\n//# sourceMappingURL=getFont.js.map","import { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\nfunction getState(annotation) {\n    if (annotation) {\n        if (annotation.data && annotation.highlighted)\n            return AnnotationStyleStates.Highlighted;\n        if (isAnnotationSelected(annotation.annotationUID))\n            return AnnotationStyleStates.Selected;\n        if (isAnnotationLocked(annotation))\n            return AnnotationStyleStates.Locked;\n    }\n    return AnnotationStyleStates.Default;\n}\nexport default getState;\n//# sourceMappingURL=getState.js.map","import toolStyle from './ToolStyle';\nfunction getHierarchalPropertyStyles(property, state, mode) {\n    const list = [`${property}`];\n    if (state)\n        list.push(`${list[0]}${state}`);\n    if (mode)\n        list.push(`${list[list.length - 1]}${mode}`);\n    return list;\n}\nfunction getStyleProperty(property, styleSpecifier, state, mode) {\n    const alternatives = getHierarchalPropertyStyles(property, state, mode);\n    for (let i = alternatives.length - 1; i >= 0; --i) {\n        const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n        if (style !== undefined) {\n            return style;\n        }\n    }\n}\nexport { getStyleProperty };\n//# sourceMappingURL=helpers.js.map","import getState from './getState';\nimport getFont from './getFont';\nimport style from './ToolStyle';\nexport { getState, getFont, style };\n//# sourceMappingURL=index.js.map","import { getEnabledElement, triggerEvent, eventTarget, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nfunction triggerAnnotationAddedForElement(annotation, element) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewportId } = enabledElement;\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId: renderingEngine.id,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationAddedForFOR(annotation) {\n    const { toolName } = annotation.metadata;\n    const toolGroups = getToolGroupsWithToolName(toolName);\n    if (!toolGroups.length) {\n        return;\n    }\n    const viewportsToRender = [];\n    toolGroups.forEach((toolGroup) => {\n        toolGroup.viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const { FrameOfReferenceUID } = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n                viewportsToRender.push(viewportInfo);\n            }\n        });\n    });\n    if (!viewportsToRender.length) {\n        return;\n    }\n    const eventType = Events.ANNOTATION_ADDED;\n    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n    });\n}\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR };\n//# sourceMappingURL=state.js.map","import * as config from './config';\nimport * as locking from './annotationLocking';\nimport * as selection from './annotationSelection';\nimport * as state from './annotationState';\nimport * as visibility from './annotationVisibility';\nimport FrameOfReferenceSpecificAnnotationManager from './FrameOfReferenceSpecificAnnotationManager';\nexport { config, locking, selection, state, visibility, FrameOfReferenceSpecificAnnotationManager, };\n//# sourceMappingURL=index.js.map","import FrameOfReferenceSpecificAnnotationManager, { defaultFrameOfReferenceSpecificAnnotationManager, } from './annotation/FrameOfReferenceSpecificAnnotationManager';\nimport * as annotationLocking from './annotation/annotationLocking';\nimport * as annotationSelection from './annotation/annotationSelection';\nimport { getAnnotations, addAnnotation, removeAnnotation, getAnnotation, getNumberOfAnnotations, setAnnotationManager, getAnnotationManager, resetAnnotationManager, } from './annotation/annotationState';\nimport { addSegmentationRepresentations, removeSegmentationsFromToolGroup, } from './segmentation';\nexport { FrameOfReferenceSpecificAnnotationManager, defaultFrameOfReferenceSpecificAnnotationManager, annotationLocking, annotationSelection, getAnnotations, addAnnotation, getNumberOfAnnotations, removeAnnotation, getAnnotation, setAnnotationManager, getAnnotationManager, resetAnnotationManager, addSegmentationRepresentations, removeSegmentationsFromToolGroup, };\n//# sourceMappingURL=index.js.map","import { utilities as csUtils } from '@cornerstonejs/core';\nimport cloneDeep from 'lodash.clonedeep';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\nconst newGlobalConfig = {\n    renderInactiveSegmentations: true,\n    representations: {\n        [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n        [SegmentationRepresentations.Contour]: defaultContourConfig,\n    },\n};\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    globalConfig: newGlobalConfig,\n    toolGroups: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        if (!uid) {\n            uid = csUtils.uuidv4();\n        }\n        this.state = cloneDeep(initialDefaultState);\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    getToolGroups() {\n        return Object.keys(this.state.toolGroups);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    resetState() {\n        this.state = cloneDeep(initialDefaultState);\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    addSegmentation(segmentation) {\n        this._initDefaultColorLUTIfNecessary();\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.state.segmentations.push(segmentation);\n    }\n    getSegmentationRepresentations(toolGroupId) {\n        const toolGroupSegRepresentationsWithConfig = this.state.toolGroups[toolGroupId];\n        if (!toolGroupSegRepresentationsWithConfig) {\n            return;\n        }\n        return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n    }\n    addSegmentationRepresentation(toolGroupId, segmentationRepresentation) {\n        if (!this.state.toolGroups[toolGroupId]) {\n            this.state.toolGroups[toolGroupId] = {\n                segmentationRepresentations: [],\n                config: {},\n            };\n        }\n        this.state.toolGroups[toolGroupId].segmentationRepresentations.push(segmentationRepresentation);\n        this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n    }\n    getGlobalConfig() {\n        return this.state.globalConfig;\n    }\n    setGlobalConfig(config) {\n        this.state.globalConfig = config;\n    }\n    getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID) {\n        const toolGroupSegRepresentations = this.getSegmentationRepresentations(toolGroupId);\n        const segmentationData = toolGroupSegRepresentations.find((representation) => representation.segmentationRepresentationUID ===\n            segmentationRepresentationUID);\n        return segmentationData;\n    }\n    removeSegmentation(segmentationId) {\n        this.state.segmentations = this.state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n    }\n    removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID) {\n        const toolGroupSegmentationRepresentations = this.getSegmentationRepresentations(toolGroupId);\n        if (!toolGroupSegmentationRepresentations ||\n            !toolGroupSegmentationRepresentations.length) {\n            throw new Error(`No viewport specific segmentation state found for viewport ${toolGroupId}`);\n        }\n        const state = toolGroupSegmentationRepresentations;\n        const index = state.findIndex((segData) => segData.segmentationRepresentationUID === segmentationRepresentationUID);\n        if (index === -1) {\n            console.warn(`No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`);\n        }\n        const removedSegmentationRepresentation = toolGroupSegmentationRepresentations[index];\n        toolGroupSegmentationRepresentations.splice(index, 1);\n        this._handleActiveSegmentation(toolGroupId, removedSegmentationRepresentation);\n    }\n    setActiveSegmentationRepresentation(toolGroupId, segmentationRepresentationUID) {\n        const toolGroupSegmentations = this.getSegmentationRepresentations(toolGroupId);\n        if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n            throw new Error(`No segmentation data found for toolGroupId: ${toolGroupId}`);\n        }\n        const segmentationData = toolGroupSegmentations.find((segmentationData) => segmentationData.segmentationRepresentationUID ===\n            segmentationRepresentationUID);\n        if (!segmentationData) {\n            throw new Error(`No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`);\n        }\n        segmentationData.active = true;\n        this._handleActiveSegmentation(toolGroupId, segmentationData);\n    }\n    getToolGroupSpecificConfig(toolGroupId) {\n        const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n        if (!toolGroupStateWithConfig) {\n            return;\n        }\n        return toolGroupStateWithConfig.config;\n    }\n    getSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID) {\n        const segmentationRepresentation = this.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n        if (!segmentationRepresentation) {\n            return;\n        }\n        return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n    }\n    setSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID, config) {\n        const segmentationRepresentation = this.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n        if (!segmentationRepresentation) {\n            return;\n        }\n        segmentationRepresentation.segmentationRepresentationSpecificConfig =\n            config;\n    }\n    getSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, segmentIndex) {\n        const segmentationRepresentation = this.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n        if (!segmentationRepresentation) {\n            return;\n        }\n        return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n    }\n    setSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, config) {\n        const segmentationRepresentation = this.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n        if (!segmentationRepresentation) {\n            return;\n        }\n        segmentationRepresentation.segmentSpecificConfig = config;\n    }\n    setSegmentationRepresentationConfig(toolGroupId, config) {\n        let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n        if (!toolGroupStateWithConfig) {\n            this.state.toolGroups[toolGroupId] = {\n                segmentationRepresentations: [],\n                config: {\n                    renderInactiveSegmentations: true,\n                    representations: {},\n                },\n            };\n            toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n        }\n        toolGroupStateWithConfig.config = {\n            ...toolGroupStateWithConfig.config,\n            ...config,\n        };\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        if (this.state.colorLUT[lutIndex]) {\n            console.log('Color LUT table already exists, overwriting');\n        }\n        this.state.colorLUT[lutIndex] = colorLUT;\n    }\n    removeColorLUT(colorLUTIndex) {\n        delete this.state.colorLUT[colorLUTIndex];\n    }\n    _handleActiveSegmentation(toolGroupId, recentlyAddedOrRemovedSegmentationRepresentation) {\n        const segmentationRepresentations = this.getSegmentationRepresentations(toolGroupId);\n        if (segmentationRepresentations.length === 0) {\n            return;\n        }\n        if (segmentationRepresentations.length === 1) {\n            segmentationRepresentations[0].active = true;\n            return;\n        }\n        const activeSegmentationRepresentations = segmentationRepresentations.filter((representation) => representation.active);\n        if (activeSegmentationRepresentations.length === 0) {\n            segmentationRepresentations[0].active = true;\n            return;\n        }\n        if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n            segmentationRepresentations.forEach((representation) => {\n                if (representation.segmentationRepresentationUID !==\n                    recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID) {\n                    representation.active = false;\n                }\n            });\n        }\n    }\n    _initDefaultColorLUTIfNecessary() {\n        if (this.state.colorLUT.length === 0 || !this.state.colorLUT[0]) {\n            this.addColorLUT(CORNERSTONE_COLOR_LUT, 0);\n        }\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n//# sourceMappingURL=SegmentationStateManager.js.map","import { getDefaultSegmentationStateManager } from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\nfunction getActiveSegmentationRepresentation(toolGroupId) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    const toolGroupSegmentationRepresentations = segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n    if (!toolGroupSegmentationRepresentations) {\n        return;\n    }\n    const activeRepresentation = toolGroupSegmentationRepresentations.find((representation) => representation.active);\n    return activeRepresentation;\n}\nfunction setActiveSegmentationRepresentation(toolGroupId, segmentationRepresentationUID) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.setActiveSegmentationRepresentation(toolGroupId, segmentationRepresentationUID);\n    triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);\n}\nexport { getActiveSegmentationRepresentation, setActiveSegmentationRepresentation, };\n//# sourceMappingURL=activeSegmentation.js.map","import Representations from '../../enums/SegmentationRepresentations';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\nasync function addSegmentationRepresentations(toolGroupId, representationInputArray, toolGroupSpecificRepresentationConfig) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (!toolGroup) {\n        throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n    }\n    const promises = representationInputArray.map((representationInput) => {\n        return _addSegmentationRepresentation(toolGroupId, representationInput, toolGroupSpecificRepresentationConfig);\n    });\n    const segmentationRepresentationUIDs = await Promise.all(promises);\n    return segmentationRepresentationUIDs;\n}\nasync function _addSegmentationRepresentation(toolGroupId, representationInput, toolGroupSpecificRepresentationConfig) {\n    let segmentationRepresentationUID;\n    if (representationInput.type === Representations.Labelmap) {\n        segmentationRepresentationUID =\n            await labelmapDisplay.addSegmentationRepresentation(toolGroupId, representationInput, toolGroupSpecificRepresentationConfig);\n    }\n    else if (representationInput.type === Representations.Contour) {\n        segmentationRepresentationUID =\n            await contourDisplay.addSegmentationRepresentation(toolGroupId, representationInput, toolGroupSpecificRepresentationConfig);\n    }\n    else {\n        throw new Error(`The representation type ${representationInput.type} is not supported`);\n    }\n    return segmentationRepresentationUID;\n}\nexport default addSegmentationRepresentations;\n//# sourceMappingURL=addSegmentationRepresentations.js.map","import _cloneDeep from 'lodash.clonedeep';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\nfunction addSegmentations(segmentationInputArray) {\n    validateSegmentationInput(segmentationInputArray);\n    segmentationInputArray.map((segInput) => {\n        const segmentationInput = _cloneDeep(segInput);\n        addSegmentationToState(segmentationInput);\n    });\n}\nexport default addSegmentations;\n//# sourceMappingURL=addSegmentations.js.map","import * as color from './segmentationColor';\nimport * as visibility from './segmentationVisibility';\nimport { getGlobalConfig, getGlobalRepresentationConfig, getToolGroupSpecificConfig, setGlobalConfig, setGlobalRepresentationConfig, setToolGroupSpecificConfig, setSegmentSpecificConfig, getSegmentSpecificConfig, setSegmentationRepresentationSpecificConfig, getSegmentationRepresentationSpecificConfig, } from './segmentationConfig';\nexport { color, visibility, getGlobalConfig, getGlobalRepresentationConfig, getToolGroupSpecificConfig, setGlobalConfig, setGlobalRepresentationConfig, setToolGroupSpecificConfig, setSegmentSpecificConfig, getSegmentSpecificConfig, setSegmentationRepresentationSpecificConfig, getSegmentationRepresentationSpecificConfig, };\n//# sourceMappingURL=index.js.map","import { utilities } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');\n        colorLUT.unshift([0, 0, 0, 0]);\n    }\n    SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(toolGroupId, segmentationRepresentationUID, colorLUTIndex) {\n    const segRepresentation = SegmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n    if (!segRepresentation) {\n        throw new Error(`setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`);\n    }\n    if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTIndex}`);\n    }\n    segRepresentation.colorLUTIndex = colorLUTIndex;\n    triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);\n}\nfunction getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex) {\n    const segmentationRepresentation = SegmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n    if (!segmentationRepresentation) {\n        throw new Error(`segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`);\n    }\n    const { colorLUTIndex } = segmentationRepresentation;\n    const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n    return colorLUT[segmentIndex];\n}\nfunction setColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex, color) {\n    const colorReference = getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);\n}\nexport { getColorForSegmentIndex, addColorLUT, setColorLUT, setColorForSegmentIndex, };\n//# sourceMappingURL=segmentationColor.js.map","import * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nfunction getGlobalConfig() {\n    return SegmentationState.getGlobalConfig();\n}\nfunction setGlobalConfig(segmentationConfig) {\n    SegmentationState.setGlobalConfig(segmentationConfig);\n}\nfunction getGlobalRepresentationConfig(representationType) {\n    const globalConfig = getGlobalConfig();\n    return globalConfig.representations[representationType];\n}\nfunction setGlobalRepresentationConfig(representationType, config) {\n    const globalConfig = getGlobalConfig();\n    setGlobalConfig({\n        ...globalConfig,\n        representations: {\n            ...globalConfig.representations,\n            [representationType]: {\n                ...globalConfig.representations[representationType],\n                ...config,\n            },\n        },\n    });\n}\nfunction getToolGroupSpecificConfig(toolGroupId) {\n    return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\nfunction setToolGroupSpecificConfig(toolGroupId, segmentationRepresentationConfig) {\n    SegmentationState.setToolGroupSpecificConfig(toolGroupId, segmentationRepresentationConfig);\n}\nfunction getSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID) {\n    return SegmentationState.getSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID);\n}\nfunction setSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID, config) {\n    SegmentationState.setSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID, config);\n}\nfunction getSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, segmentIndex) {\n    return SegmentationState.getSegmentSpecificRepresentationConfig(toolGroupId, segmentationRepresentationUID, segmentIndex);\n}\nfunction setSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, config) {\n    SegmentationState.setSegmentSpecificRepresentationConfig(toolGroupId, segmentationRepresentationUID, config);\n}\nexport { getGlobalConfig, setGlobalConfig, getGlobalRepresentationConfig, setGlobalRepresentationConfig, getToolGroupSpecificConfig, setToolGroupSpecificConfig, getSegmentationRepresentationSpecificConfig, setSegmentationRepresentationSpecificConfig, getSegmentSpecificConfig, setSegmentSpecificConfig, };\n//# sourceMappingURL=segmentationConfig.js.map","import { cache } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nfunction getSegmentationIndices(segmentationId) {\n    const segmentation = SegmentationState.getSegmentation(segmentationId);\n    if (segmentation.type === SegmentationRepresentations.Labelmap) {\n        const volume = cache.getVolume(segmentationId);\n        const scalarData = volume.getScalarData();\n        const keySet = {};\n        for (let i = 0; i < scalarData.length; i++) {\n            const segmentIndex = scalarData[i];\n            if (segmentIndex !== 0 && !keySet[segmentIndex]) {\n                keySet[segmentIndex] = true;\n            }\n        }\n        return Object.keys(keySet).map((it) => parseInt(it, 10));\n    }\n    else if (segmentation.type === SegmentationRepresentations.Contour) {\n        const geometryIds = segmentation.representationData.CONTOUR?.geometryIds;\n        if (!geometryIds) {\n            throw new Error(`No geometryIds found for segmentationId ${segmentationId}`);\n        }\n        return geometryIds.map((geometryId) => {\n            const geometry = cache.getGeometry(geometryId);\n            return geometry.data.getSegmentIndex();\n        });\n    }\n}\nfunction setSegmentationVisibility(toolGroupId, segmentationRepresentationUID, visibility) {\n    const toolGroupSegmentationRepresentations = getSegmentationRepresentations(toolGroupId);\n    if (!toolGroupSegmentationRepresentations) {\n        return;\n    }\n    const representation = toolGroupSegmentationRepresentations.find((representation) => representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID);\n    if (!representation) {\n        return;\n    }\n    const { segmentsHidden, segmentationId } = representation;\n    const indices = getSegmentationIndices(segmentationId);\n    if (visibility) {\n        segmentsHidden.clear();\n    }\n    else {\n        indices.forEach((index) => {\n            segmentsHidden.add(index);\n        });\n    }\n    triggerSegmentationRepresentationModified(toolGroupId, representation.segmentationRepresentationUID);\n}\nfunction getSegmentationVisibility(toolGroupId, segmentationRepresentationUID) {\n    const toolGroupSegmentationRepresentations = getSegmentationRepresentations(toolGroupId);\n    const representation = toolGroupSegmentationRepresentations.find((representation) => representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID);\n    if (!representation) {\n        return;\n    }\n    const { segmentsHidden } = representation;\n    return segmentsHidden.size === 0;\n}\nfunction setSegmentsVisibility(toolGroupId, segmentationRepresentationUID, segmentIndices, visibility) {\n    const segRepresentation = SegmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n    if (!segRepresentation) {\n        return;\n    }\n    segmentIndices.forEach((segmentIndex) => {\n        visibility\n            ? segRepresentation.segmentsHidden.delete(segmentIndex)\n            : segRepresentation.segmentsHidden.add(segmentIndex);\n    });\n    triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);\n}\nfunction setSegmentVisibility(toolGroupId, segmentationRepresentationUID, segmentIndex, visibility) {\n    const segRepresentation = SegmentationState.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n    if (!segRepresentation) {\n        return;\n    }\n    visibility\n        ? segRepresentation.segmentsHidden.delete(segmentIndex)\n        : segRepresentation.segmentsHidden.add(segmentIndex);\n    triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);\n}\nexport { setSegmentationVisibility, getSegmentationVisibility, setSegmentVisibility, setSegmentsVisibility, };\n//# sourceMappingURL=segmentationVisibility.js.map","import validateSegmentationInput from './validateSegmentationInput';\nexport { validateSegmentationInput };\n//# sourceMappingURL=index.js.map","function normalizeSegmentationInput(segmentationInput) {\n    const { segmentationId, representation } = segmentationInput;\n    return {\n        segmentationId,\n        cachedStats: {},\n        segmentLabels: {},\n        label: null,\n        segmentsLocked: new Set(),\n        type: representation.type,\n        activeSegmentIndex: 1,\n        representationData: {\n            [representation.type]: {\n                ...representation.data,\n            },\n        },\n    };\n}\nexport default normalizeSegmentationInput;\n//# sourceMappingURL=normalizeSegmentationInput.js.map","import * as Enums from '../../../enums';\nimport validateLabelmap from '../../../tools/displayTools/Labelmap/validateRepresentationData';\nfunction validateSegmentationInput(segmentationInputArray) {\n    if (!segmentationInputArray || !segmentationInputArray.length) {\n        throw new Error('The segmentationInputArray is undefined or empty array');\n    }\n    segmentationInputArray.forEach((segmentationInput) => {\n        if (segmentationInput.segmentationId === undefined) {\n            throw new Error('The segmentationInput.segmentationId is undefined, please provide a valid segmentationId');\n        }\n        if (segmentationInput.representation === undefined) {\n            throw new Error('The segmentationInput.representation is undefined, please provide a valid representation');\n        }\n        if (segmentationInput.representation.type ===\n            Enums.SegmentationRepresentations.Labelmap) {\n            validateLabelmap(segmentationInput);\n        }\n    });\n}\nexport default validateSegmentationInput;\n//# sourceMappingURL=validateSegmentationInput.js.map","import removeSegmentationsFromToolGroup from './removeSegmentationsFromToolGroup';\nimport addSegmentations from './addSegmentations';\nimport addSegmentationRepresentations from './addSegmentationRepresentations';\nimport * as activeSegmentation from './activeSegmentation';\nimport * as segmentLocking from './segmentLocking';\nimport * as state from './segmentationState';\nimport * as config from './config';\nimport * as segmentIndex from './segmentIndex';\nimport * as triggerSegmentationEvents from './triggerSegmentationEvents';\nexport { state, addSegmentations, activeSegmentation, addSegmentationRepresentations, removeSegmentationsFromToolGroup, segmentLocking, config, segmentIndex, triggerSegmentationEvents, };\n//# sourceMappingURL=index.js.map","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\nimport { getSegmentationRepresentations, getSegmentationRepresentationByUID, } from './segmentationState';\nfunction removeSegmentationsFromToolGroup(toolGroupId, segmentationRepresentationUIDs, immediate) {\n    const toolGroupSegRepresentations = getSegmentationRepresentations(toolGroupId);\n    if (!toolGroupSegRepresentations ||\n        toolGroupSegRepresentations.length === 0) {\n        return;\n    }\n    const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map((representation) => representation.segmentationRepresentationUID);\n    let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n    if (segRepresentationUIDsToRemove) {\n        const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter((segRepresentationUID) => !toolGroupSegRepresentationUIDs.includes(segRepresentationUID));\n        if (invalidSegRepresentationUIDs.length > 0) {\n            throw new Error(`The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(invalidSegRepresentationUIDs)}`);\n        }\n    }\n    else {\n        segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n    }\n    segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n        _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n    });\n}\nfunction _removeSegmentation(toolGroupId, segmentationRepresentationUID, immediate) {\n    const segmentationRepresentation = getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n    const { type } = segmentationRepresentation;\n    if (type === SegmentationRepresentations.Labelmap) {\n        labelmapDisplay.removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID, immediate);\n    }\n    else if (type === SegmentationRepresentations.Contour) {\n        contourDisplay.removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID, immediate);\n    }\n    else {\n        throw new Error(`The representation ${type} is not supported yet`);\n    }\n}\nexport default removeSegmentationsFromToolGroup;\n//# sourceMappingURL=removeSegmentationsFromToolGroup.js.map","import { getSegmentation } from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nfunction setActiveSegmentIndex(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation?.activeSegmentIndex !== segmentIndex) {\n        segmentation.activeSegmentIndex = segmentIndex;\n        triggerSegmentationModified(segmentationId);\n    }\n}\nfunction getActiveSegmentIndex(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation) {\n        return segmentation.activeSegmentIndex;\n    }\n}\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n//# sourceMappingURL=segmentIndex.js.map","import { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segmentsLocked } = segmentation;\n    return segmentsLocked.has(segmentIndex);\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segmentsLocked } = segmentation;\n    if (locked) {\n        segmentsLocked.add(segmentIndex);\n    }\n    else {\n        segmentsLocked.delete(segmentIndex);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegments(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segmentsLocked } = segmentation;\n    return Array.from(segmentsLocked);\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n//# sourceMappingURL=segmentLocking.js.map","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\nfunction getDefaultSegmentationStateManager() {\n    return defaultSegmentationStateManager;\n}\nfunction getSegmentation(segmentationId) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getSegmentation(segmentationId);\n}\nfunction getSegmentations() {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    const state = segmentationStateManager.getState();\n    return state.segmentations;\n}\nfunction addSegmentation(segmentationInput, suppressEvents) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    const segmentation = normalizeSegmentationInput(segmentationInput);\n    segmentationStateManager.addSegmentation(segmentation);\n    if (!suppressEvents) {\n        triggerSegmentationModified(segmentation.segmentationId);\n    }\n}\nfunction getSegmentationRepresentations(toolGroupId) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\nfunction getToolGroupIdsWithSegmentation(segmentationId) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    const state = segmentationStateManager.getState();\n    const toolGroupIds = Object.keys(state.toolGroups);\n    const foundToolGroupIds = [];\n    toolGroupIds.forEach((toolGroupId) => {\n        const toolGroupSegmentationRepresentations = segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n        toolGroupSegmentationRepresentations.forEach((representation) => {\n            if (representation.segmentationId === segmentationId) {\n                foundToolGroupIds.push(toolGroupId);\n            }\n        });\n    });\n    return foundToolGroupIds;\n}\nfunction getToolGroupSpecificConfig(toolGroupId) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\nfunction setToolGroupSpecificConfig(toolGroupId, config, suppressEvents) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.setSegmentationRepresentationConfig(toolGroupId, config);\n    if (!suppressEvents) {\n        triggerSegmentationRepresentationModified(toolGroupId);\n    }\n}\nfunction setSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID, config, suppressEvents = false) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.setSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID, config);\n    if (!suppressEvents) {\n        triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);\n    }\n}\nfunction getSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getSegmentationRepresentationSpecificConfig(toolGroupId, segmentationRepresentationUID);\n}\nfunction getSegmentSpecificRepresentationConfig(toolGroupId, segmentationRepresentationUID, segmentIndex) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, segmentIndex);\n}\nfunction setSegmentSpecificRepresentationConfig(toolGroupId, segmentationRepresentationUID, config, suppressEvents = false) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.setSegmentSpecificConfig(toolGroupId, segmentationRepresentationUID, config);\n    if (!suppressEvents) {\n        triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID);\n    }\n}\nfunction addSegmentationRepresentation(toolGroupId, segmentationRepresentation, suppressEvents) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.addSegmentationRepresentation(toolGroupId, segmentationRepresentation);\n    if (!suppressEvents) {\n        triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentation.segmentationRepresentationUID);\n    }\n}\nfunction getGlobalConfig() {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getGlobalConfig();\n}\nfunction setGlobalConfig(config, suppressEvents) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.setGlobalConfig(config);\n    if (!suppressEvents) {\n        triggerSegmentationModified();\n    }\n}\nfunction getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getSegmentationRepresentationByUID(toolGroupId, segmentationRepresentationUID);\n}\nfunction removeSegmentation(segmentationId) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.removeSegmentation(segmentationId);\n    triggerSegmentationRemoved(segmentationId);\n}\nfunction removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID);\n    triggerSegmentationRepresentationRemoved(toolGroupId, segmentationRepresentationUID);\n}\nfunction removeColorLUT(colorLUTIndex) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\nfunction getColorLUT(index) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    return segmentationStateManager.getColorLUT(index);\n}\nfunction addColorLUT(colorLUT, index) {\n    const segmentationStateManager = getDefaultSegmentationStateManager();\n    segmentationStateManager.addColorLUT(colorLUT, index);\n}\nexport { getDefaultSegmentationStateManager, getSegmentation, getSegmentations, addSegmentation, removeSegmentation, getSegmentationRepresentations, addSegmentationRepresentation, removeSegmentationRepresentation, getToolGroupSpecificConfig, setToolGroupSpecificConfig, getGlobalConfig, setGlobalConfig, getSegmentationRepresentationSpecificConfig, setSegmentationRepresentationSpecificConfig, getSegmentSpecificRepresentationConfig, setSegmentSpecificRepresentationConfig, getToolGroupIdsWithSegmentation, getSegmentationRepresentationByUID, addColorLUT, getColorLUT, removeColorLUT, };\n//# sourceMappingURL=segmentationState.js.map","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getSegmentationRepresentations, getSegmentations, } from '../../stateManagement/segmentation/segmentationState';\nfunction triggerSegmentationRemoved(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\nfunction triggerSegmentationRepresentationRemoved(toolGroupId, segmentationRepresentationUID) {\n    const eventDetail = {\n        toolGroupId,\n        segmentationRepresentationUID,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);\n}\nfunction triggerSegmentationRepresentationModified(toolGroupId, segmentationRepresentationUID) {\n    const eventDetail = {\n        toolGroupId,\n        segmentationRepresentationUID,\n    };\n    if (segmentationRepresentationUID) {\n        triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n        return;\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(toolGroupId) || [];\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        const { segmentationRepresentationUID } = segmentationRepresentation;\n        const eventDetail = {\n            toolGroupId,\n            segmentationRepresentationUID,\n        };\n        triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n    });\n}\nfunction triggerSegmentationModified(segmentationId) {\n    let segmentationIds;\n    if (segmentationId) {\n        segmentationIds = [segmentationId];\n    }\n    else {\n        segmentationIds = getSegmentations().map(({ segmentationId }) => segmentationId);\n    }\n    segmentationIds.forEach((segmentationId) => {\n        const eventDetail = {\n            segmentationId,\n        };\n        triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n    });\n}\nfunction triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\nexport { triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, triggerSegmentationDataModified, triggerSegmentationModified, triggerSegmentationRemoved, };\n//# sourceMappingURL=triggerSegmentationEvents.js.map","import { getRenderingEngine, getEnabledElement, Enums, } from '@cornerstonejs/core';\nclass Synchronizer {\n    constructor(synchronizerId, eventName, eventHandler) {\n        this._viewportOptions = {};\n        this._onEvent = (evt) => {\n            if (this._ignoreFiredEvents === true) {\n                return;\n            }\n            if (!this._targetViewports.length) {\n                return;\n            }\n            const enabledElement = getEnabledElement(evt.currentTarget);\n            if (!enabledElement) {\n                return;\n            }\n            const { renderingEngineId, viewportId } = enabledElement;\n            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n                return;\n            }\n            this.fireEvent({\n                renderingEngineId,\n                viewportId,\n            }, evt);\n        };\n        this._enabled = true;\n        this._eventName = eventName;\n        this._eventHandler = eventHandler;\n        this._ignoreFiredEvents = false;\n        this._sourceViewports = [];\n        this._targetViewports = [];\n        this.id = synchronizerId;\n    }\n    isDisabled() {\n        return !this._enabled || !this._hasSourceElements();\n    }\n    setOptions(viewportId, options = {}) {\n        this._viewportOptions[viewportId] = options;\n    }\n    getOptions(viewportId) {\n        return this._viewportOptions[viewportId];\n    }\n    add(viewportInfo) {\n        this.addTarget(viewportInfo);\n        this.addSource(viewportInfo);\n    }\n    addSource(viewportInfo) {\n        if (_containsViewport(this._sourceViewports, viewportInfo)) {\n            return;\n        }\n        const { renderingEngineId, viewportId } = viewportInfo;\n        const { element } = getRenderingEngine(renderingEngineId).getViewport(viewportId);\n        element.addEventListener(this._eventName, this._onEvent.bind(this));\n        this._updateDisableHandlers();\n        this._sourceViewports.push(viewportInfo);\n    }\n    addTarget(viewportInfo) {\n        if (_containsViewport(this._targetViewports, viewportInfo)) {\n            return;\n        }\n        this._targetViewports.push(viewportInfo);\n        this._updateDisableHandlers();\n    }\n    getSourceViewports() {\n        return this._sourceViewports;\n    }\n    getTargetViewports() {\n        return this._targetViewports;\n    }\n    destroy() {\n        this._sourceViewports.forEach((s) => this.removeSource(s));\n        this._targetViewports.forEach((t) => this.removeTarget(t));\n    }\n    remove(viewportInfo) {\n        this.removeTarget(viewportInfo);\n        this.removeSource(viewportInfo);\n    }\n    removeSource(viewportInfo) {\n        const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        const element = _getViewportElement(viewportInfo);\n        this._sourceViewports.splice(index, 1);\n        element.removeEventListener(this._eventName, this._eventHandler);\n        this._updateDisableHandlers();\n    }\n    removeTarget(viewportInfo) {\n        const index = _getViewportIndex(this._targetViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        this._targetViewports.splice(index, 1);\n        this._updateDisableHandlers();\n    }\n    hasSourceViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._sourceViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    hasTargetViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._targetViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    fireEvent(sourceViewport, sourceEvent) {\n        if (this.isDisabled() || this._ignoreFiredEvents) {\n            return;\n        }\n        this._ignoreFiredEvents = true;\n        try {\n            for (let i = 0; i < this._targetViewports.length; i++) {\n                const targetViewport = this._targetViewports[i];\n                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;\n                if (targetIsSource) {\n                    continue;\n                }\n                this._eventHandler(this, sourceViewport, targetViewport, sourceEvent);\n            }\n        }\n        catch (ex) {\n            console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n        }\n        finally {\n            this._ignoreFiredEvents = false;\n        }\n    }\n    _hasSourceElements() {\n        return this._sourceViewports.length !== 0;\n    }\n    _updateDisableHandlers() {\n        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);\n        const _remove = this.remove;\n        const disableHandler = (elementDisabledEvent) => {\n            _remove(elementDisabledEvent.detail.element);\n        };\n        viewports.forEach(function (vUid) {\n            const renderingEngine = getRenderingEngine(vUid.renderingEngineId).getViewport(vUid.viewportId);\n            if (!renderingEngine) {\n                return;\n            }\n            const { element } = renderingEngine;\n            element.removeEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n            element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n        });\n    }\n}\nfunction _getUniqueViewports(vp1, vp2) {\n    const unique = [];\n    const vps = vp1.concat(vp2);\n    for (let i = 0; i < vps.length; i++) {\n        const vp = vps[i];\n        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&\n            vp.viewportId === u.viewportId)) {\n            unique.push(vp);\n        }\n    }\n    return unique;\n}\nfunction _getViewportIndex(arr, vp) {\n    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&\n        vp.viewportId === ar.viewportId);\n}\nfunction _containsViewport(arr, vp) {\n    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&\n        ar.viewportId === vp.viewportId);\n}\nfunction _getViewportElement(vp) {\n    const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n    }\n    return renderingEngine.getViewport(vp.viewportId).element;\n}\nexport default Synchronizer;\n//# sourceMappingURL=Synchronizer.js.map","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nfunction createSynchronizer(synchronizerId, eventName, eventHandler) {\n    const synchronizerWithSameIdExists = state.synchronizers.some((sync) => sync.id === synchronizerId);\n    if (synchronizerWithSameIdExists) {\n        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n    }\n    const synchronizer = new Synchronizer(synchronizerId, eventName, eventHandler);\n    state.synchronizers.push(synchronizer);\n    return synchronizer;\n}\nexport default createSynchronizer;\n//# sourceMappingURL=createSynchronizer.js.map","import { state } from '../index';\nfunction destroy() {\n    while (state.synchronizers.length > 0) {\n        const synchronizer = state.synchronizers.pop();\n        synchronizer.destroy();\n    }\n}\nexport default destroy;\n//# sourceMappingURL=destroy.js.map","import { state } from '../index';\nfunction destroySynchronizer(synchronizerId) {\n    const synchronizerIndex = state.synchronizers.findIndex((sync) => sync.id === synchronizerId);\n    if (synchronizerIndex > -1) {\n        const synchronizer = state.synchronizers[synchronizerIndex];\n        synchronizer.destroy();\n        state.synchronizers.splice(synchronizerIndex, 1);\n    }\n}\nexport default destroySynchronizer;\n//# sourceMappingURL=destroySynchronizer.js.map","import { state } from '../index';\nfunction getAllSynchronizers() {\n    return state.synchronizers;\n}\nexport default getAllSynchronizers;\n//# sourceMappingURL=getAllSynchronizers.js.map","import { state } from '../index';\nfunction getSynchronizer(synchronizerId) {\n    return state.synchronizers.find((s) => s.id === synchronizerId);\n}\nexport default getSynchronizer;\n//# sourceMappingURL=getSynchronizer.js.map","import { state } from '../index';\nfunction getSynchronizersForViewport(viewportId, renderingEngineId) {\n    const synchronizersFilteredByIds = [];\n    if (!renderingEngineId && !viewportId) {\n        throw new Error('At least one of renderingEngineId or viewportId should be given');\n    }\n    for (let i = 0; i < state.synchronizers.length; i++) {\n        const synchronizer = state.synchronizers[i];\n        const notDisabled = !synchronizer.isDisabled();\n        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);\n        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);\n        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n            synchronizersFilteredByIds.push(synchronizer);\n        }\n    }\n    return synchronizersFilteredByIds;\n}\nexport default getSynchronizersForViewport;\n//# sourceMappingURL=getSynchronizersForViewport.js.map","import createSynchronizer from './createSynchronizer';\nimport destroy from './destroy';\nimport getSynchronizersForViewport from './getSynchronizersForViewport';\nimport getSynchronizer from './getSynchronizer';\nimport getAllSynchronizers from './getAllSynchronizers';\nimport destroySynchronizer from './destroySynchronizer';\nexport { createSynchronizer, destroy, getSynchronizer, getSynchronizersForViewport, getAllSynchronizers, destroySynchronizer, };\n//# sourceMappingURL=index.js.map","import { MouseBindings, ToolModes } from '../../enums';\nimport cloneDeep from 'lodash.clonedeep';\nimport get from 'lodash.get';\nimport { getRenderingEngine, getRenderingEngines, getEnabledElementByIds, Settings, utilities as csUtils, } from '@cornerstonejs/core';\nimport { state } from '../index';\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\nexport default class ToolGroup {\n    constructor(id) {\n        this.viewportsInfo = [];\n        this.toolOptions = {};\n        this._toolInstances = {};\n        this.id = id;\n    }\n    getViewportIds() {\n        return this.viewportsInfo.map(({ viewportId }) => viewportId);\n    }\n    getViewportsInfo() {\n        return this.viewportsInfo.slice();\n    }\n    getToolInstance(toolInstanceName) {\n        const toolInstance = this._toolInstances[toolInstanceName];\n        if (!toolInstance) {\n            console.warn(`'${toolInstanceName}' is not registered with this toolGroup.`);\n            return;\n        }\n        return toolInstance;\n    }\n    addTool(toolName, configuration = {}) {\n        const toolDefinition = state.tools[toolName];\n        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n        const localToolInstance = this.toolOptions[toolName];\n        if (!hasToolName) {\n            console.warn('Tool with configuration did not produce a toolName: ', configuration);\n            return;\n        }\n        if (!toolDefinition) {\n            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);\n            return;\n        }\n        if (localToolInstance) {\n            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);\n            return;\n        }\n        const { toolClass: ToolClass } = toolDefinition;\n        const toolProps = {\n            name: toolName,\n            toolGroupId: this.id,\n            configuration,\n        };\n        const instantiatedTool = new ToolClass(toolProps);\n        this._toolInstances[toolName] = instantiatedTool;\n    }\n    addToolInstance(toolName, parentClassName, configuration = {}) {\n        let ToolClassToUse = state.tools[toolName]\n            ?.toolClass;\n        if (!ToolClassToUse) {\n            const ParentClass = state.tools[parentClassName]\n                .toolClass;\n            class ToolInstance extends ParentClass {\n            }\n            ToolInstance.toolName = toolName;\n            ToolClassToUse = ToolInstance;\n            state.tools[toolName] = {\n                toolClass: ToolInstance,\n            };\n        }\n        this.addTool(ToolClassToUse.toolName, configuration);\n    }\n    addViewport(viewportId, renderingEngineId) {\n        const renderingEngines = getRenderingEngines();\n        if (!renderingEngineId && renderingEngines.length > 1) {\n            throw new Error('You must specify a renderingEngineId when there are multiple rendering engines.');\n        }\n        const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {\n            this.viewportsInfo.push({\n                viewportId,\n                renderingEngineId: renderingEngineUIDToUse,\n            });\n        }\n        const toolName = this.getActivePrimaryMouseButtonTool();\n        const runtimeSettings = Settings.getRuntimeSettings();\n        if (runtimeSettings.get('useCursors')) {\n            this.setViewportsCursorByToolName(toolName);\n        }\n    }\n    removeViewports(renderingEngineId, viewportId) {\n        const indices = [];\n        this.viewportsInfo.forEach((vpInfo, index) => {\n            let match = false;\n            if (vpInfo.renderingEngineId === renderingEngineId) {\n                match = true;\n                if (viewportId && vpInfo.viewportId !== viewportId) {\n                    match = false;\n                }\n            }\n            if (match) {\n                indices.push(index);\n            }\n        });\n        if (indices.length) {\n            for (let i = indices.length - 1; i >= 0; i--) {\n                this.viewportsInfo.splice(indices[i], 1);\n            }\n        }\n    }\n    setActiveStrategy(toolName, strategyName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);\n            return;\n        }\n        toolInstance.setActiveStrategy(strategyName);\n    }\n    setToolMode(toolName, mode, options = {}) {\n        if (!toolName) {\n            console.warn('setToolMode: toolName must be defined');\n            return;\n        }\n        if (mode === ToolModes.Active) {\n            this.setToolActive(toolName, options);\n            return;\n        }\n        if (mode === ToolModes.Passive) {\n            this.setToolPassive(toolName);\n            return;\n        }\n        if (mode === ToolModes.Enabled) {\n            this.setToolEnabled(toolName);\n            return;\n        }\n        if (mode === ToolModes.Disabled) {\n            this.setToolDisabled(toolName);\n            return;\n        }\n        console.warn('setToolMode: mode must be defined');\n    }\n    setToolActive(toolName, toolBindingsOptions = {}) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        if (!toolInstance) {\n            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevBindings = this.toolOptions[toolName]\n            ? this.toolOptions[toolName].bindings\n            : [];\n        const newBindings = toolBindingsOptions.bindings\n            ? toolBindingsOptions.bindings\n            : [];\n        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {\n            const TouchBinding = binding.numTouchPoints !== undefined;\n            const MouseBinding = binding.mouseButton !== undefined;\n            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&\n                (TouchBinding || MouseBinding)) {\n                unique.push(binding);\n            }\n            return unique;\n        }, []);\n        const toolOptions = {\n            bindings: bindingsToUse,\n            mode: Active,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        this._toolInstances[toolName].mode = Active;\n        const runtimeSettings = Settings.getRuntimeSettings();\n        const useCursor = runtimeSettings.get('useCursors');\n        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n            this.setViewportsCursorByToolName(toolName);\n        }\n        else {\n            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n            if (!activeToolIdentifier && useCursor) {\n                const cursor = MouseCursor.getDefinedCursor('default');\n                this._setCursorForViewports(cursor);\n            }\n        }\n        if (typeof toolInstance.onSetToolActive === 'function') {\n            toolInstance.onSetToolActive();\n        }\n        this._renderViewports();\n    }\n    setToolPassive(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevToolOptions = this.getToolOptions(toolName);\n        const toolOptions = Object.assign({\n            bindings: prevToolOptions ? prevToolOptions.bindings : [],\n        }, prevToolOptions, {\n            mode: Passive,\n        });\n        const defaultMousePrimary = this.getDefaultMousePrimary();\n        toolOptions.bindings = toolOptions.bindings.filter((binding) => binding.mouseButton !== defaultMousePrimary || binding.modifierKey);\n        let mode = Passive;\n        if (toolOptions.bindings.length !== 0) {\n            mode = Active;\n            toolOptions.mode = mode;\n        }\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = mode;\n        if (typeof toolInstance.onSetToolPassive === 'function') {\n            toolInstance.onSetToolPassive();\n        }\n        this._renderViewports();\n    }\n    setToolEnabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Enabled,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Enabled;\n        if (typeof toolInstance.onSetToolEnabled === 'function') {\n            toolInstance.onSetToolEnabled();\n        }\n        this._renderViewports();\n    }\n    setToolDisabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Disabled,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Disabled;\n        if (typeof toolInstance.onSetToolDisabled === 'function') {\n            toolInstance.onSetToolDisabled();\n        }\n        this._renderViewports();\n    }\n    getToolOptions(toolName) {\n        const toolOptionsForTool = this.toolOptions[toolName];\n        if (toolOptionsForTool === undefined) {\n            return;\n        }\n        return toolOptionsForTool;\n    }\n    getActivePrimaryMouseButtonTool() {\n        return Object.keys(this.toolOptions).find((toolName) => {\n            const toolOptions = this.toolOptions[toolName];\n            return (toolOptions.mode === Active &&\n                this._hasMousePrimaryButtonBinding(toolOptions));\n        });\n    }\n    setViewportsCursorByToolName(toolName, strategyName) {\n        const cursor = this._getCursor(toolName, strategyName);\n        this._setCursorForViewports(cursor);\n    }\n    _getCursor(toolName, strategyName) {\n        let cursorName;\n        let cursor;\n        if (strategyName) {\n            cursorName = `${toolName}.${strategyName}`;\n            cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n            if (cursor) {\n                return cursor;\n            }\n        }\n        cursorName = `${toolName}`;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        cursorName = toolName;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        return MouseCursor.getDefinedCursor('default');\n    }\n    _setCursorForViewports(cursor) {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            initElementCursor(viewport.element, cursor);\n        });\n    }\n    setToolConfiguration(toolName, configuration, overwrite) {\n        if (this._toolInstances[toolName] === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return false;\n        }\n        let _configuration;\n        if (overwrite) {\n            _configuration = configuration;\n        }\n        else {\n            _configuration = csUtils.deepMerge(this._toolInstances[toolName].configuration, configuration);\n        }\n        this._toolInstances[toolName].configuration = _configuration;\n        this._renderViewports();\n        return true;\n    }\n    getDefaultMousePrimary() {\n        return MouseBindings.Primary;\n    }\n    getToolConfiguration(toolName, configurationPath) {\n        if (this._toolInstances[toolName] === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return;\n        }\n        const _configuration = get(this._toolInstances[toolName].configuration, configurationPath);\n        return cloneDeep(_configuration);\n    }\n    _hasMousePrimaryButtonBinding(toolOptions) {\n        const defaultMousePrimary = this.getDefaultMousePrimary();\n        return toolOptions?.bindings?.some((binding) => binding.mouseButton === defaultMousePrimary &&\n            binding.modifierKey === undefined);\n    }\n    _renderViewports() {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n        });\n    }\n}\nfunction hasSameBinding(binding1, binding2) {\n    if (binding1.mouseButton !== binding2.mouseButton) {\n        return false;\n    }\n    return binding1.modifierKey === binding2.modifierKey;\n}\n//# sourceMappingURL=ToolGroup.js.map","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nfunction createToolGroup(toolGroupId) {\n    const toolGroupWithIdExists = state.toolGroups.some((tg) => tg.id === toolGroupId);\n    if (toolGroupWithIdExists) {\n        console.warn(`'${toolGroupId}' already exists.`);\n        return;\n    }\n    const toolGroup = new ToolGroup(toolGroupId);\n    state.toolGroups.push(toolGroup);\n    return toolGroup;\n}\nexport default createToolGroup;\n//# sourceMappingURL=createToolGroup.js.map","import { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\nfunction destroy() {\n    const toolGroups = [...csToolsState.toolGroups];\n    for (const toolGroup of toolGroups) {\n        destroyToolGroup(toolGroup.id);\n    }\n    csToolsState.toolGroups = [];\n}\nexport default destroy;\n//# sourceMappingURL=destroy.js.map","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\nfunction destroyToolGroup(toolGroupId) {\n    const toolGroupIndex = state.toolGroups.findIndex((tg) => tg.id === toolGroupId);\n    if (toolGroupIndex > -1) {\n        segmentationRenderingEngine.removeToolGroup(toolGroupId);\n        removeSegmentationsFromToolGroup(toolGroupId);\n        state.toolGroups.splice(toolGroupIndex, 1);\n    }\n}\nexport default destroyToolGroup;\n//# sourceMappingURL=destroyToolGroup.js.map","import { state } from '../index';\nfunction getAllToolGroups() {\n    return state.toolGroups;\n}\nexport default getAllToolGroups;\n//# sourceMappingURL=getAllToolGroups.js.map","import { state } from '../index';\nfunction getToolGroup(toolGroupId) {\n    return state.toolGroups.find((s) => s.id === toolGroupId);\n}\nexport default getToolGroup;\n//# sourceMappingURL=getToolGroup.js.map","import { state } from '../index';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n//# sourceMappingURL=getToolGroupForViewport.js.map","import { state } from '../index';\nimport { ToolModes } from '../../enums';\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\nfunction getToolGroupsWithToolName(toolName) {\n    return state.toolGroups.filter(({ toolOptions }) => {\n        const toolGroupToolNames = Object.keys(toolOptions);\n        for (let i = 0; i < toolGroupToolNames.length; i++) {\n            if (toolName !== toolGroupToolNames[i])\n                continue;\n            if (!toolOptions[toolName]) {\n                continue;\n            }\n            if (MODES.includes(toolOptions[toolName].mode)) {\n                return true;\n            }\n        }\n        return false;\n    });\n}\nexport default getToolGroupsWithToolName;\n//# sourceMappingURL=getToolGroupsWithToolName.js.map","import createToolGroup from './createToolGroup';\nimport destroyToolGroup from './destroyToolGroup';\nimport destroy from './destroy';\nimport getToolGroup from './getToolGroup';\nimport getToolGroupForViewport from './getToolGroupForViewport';\nimport getAllToolGroups from './getAllToolGroups';\nimport getToolGroupsWithToolName from './getToolGroupsWithToolName';\nexport { createToolGroup, destroy, destroyToolGroup, getToolGroup, getToolGroupForViewport, getAllToolGroups, getToolGroupsWithToolName, };\n//# sourceMappingURL=index.js.map","import { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, touchToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, } from '../eventDispatchers';\nimport { state } from './state';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\nexport default function addEnabledElement(evt) {\n    const { element, viewportId } = evt.detail;\n    const svgLayer = _createSvgAnnotationLayer(viewportId);\n    _setSvgNodeCache(element);\n    _appendChild(svgLayer, element);\n    annotationRenderingEngine.addViewportElement(viewportId, element);\n    mouseEventListeners.enable(element);\n    wheelEventListener.enable(element);\n    touchEventListeners.enable(element);\n    keyEventListener.enable(element);\n    imageRenderedEventDispatcher.enable(element);\n    cameraModifiedEventDispatcher.enable(element);\n    imageSpacingCalibratedEventDispatcher.enable(element);\n    mouseToolEventDispatcher.enable(element);\n    keyboardToolEventDispatcher.enable(element);\n    touchToolEventDispatcher.enable(element);\n    state.enabledElements.push(element);\n}\nfunction _createSvgAnnotationLayer(viewportId) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgLayer = document.createElementNS(svgns, 'svg');\n    const svgLayerId = `svg-layer-${viewportId}`;\n    svgLayer.classList.add('svg-layer');\n    svgLayer.setAttribute('id', svgLayerId);\n    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svgLayer.style.width = '100%';\n    svgLayer.style.height = '100%';\n    svgLayer.style.pointerEvents = 'none';\n    svgLayer.style.position = 'absolute';\n    const defs = document.createElementNS(svgns, 'defs');\n    const filter = document.createElementNS(svgns, 'filter');\n    const feOffset = document.createElementNS(svgns, 'feOffset');\n    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n    const feBlend = document.createElementNS(svgns, 'feBlend');\n    filter.setAttribute('id', `shadow-${svgLayerId}`);\n    filter.setAttribute('filterUnits', 'userSpaceOnUse');\n    feOffset.setAttribute('result', 'offOut');\n    feOffset.setAttribute('in', 'SourceGraphic');\n    feOffset.setAttribute('dx', '0.5');\n    feOffset.setAttribute('dy', '0.5');\n    feColorMatrix.setAttribute('result', 'matrixOut');\n    feColorMatrix.setAttribute('in', 'offOut');\n    feColorMatrix.setAttribute('in2', 'matrix');\n    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');\n    feBlend.setAttribute('in', 'SourceGraphic');\n    feBlend.setAttribute('in2', 'matrixOut');\n    feBlend.setAttribute('mode', 'normal');\n    filter.appendChild(feOffset);\n    filter.appendChild(feColorMatrix);\n    filter.appendChild(feBlend);\n    defs.appendChild(filter);\n    svgLayer.appendChild(defs);\n    return svgLayer;\n}\nfunction _setSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    state.svgNodeCache[elementHash] = {};\n}\nfunction _appendChild(newNode, referenceNode) {\n    referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n//# sourceMappingURL=addEnabledElement.js.map","import { state } from './state';\nexport function addTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    const toolAlreadyAdded = state.tools[toolName] !== undefined;\n    if (!toolName) {\n        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n    }\n    if (toolAlreadyAdded) {\n        throw new Error(`${toolName} has already been added globally`);\n    }\n    state.tools[toolName] = {\n        toolClass: ToolClass,\n    };\n}\nexport function removeTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No tool found for: ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName] !== undefined) {\n        delete state.tools[toolName];\n    }\n    else {\n        throw new Error(`${toolName} cannot be removed because it has not been added`);\n    }\n}\nexport default addTool;\n//# sourceMappingURL=addTool.js.map","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nexport default function cancelActiveManipulations(element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    for (const { tool } of toolsWithData) {\n        const annotationUID = tool.cancel(element);\n        if (annotationUID) {\n            return annotationUID;\n        }\n    }\n}\n//# sourceMappingURL=cancelActiveManipulations.js.map","export default function filterMoveableAnnotationTools(element, ToolAndAnnotations, canvasCoords, interactionType = 'mouse') {\n    const proximity = interactionType === 'touch' ? 36 : 6;\n    const moveableAnnotationTools = [];\n    ToolAndAnnotations.forEach(({ tool, annotations }) => {\n        for (const annotation of annotations) {\n            if (annotation.isLocked || !annotation.isVisible) {\n                continue;\n            }\n            const near = tool.isPointNearTool(element, annotation, canvasCoords, proximity, interactionType);\n            if (near) {\n                moveableAnnotationTools.push({\n                    tool,\n                    annotation,\n                });\n                break;\n            }\n        }\n    });\n    return moveableAnnotationTools;\n}\n//# sourceMappingURL=filterMoveableAnnotationTools.js.map","import { getAnnotations } from '../stateManagement/annotation/annotationState';\nexport default function filterToolsWithAnnotationsForElement(element, tools) {\n    const result = [];\n    for (let i = 0; i < tools.length; i++) {\n        const tool = tools[i];\n        if (!tool) {\n            console.warn('undefined tool in filterToolsWithAnnotationsForElement');\n            continue;\n        }\n        let annotations = getAnnotations(tool.constructor.toolName, element);\n        if (!annotations?.length) {\n            continue;\n        }\n        if (typeof tool.filterInteractableAnnotationsForElement === 'function') {\n            annotations = tool.filterInteractableAnnotationsForElement(element, annotations);\n        }\n        if (annotations.length > 0) {\n            result.push({ tool, annotations });\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=filterToolsWithAnnotationsForElement.js.map","export default function filterToolsWithMoveableHandles(element, ToolAndAnnotations, canvasCoords, interactionType = 'mouse') {\n    const proximity = interactionType === 'touch' ? 36 : 6;\n    const toolsWithMoveableHandles = [];\n    ToolAndAnnotations.forEach(({ tool, annotations }) => {\n        for (const annotation of annotations) {\n            if (annotation.isLocked || !annotation.isVisible) {\n                continue;\n            }\n            const handle = tool.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n            if (handle) {\n                toolsWithMoveableHandles.push({\n                    tool,\n                    annotation,\n                    handle,\n                });\n                break;\n            }\n        }\n    });\n    return toolsWithMoveableHandles;\n}\n//# sourceMappingURL=filterToolsWithMoveableHandles.js.map","import { addTool, removeTool } from './addTool';\nimport addEnabledElement from './addEnabledElement';\nimport removeEnabledElement from './removeEnabledElement';\nimport cancelActiveManipulations from './cancelActiveManipulations';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache from './svgNodeCache';\nimport state from './state';\nimport * as ToolGroupManager from './ToolGroupManager';\nimport * as SynchronizerManager from './SynchronizerManager';\nexport { state, addTool, removeTool, addEnabledElement, removeEnabledElement, cancelActiveManipulations, svgNodeCache, ToolGroupManager, SynchronizerManager, Synchronizer, };\n//# sourceMappingURL=index.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, touchToolEventDispatcher, } from '../eventDispatchers';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction removeEnabledElement(elementDisabledEvt) {\n    const { element, viewportId } = elementDisabledEvt.detail;\n    _resetSvgNodeCache(element);\n    _removeSvgNode(element);\n    annotationRenderingEngine.removeViewportElement(viewportId, element);\n    mouseEventListeners.disable(element);\n    wheelEventListener.disable(element);\n    touchEventListeners.disable(element);\n    keyEventListener.disable(element);\n    imageRenderedEventDispatcher.disable(element);\n    cameraModifiedEventDispatcher.disable(element);\n    imageSpacingCalibratedEventDispatcher.disable(element);\n    mouseToolEventDispatcher.disable(element);\n    keyboardToolEventDispatcher.disable(element);\n    touchToolEventDispatcher.disable(element);\n    _removeViewportFromSynchronizers(element);\n    _removeViewportFromToolGroup(element);\n    _removeEnabledElement(element);\n}\nconst _removeViewportFromSynchronizers = (element) => {\n    const enabledElement = getEnabledElement(element);\n    const synchronizers = getSynchronizersForViewport(enabledElement.viewportId, enabledElement.renderingEngineId);\n    synchronizers.forEach((sync) => {\n        sync.remove(enabledElement);\n    });\n};\nconst _removeViewportFromToolGroup = (element) => {\n    const { renderingEngineId, viewportId } = getEnabledElement(element);\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (toolGroup) {\n        toolGroup.removeViewports(renderingEngineId, viewportId);\n    }\n};\nconst _removeAllToolsForElement = function (element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    toolsWithData.forEach(({ annotations }) => {\n        annotations.forEach((annotation) => {\n            removeAnnotation(annotation.annotationUID);\n        });\n    });\n};\nfunction _resetSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    delete state.svgNodeCache[elementHash];\n}\nfunction _removeSvgNode(element) {\n    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n    const svgLayer = internalViewportNode.querySelector('svg');\n    if (svgLayer) {\n        internalViewportNode.removeChild(svgLayer);\n    }\n}\nconst _removeEnabledElement = function (element) {\n    const foundElementIndex = state.enabledElements.findIndex((el) => el === element);\n    if (foundElementIndex > -1) {\n        state.enabledElements.splice(foundElementIndex, 1);\n    }\n};\nexport default removeEnabledElement;\n//# sourceMappingURL=removeEnabledElement.js.map","import _cloneDeep from 'lodash.clonedeep';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nconst defaultState = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nlet state = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nfunction resetCornerstoneToolsState() {\n    resetSvgNodeCache();\n    state = _cloneDeep(defaultState);\n}\nexport { resetCornerstoneToolsState, state, state as default, };\n//# sourceMappingURL=state.js.map","let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n//# sourceMappingURL=svgNodeCache.js.map","import { vec3 } from 'gl-matrix';\nexport default function areViewportsCoplanar(viewport1, viewport2) {\n    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n    const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n    return Math.abs(dotProducts) > 0.9;\n}\n//# sourceMappingURL=areViewportsCoplanar%20.js.map","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {\n    const { camera } = cameraModifiedEvent.detail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    tViewport.setCamera(camera);\n    tViewport.render();\n}\n//# sourceMappingURL=cameraSyncCallback.js.map","import { vec3 } from 'gl-matrix';\nimport { getRenderingEngine, metaData, utilities, } from '@cornerstonejs/core';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\nexport default async function stackImageSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n    const imageId1 = sViewport.getCurrentImageId();\n    const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n    const targetImageIds = tViewport.getImageIds();\n    if (!areViewportsCoplanar(sViewport, tViewport)) {\n        return;\n    }\n    if (frameOfReferenceUID1 === frameOfReferenceUID2) {\n        const closestImageIdIndex = _getClosestImageIdIndex(sourceImagePositionPatient, targetImageIds);\n        if (closestImageIdIndex.index !== -1 &&\n            tViewport.getCurrentImageIdIndex() !== closestImageIdIndex.index) {\n            await jumpToSlice(tViewport.element, {\n                imageIndex: closestImageIdIndex.index,\n            });\n            return;\n        }\n    }\n    else {\n        const registrationMatrixMat4 = utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', [targetViewport.viewportId, sourceViewport.viewportId]);\n        if (!registrationMatrixMat4) {\n            throw new Error(`No registration matrix found for sourceViewport: ${sourceViewport.viewportId} and targetViewport: ${targetViewport.viewportId}, viewports with different frameOfReferenceUIDs must have a registration matrix in the registrationMetadataProvider. Use calculateViewportsRegistrationMatrix to calculate the matrix.`);\n        }\n        const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(vec3.create(), sourceImagePositionPatient, registrationMatrixMat4);\n        const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);\n        if (closestImageIdIndex2.index !== -1 &&\n            tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {\n            await jumpToSlice(tViewport.element, {\n                imageIndex: closestImageIdIndex2.index,\n            });\n        }\n    }\n}\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n    return imageIds.reduce((closestImageIdIndex, imageId, index) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = vec3.distance(imagePositionPatient, targetPoint);\n        if (distance < closestImageIdIndex.distance) {\n            return {\n                distance,\n                index,\n            };\n        }\n        return closestImageIdIndex;\n    }, {\n        distance: Infinity,\n        index: -1,\n    });\n}\n//# sourceMappingURL=stackImageSyncCallback.js.map","import { getRenderingEngine, StackViewport, VolumeViewport, } from '@cornerstonejs/core';\nexport default function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, voiModifiedEvent) {\n    const eventDetail = voiModifiedEvent.detail;\n    const { volumeId, range } = eventDetail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    if (tViewport instanceof VolumeViewport) {\n        tViewport.setProperties({\n            voiRange: range,\n        }, volumeId);\n    }\n    else if (tViewport instanceof StackViewport) {\n        tViewport.setProperties({\n            voiRange: range,\n        });\n    }\n    else {\n        throw new Error('Viewport type not supported.');\n    }\n    tViewport.render();\n}\n//# sourceMappingURL=voiSyncCallback.js.map","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    if (options?.syncZoom !== false) {\n        const srcZoom = sViewport.getZoom();\n        tViewport.setZoom(srcZoom);\n    }\n    if (options?.syncPan !== false) {\n        const srcPan = sViewport.getPan();\n        tViewport.setPan(srcPan);\n    }\n    tViewport.render();\n}\n//# sourceMappingURL=zoomPanSyncCallback.js.map","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createStackImageSynchronizer from './synchronizers/createStackImageSynchronizer';\nexport { createCameraPositionSynchronizer, createVOISynchronizer, createZoomPanSynchronizer, createStackImageSynchronizer, };\n//# sourceMappingURL=index.js.map","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createCameraPositionSynchronizer(synchronizerName) {\n    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);\n    return cameraPositionSynchronizer;\n}\n//# sourceMappingURL=createCameraPositionSynchronizer.js.map","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport stackImageSyncCallback from '../callbacks/stackImageSyncCallback';\nconst { STACK_NEW_IMAGE } = Enums.Events;\nexport default function createStackImageSynchronizer(synchronizerName) {\n    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, stackImageSyncCallback);\n    return stackImageSynchronizer;\n}\n//# sourceMappingURL=createStackImageSynchronizer.js.map","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nexport default function createVOISynchronizer(synchronizerName) {\n    const VOISynchronizer = createSynchronizer(synchronizerName, Enums.Events.VOI_MODIFIED, voiSyncCallback);\n    return VOISynchronizer;\n}\n//# sourceMappingURL=createVOISynchronizer.js.map","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createZoomPanSynchronizer(synchronizerName) {\n    const zoomPanSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, zoomPanSyncCallback);\n    return zoomPanSynchronizer;\n}\n//# sourceMappingURL=createZoomPanSynchronizer.js.map","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport { AnnotationTool } from './base';\nimport { getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nfunction defaultReferenceLineDraggableRotatable() {\n    return true;\n}\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nconst EPSILON = 1e-3;\nclass CrosshairsTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            shadow: true,\n            viewportIndicators: true,\n            autoPan: {\n                enabled: false,\n                panSize: 10,\n            },\n            referenceLinesCenterGapRadius: 20,\n            filterActorUIDsToSetSlabThickness: [],\n            slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n                handleRadius: 9,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.toolCenter = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { FrameOfReferenceUID, viewport } = enabledElement;\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    FrameOfReferenceUID,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        rotationPoints: [],\n                        slabThicknessPoints: [],\n                        toolCenter: this.toolCenter,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([\n                    viewport.canvas.clientWidth / 2,\n                    viewport.canvas.clientHeight / 2,\n                ]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo.length || viewportsInfo.length === 1) {\n                throw new Error('For crosshairs to operate, at least two viewports must be given.');\n            }\n            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);\n            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);\n            let normal3 = [0, 0, 0];\n            let point3 = vec3.create();\n            if (thirdViewport) {\n                ({ normal: normal3, point: point3 } =\n                    this.initializeViewport(thirdViewport));\n            }\n            else {\n                vec3.add(point3, point1, point2);\n                vec3.scale(point3, point3, 0.5);\n                vec3.cross(normal3, normal1, normal2);\n            }\n            const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n            const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n            const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n            this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);\n            const { renderingEngine } = getEnabledElementByIds(viewportsInfo[0].viewportId, viewportsInfo[0].renderingEngineId);\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const jumpWorld = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._jump(enabledElement, jumpWorld);\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n            const { data } = filteredAnnotations[0];\n            const { rotationPoints } = data.handles;\n            const viewportIdArray = [];\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                if (!viewportControllable || !viewportDraggableRotatable) {\n                    continue;\n                }\n                viewportIdArray.push(otherViewport.id);\n                i++;\n            }\n            data.activeViewportIds = [...viewportIdArray];\n            data.handles.activeOperation = OPERATION.DRAG;\n            evt.preventDefault();\n            hideElementCursor(element);\n            this._activateModify(element);\n            return filteredAnnotations[0];\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const viewport = enabledElement.viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const currentCamera = viewport.getCamera();\n            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n            const deltaCameraPosition = [0, 0, 0];\n            vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);\n            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);\n            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n            viewportAnnotation.metadata.cameraFocalPoint = [\n                ...currentCamera.focalPoint,\n            ];\n            const viewportControllable = this._getReferenceLineControllable(viewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);\n            if (!csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n                viewportControllable &&\n                viewportDraggableRotatable) {\n                let isRotation = false;\n                const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);\n                if (!cameraModifiedSameForPosAndFocalPoint) {\n                    isRotation = true;\n                }\n                const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;\n                if (!isRotation && !cameraModifiedInPlane) {\n                    this.toolCenter[0] += deltaCameraPosition[0];\n                    this.toolCenter[1] += deltaCameraPosition[1];\n                    this.toolCenter[2] += deltaCameraPosition[2];\n                }\n            }\n            if (this.configuration.autoPan?.enabled) {\n                const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);\n                const otherViewportIds = toolGroup\n                    .getViewportIds()\n                    .filter((id) => id !== viewport.id);\n                otherViewportIds.forEach((viewportId) => {\n                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n                });\n            }\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                data.handles.activeOperation = null;\n                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);\n                let near = false;\n                if (handleNearImagePoint) {\n                    near = true;\n                }\n                else {\n                    near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                }\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n                else if (data.handles.activeOperation !== previousActiveOperation ||\n                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewportId } = enabledElement;\n            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);\n            return viewportUIDSpecificCrosshairs;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!annotations?.length || !viewportAnnotation?.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n            const data = viewportAnnotation.data;\n            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const { data } = annotation;\n                data.handles.toolCenter = this.toolCenter;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                const { clientWidth, clientHeight } = otherViewport.canvas;\n                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                const otherCanvasCenter = [\n                    clientWidth * 0.5,\n                    clientHeight * 0.5,\n                ];\n                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const canvasVectorFromCenterMid = vec2.create();\n                vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);\n                const canvasVectorFromCenterShort = vec2.create();\n                vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);\n                const canvasVectorFromCenterStart = vec2.create();\n                const centerGap = this.configuration.referenceLinesCenterGapRadius;\n                vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);\n                const refLinePointOne = vec2.create();\n                const refLinePointTwo = vec2.create();\n                const refLinePointThree = vec2.create();\n                const refLinePointFour = vec2.create();\n                let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n                    refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n                }\n                vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n                liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n                const rotHandleOne = vec2.create();\n                vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                const rotHandleTwo = vec2.create();\n                vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n                }\n                let stHandlesCenterWorld = [...this.toolCenter];\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterWorld = [...otherViewportCenterWorld];\n                }\n                const worldUnitVectorFromCenter = [0, 0, 0];\n                vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n                vtkMath.normalize(worldUnitVectorFromCenter);\n                const { viewPlaneNormal } = camera;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromDegree()\n                    .rotate(90, viewPlaneNormal);\n                const worldUnitOrthoVectorFromCenter = [0, 0, 0];\n                vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);\n                const slabThicknessValue = otherViewport.getSlabThickness();\n                const worldOrthoVectorFromCenter = [\n                    ...worldUnitOrthoVectorFromCenter,\n                ];\n                vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n                const worldVerticalRefPoint = [0, 0, 0];\n                vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);\n                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);\n                const canvasOrthoVectorFromCenter = vec2.create();\n                vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);\n                const stLinePointOne = vec2.create();\n                vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n                const stLinePointTwo = vec2.create();\n                vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n                const stLinePointThree = vec2.create();\n                vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);\n                const stLinePointFour = vec2.create();\n                vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n                const stHandleOne = vec2.create();\n                const stHandleTwo = vec2.create();\n                const stHandleThree = vec2.create();\n                const stHandleFour = vec2.create();\n                vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n                vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointOne,\n                    refLinePointTwo,\n                    refLinePointThree,\n                    refLinePointFour,\n                    stLinePointOne,\n                    stLinePointTwo,\n                    stLinePointThree,\n                    stLinePointFour,\n                    rotHandleOne,\n                    rotHandleTwo,\n                    stHandleOne,\n                    stHandleTwo,\n                    stHandleThree,\n                    stHandleFour,\n                ]);\n            });\n            const newRtpoints = [];\n            const newStpoints = [];\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const otherViewport = line[0];\n                const viewportColor = this._getReferenceLineColor(otherViewport.id);\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                let lineWidth = 1;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = 2.5;\n                }\n                let lineUID = `${lineIndex}`;\n                if (viewportControllable && viewportDraggableRotatable) {\n                    lineUID = `${lineIndex}One`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {\n                        color,\n                        lineWidth,\n                    });\n                    lineUID = `${lineIndex}Two`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                else {\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                if (viewportControllable) {\n                    color =\n                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;\n                    const rotationHandles = [line[9], line[10]];\n                    const rotHandleWorldOne = [\n                        viewport.canvasToWorld(line[9]),\n                        otherViewport,\n                        line[1],\n                        line[2],\n                    ];\n                    const rotHandleWorldTwo = [\n                        viewport.canvasToWorld(line[10]),\n                        otherViewport,\n                        line[3],\n                        line[4],\n                    ];\n                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;\n                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n                    const slabThicknessHandleWorldOne = [\n                        viewport.canvasToWorld(line[11]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldTwo = [\n                        viewport.canvasToWorld(line[12]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldThree = [\n                        viewport.canvasToWorld(line[13]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    const slabThicknessHandleWorldFour = [\n                        viewport.canvasToWorld(line[14]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);\n                    if ((lineActive || this.configuration.mobile?.enabled) &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable &&\n                        viewportSlabThicknessControlsOn) {\n                        let handleUID = `${lineIndex}One`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'circle',\n                        });\n                        handleUID = `${lineIndex}Two`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'rect',\n                        });\n                    }\n                    else if (lineActive &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'circle',\n                        });\n                    }\n                    else if (selectedViewportId &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.handleRadius\n                                : 3,\n                            opacity: this.configuration.mobile?.enabled\n                                ? this.configuration.mobile?.opacity\n                                : 1,\n                            type: 'rect',\n                        });\n                    }\n                    else if (rotHandlesActive && viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius: 2,\n                            fill: color,\n                            type: 'circle',\n                        });\n                    }\n                    else if (slabThicknessHandlesActive &&\n                        selectedViewportId &&\n                        viewportSlabThicknessControlsOn) {\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {\n                            color,\n                            handleRadius: 2,\n                            fill: color,\n                            type: 'rect',\n                        });\n                    }\n                    const slabThicknessValue = otherViewport.getSlabThickness();\n                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n                        lineUID = `${lineIndex}STOne`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {\n                            color,\n                            width: 1,\n                            lineDash: [2, 3],\n                        });\n                        lineUID = `${lineIndex}STTwo`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {\n                            color,\n                            width: line,\n                            lineDash: [2, 3],\n                        });\n                    }\n                }\n            });\n            renderStatus = true;\n            data.handles.rotationPoints = newRtpoints;\n            data.handles.slabThicknessPoints = newStpoints;\n            if (this.configuration.viewportIndicators) {\n                const referenceColorCoordinates = [\n                    clientWidth * 0.95,\n                    clientHeight * 0.05,\n                ];\n                const circleRadius = canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            return getAnnotations(this.getToolName(), viewport.element);\n        };\n        this._onNewVolume = (e) => {\n            const viewportsInfo = this._getViewportsInfo();\n            this.computeToolCenter(viewportsInfo);\n        };\n        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n                return false;\n            }\n            viewportIdArrayOne.forEach((id) => {\n                let itemFound = false;\n                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n                    if (id === viewportIdArrayTwo[i]) {\n                        itemFound = true;\n                        break;\n                    }\n                }\n                if (itemFound === false) {\n                    return false;\n                }\n            });\n            return true;\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {\n            const { renderingEngine, viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable === true);\n            });\n            const otherViewportsAnnotationsWithUniqueCameras = [];\n            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable !== true);\n            });\n            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n                const annotation = otherViewportAnnotations[i];\n                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {\n                    continue;\n                }\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            return otherViewportsAnnotationsWithUniqueCameras;\n        };\n        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n            const actors = viewport.getActors();\n            const otherViewportActors = otherViewport.getActors();\n            let sameScene = true;\n            actors.forEach((actor) => {\n                if (actors.length !== otherViewportActors.length ||\n                    otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined) {\n                    sameScene = false;\n                }\n            });\n            return sameScene;\n        };\n        this._jump = (enabledElement, jumpWorld) => {\n            state.isInteractingWithTool = true;\n            const { viewport, renderingEngine } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const delta = [0, 0, 0];\n            vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);\n                return (this._getReferenceLineControllable(otherViewport.id) &&\n                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n                    sameScene);\n            });\n            if (viewportsAnnotationsToUpdate.length === 0) {\n                state.isInteractingWithTool = false;\n                return false;\n            }\n            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            state.isInteractingWithTool = false;\n            return true;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            const { currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            }\n            else if (handles.activeOperation === OPERATION.ROTATE) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true);\n                });\n                const dir1 = vec2.create();\n                const dir2 = vec2.create();\n                const center = [\n                    this.toolCenter[0],\n                    this.toolCenter[1],\n                    this.toolCenter[2],\n                ];\n                const centerCanvas = viewport.worldToCanvas(center);\n                const finalPointCanvas = eventDetail.currentPoints.canvas;\n                const originalPointCanvas = vec2.create();\n                vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);\n                vec2.sub(dir1, originalPointCanvas, centerCanvas);\n                vec2.sub(dir2, finalPointCanvas, centerCanvas);\n                let angle = vec2.angle(dir1, dir2);\n                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {\n                    angle *= -1;\n                }\n                angle = Math.round(angle * 100) / 100;\n                const rotationAxis = viewport.getCamera().viewPlaneNormal;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(center[0], center[1], center[2])\n                    .rotate(angle, rotationAxis)\n                    .translate(-center[0], -center[1], -center[2]);\n                const otherViewportsIds = [];\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    data.handles.toolCenter = center;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const { viewUp, position, focalPoint } = camera;\n                    viewUp[0] += position[0];\n                    viewUp[1] += position[1];\n                    viewUp[2] += position[2];\n                    vec3.transformMat4(focalPoint, focalPoint, matrix);\n                    vec3.transformMat4(position, position, matrix);\n                    vec3.transformMat4(viewUp, viewUp, matrix);\n                    viewUp[0] -= position[0];\n                    viewUp[1] -= position[1];\n                    viewUp[2] -= position[2];\n                    otherViewport.setCamera({\n                        position,\n                        viewUp,\n                        focalPoint,\n                    });\n                    otherViewportsIds.push(otherViewport.id);\n                });\n                renderingEngine.renderViewports(otherViewportsIds);\n            }\n            else if (handles.activeOperation === OPERATION.SLAB) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportSlabThicknessControlsOn === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                if (referenceAnnotations.length === 0) {\n                    return;\n                }\n                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);\n                const viewportsIds = [];\n                viewportsIds.push(viewport.id);\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const normal = camera.viewPlaneNormal;\n                    const dotProd = vtkMath.dot(delta, normal);\n                    const projectedDelta = [...normal];\n                    vtkMath.multiplyScalar(projectedDelta, dotProd);\n                    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n                        Math.abs(projectedDelta[1]) > 1e-3 ||\n                        Math.abs(projectedDelta[2]) > 1e-3) {\n                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +\n                            projectedDelta[1] * projectedDelta[1] +\n                            projectedDelta[2] * projectedDelta[2]);\n                        const currentPoint = eventDetail.lastPoints.world;\n                        const direction = [0, 0, 0];\n                        const currentCenter = [\n                            this.toolCenter[0],\n                            this.toolCenter[1],\n                            this.toolCenter[2],\n                        ];\n                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                        if (!viewportDraggableRotatable) {\n                            const { rotationPoints } = this.editData.annotation.data.handles;\n                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);\n                            if (otherViewportRotationPoints.length === 2) {\n                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);\n                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);\n                                vtkMath.add(point1, point2, currentCenter);\n                                vtkMath.multiplyScalar(currentCenter, 0.5);\n                            }\n                        }\n                        vtkMath.subtract(currentPoint, currentCenter, direction);\n                        const dotProdDirection = vtkMath.dot(direction, normal);\n                        const projectedDirection = [...normal];\n                        vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n                        const normalizedProjectedDirection = [\n                            projectedDirection[0],\n                            projectedDirection[1],\n                            projectedDirection[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);\n                        const normalizedProjectedDelta = [\n                            projectedDelta[0],\n                            projectedDelta[1],\n                            projectedDelta[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n                        let slabThicknessValue = otherViewport.getSlabThickness();\n                        if (csUtils.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {\n                            slabThicknessValue -= mod;\n                        }\n                        else {\n                            slabThicknessValue += mod;\n                        }\n                        slabThicknessValue = Math.abs(slabThicknessValue);\n                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);\n                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);\n                        if (near) {\n                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n                        }\n                        const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);\n                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());\n                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);\n                        viewportsIds.push(otherViewport.id);\n                    }\n                });\n                renderingEngine.renderViewports(viewportsIds);\n            }\n        };\n        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {\n            const { data } = annotation;\n            const { rotationPoints } = data.handles;\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                if (otherViewport.id !== lineViewport.id) {\n                    continue;\n                }\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                if (!viewportControllable) {\n                    continue;\n                }\n                const lineSegment1 = {\n                    start: {\n                        x: rotationPoints[i][2][0],\n                        y: rotationPoints[i][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i][3][0],\n                        y: rotationPoints[i][3][1],\n                    },\n                };\n                const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n                const lineSegment2 = {\n                    start: {\n                        x: rotationPoints[i + 1][2][0],\n                        y: rotationPoints[i + 1][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i + 1][3][0],\n                        y: rotationPoints[i + 1][3][1],\n                    },\n                };\n                const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                    return true;\n                }\n                i++;\n            }\n            return false;\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        this._getReferenceLineDraggableRotatable =\n            toolProps.configuration?.getReferenceLineDraggableRotatable ||\n                defaultReferenceLineDraggableRotatable;\n        this._getReferenceLineSlabThicknessControlsOn =\n            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n                defaultReferenceLineSlabThicknessControlsOn;\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        this._subscribeToViewportNewVolumeSet(viewportsInfo);\n        this.computeToolCenter(viewportsInfo);\n    }\n    onSetToolPassive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this.computeToolCenter(viewportsInfo);\n    }\n    onSetToolEnabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this.computeToolCenter(viewportsInfo);\n    }\n    onSetToolDisabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _autoPanViewportIfNecessary(viewportId, renderingEngine) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n        const pan = this.configuration.autoPan.panSize;\n        const visiblePointCanvas = [\n            toolCenterCanvas[0],\n            toolCenterCanvas[1],\n        ];\n        if (toolCenterCanvas[0] < 0) {\n            visiblePointCanvas[0] = pan;\n        }\n        else if (toolCenterCanvas[0] > clientWidth) {\n            visiblePointCanvas[0] = clientWidth - pan;\n        }\n        if (toolCenterCanvas[1] < 0) {\n            visiblePointCanvas[1] = pan;\n        }\n        else if (toolCenterCanvas[1] > clientHeight) {\n            visiblePointCanvas[1] = clientHeight - pan;\n        }\n        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&\n            visiblePointCanvas[1] === toolCenterCanvas[1]) {\n            return;\n        }\n        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n        const deltaPointsWorld = [\n            visiblePointWorld[0] - this.toolCenter[0],\n            visiblePointWorld[1] - this.toolCenter[1],\n            visiblePointWorld[2] - this.toolCenter[2],\n        ];\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n    setSlabThickness(viewport, slabThickness) {\n        let actorUIDs;\n        const { filterActorUIDsToSetSlabThickness } = this.configuration;\n        if (filterActorUIDsToSetSlabThickness &&\n            filterActorUIDsToSetSlabThickness.length > 0) {\n            actorUIDs = filterActorUIDsToSetSlabThickness;\n        }\n        let blendModeToUse = this.configuration.slabThicknessBlendMode;\n        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n            blendModeToUse = Enums.BlendModes.COMPOSITE;\n        }\n        const immediate = false;\n        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n        viewport.setSlabThickness(slabThickness, actorUIDs);\n    }\n    _isClockWise(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        for (let i = 0; i < rotationPoints.length; i++) {\n            const point = rotationPoints[i][0];\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.ROTATE;\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { slabThicknessPoints } = data.handles;\n        for (let i = 0; i < slabThicknessPoints.length; i++) {\n            const point = slabThicknessPoints[i][0];\n            const otherViewport = slabThicknessPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.SLAB;\n                data.activeViewportIds = [otherViewport.id];\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        const { slabThicknessPoints } = data.handles;\n        const viewportIdArray = [];\n        for (let i = 0; i < rotationPoints.length - 1; ++i) {\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportControllable || !viewportDraggableRotatable) {\n                continue;\n            }\n            const lineSegment1 = {\n                start: {\n                    x: rotationPoints[i][2][0],\n                    y: rotationPoints[i][2][1],\n                },\n                end: {\n                    x: rotationPoints[i][3][0],\n                    y: rotationPoints[i][3][1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: rotationPoints[i + 1][2][0],\n                    y: rotationPoints[i + 1][2][1],\n                },\n                end: {\n                    x: rotationPoints[i + 1][3][0],\n                    y: rotationPoints[i + 1][3][1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = OPERATION.DRAG;\n            }\n            i++;\n        }\n        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n            const otherViewport = slabThicknessPoints[i][1];\n            if (viewportIdArray.find((id) => id === otherViewport.id)) {\n                continue;\n            }\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const stPointLineCanvas1 = slabThicknessPoints[i][2];\n            const stPointLineCanvas2 = slabThicknessPoints[i][3];\n            const centerCanvas = vec2.create();\n            vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n            vec2.scale(centerCanvas, centerCanvas, 0.5);\n            const canvasUnitVectorFromCenter = vec2.create();\n            vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);\n            vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n            const canvasVectorFromCenterStart = vec2.create();\n            vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);\n            const stPointLineCanvas1Start = vec2.create();\n            const stPointLineCanvas2Start = vec2.create();\n            vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);\n            vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);\n            const lineSegment1 = {\n                start: {\n                    x: stPointLineCanvas1Start[0],\n                    y: stPointLineCanvas1Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas1[0],\n                    y: stPointLineCanvas1[1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: stPointLineCanvas2Start[0],\n                    y: stPointLineCanvas2Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas2[0],\n                    y: stPointLineCanvas2[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = null;\n            }\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n    }\n}\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n//# sourceMappingURL=CrosshairsTool.js.map","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nclass MIPJumpToClickTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            targetViewportIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseClickCallback(evt) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const targetId = this.getTargetId(viewport);\n        if (!targetId.startsWith('volumeId')) {\n            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);\n        }\n        const volumeId = targetId.split('volumeId:')[1];\n        let maxIntensity = -Infinity;\n        const maxFn = (intensity, point) => {\n            if (intensity > maxIntensity) {\n                maxIntensity = intensity;\n                return point;\n            }\n        };\n        const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);\n        if (!brightestPoint || !brightestPoint.length) {\n            return;\n        }\n        const { targetViewportIds } = this.configuration;\n        targetViewportIds.forEach((viewportId) => {\n            const viewport = renderingEngine.getViewport(viewportId);\n            if (viewport instanceof VolumeViewport) {\n                jumpToWorld(viewport, brightestPoint);\n            }\n            else {\n                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');\n            }\n        });\n    }\n}\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n//# sourceMappingURL=MIPJumpToClickTool.js.map","import { BaseTool } from './base';\nimport { Events } from '../enums';\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\nclass MagnifyTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            magnifySize: 10,\n            magnifyWidth: 250,\n            magnifyHeight: 250,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('MagnifyTool only works on StackViewports');\n            }\n            const referencedImageId = this._getReferencedImageId(viewport);\n            if (!referencedImageId) {\n                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                referencedImageId,\n                viewportIdsToRender,\n                enabledElement,\n                renderingEngine,\n                currentPoints,\n            };\n            this._createMagnificationViewport();\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return true;\n        };\n        this.preTouchStartCallback = (evt) => {\n            this.preMouseDownCallback(evt);\n        };\n        this._createMagnificationViewport = () => {\n            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const { voiRange } = viewport.getProperties();\n            const { canvas: canvasPos, world: worldPos } = currentPoints;\n            let magnifyToolElement;\n            magnifyToolElement = element.querySelector('.magnifyTool');\n            if (magnifyToolElement === null) {\n                const magnifyElement = document.createElement('div');\n                magnifyElement.classList.add('magnifyTool');\n                magnifyElement.style.display = 'block';\n                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n                magnifyElement.style.position = 'absolute';\n                magnifyToolElement = magnifyElement;\n                const viewportElement = element.querySelector('.viewport-element');\n                viewportElement.appendChild(magnifyElement);\n                const viewportInput = {\n                    viewportId: MAGNIFY_VIEWPORT_ID,\n                    type: Enums.ViewportType.STACK,\n                    element: magnifyToolElement,\n                };\n                renderingEngine.enableElement(viewportInput);\n            }\n            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            magnifyViewport.setStack([referencedImageId]).then(() => {\n                magnifyViewport.setProperties({ voiRange });\n                const { parallelScale } = viewport.getCamera();\n                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n                    Math.pow(focalPoint[1] - position[1], 2) +\n                    Math.pow(focalPoint[2] - position[2], 2));\n                const updatedFocalPoint = [\n                    worldPos[0],\n                    worldPos[1],\n                    worldPos[2],\n                ];\n                const updatedPosition = [\n                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n                ];\n                magnifyViewport.setCamera({\n                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n                    focalPoint: updatedFocalPoint,\n                    position: updatedPosition,\n                });\n                magnifyViewport.render();\n            });\n            magnifyToolElement.style.display = 'block';\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { deltaPoints, element, currentPoints } = eventDetail;\n            const deltaPointsWorld = deltaPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            const magnifyElement = element.querySelector('.magnifyTool');\n            if (!magnifyElement) {\n                return;\n            }\n            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const { focalPoint, position } = magnifyViewport.getCamera();\n            const updatedPosition = [\n                position[0] + deltaPointsWorld[0],\n                position[1] + deltaPointsWorld[1],\n                position[2] + deltaPointsWorld[2],\n            ];\n            const updatedFocalPoint = [\n                focalPoint[0] + deltaPointsWorld[0],\n                focalPoint[1] + deltaPointsWorld[1],\n                focalPoint[2] + deltaPointsWorld[2],\n            ];\n            magnifyViewport.setCamera({\n                focalPoint: updatedFocalPoint,\n                position: updatedPosition,\n            });\n            magnifyViewport.render();\n        };\n        this._dragEndCallback = (evt) => {\n            const { element } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n            const viewportElement = element.querySelector('.viewport-element');\n            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');\n            viewportElement.removeChild(magnifyToolElement);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n    }\n    _getReferencedImageId(viewport) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        return referencedImageId;\n    }\n}\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n//# sourceMappingURL=MagnifyTool.js.map","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nclass PanTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nPanTool.toolName = 'Pan';\nexport default PanTool;\n//# sourceMappingURL=PanTool.js.map","import { BaseVolumeViewport, getEnabledElement, } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nclass PlanarRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, startPoints } = evt.detail;\n        const currentPointWorld = currentPoints.world;\n        const startPointWorld = startPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const centerCanvas = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(centerCanvas);\n        let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);\n        const { viewPlaneNormal, viewUp } = camera;\n        const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n        const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n        const cross = vec3.cross(vec3.create(), v1, v2);\n        if (vec3.dot(viewPlaneNormal, cross) > 0) {\n            angle = -angle;\n        }\n        if (Number.isNaN(angle))\n            return;\n        if (viewport instanceof BaseVolumeViewport) {\n            const rotAngle = (angle * Math.PI) / 180;\n            const rotMat = mat4.identity(new Float32Array(16));\n            mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n            const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n            viewport.setCamera({ viewUp: rotatedViewUp });\n        }\n        else {\n            const { rotation } = viewport.getProperties();\n            viewport.setProperties({ rotation: rotation + angle });\n        }\n        viewport.render();\n    }\n}\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n//# sourceMappingURL=PlanarRotateTool.js.map","import { getEnabledElement, StackViewport, VolumeViewport, utilities, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass ReferenceCursors extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            displayThreshold: 5,\n            positionSync: true,\n            disableCursor: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isHandleOutsideImage = false;\n        this._elementWithCursor = null;\n        this._currentCursorWorldPosition = null;\n        this._currentCanvasPosition = null;\n        this._disableCursorEnabled = false;\n        this.mouseMoveCallback = (evt) => {\n            const { detail } = evt;\n            const { element, currentPoints } = detail;\n            this._currentCursorWorldPosition = currentPoints.world;\n            this._currentCanvasPosition = currentPoints.canvas;\n            this._elementWithCursor = element;\n            const annotation = this.getActiveAnnotation(element);\n            if (annotation === null) {\n                this.createInitialAnnotation(currentPoints.world, element);\n                return false;\n            }\n            this.updateAnnotationPosition(element, annotation);\n            return false;\n        };\n        this.createInitialAnnotation = (worldPos, element) => {\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement)\n                throw new Error('No enabled element found');\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            if (!viewPlaneNormal || !viewUp)\n                throw new Error('Camera not found');\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            };\n            const annotations = getAnnotations(this.getToolName(), element);\n            if (annotations.length > 0)\n                return null;\n            const annotationId = addAnnotation(annotation, element);\n            if (annotationId === null)\n                return;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, previousCamera, camera } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const viewport = enabledElement.viewport;\n            if (element !== this._elementWithCursor)\n                return;\n            const oldFocalPoint = previousCamera.focalPoint;\n            const cameraNormal = camera.viewPlaneNormal;\n            const newFocalPoint = camera.focalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0)\n                return;\n            const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n            if (Math.abs(dotProduct) < 1e-2)\n                return;\n            if (!this._currentCanvasPosition)\n                return;\n            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n            this._currentCursorWorldPosition = newWorldPos;\n            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            const isElementWithCursor = this._elementWithCursor === viewport.element;\n            if (this.configuration.positionSync && !isElementWithCursor) {\n                this.updateViewportImage(viewport);\n            }\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                if (!annotationUID)\n                    return renderStatus;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));\n                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor\n                    ? lineWidthBase\n                    : lineWidthBase;\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (points[0].some((e) => isNaN(e)))\n                    return renderStatus;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const crosshairUIDs = {\n                    upper: 'upper',\n                    right: 'right',\n                    lower: 'lower',\n                    left: 'left',\n                };\n                const [x, y] = canvasCoordinates[0];\n                const centerSpace = isElementWithCursor ? 20 : 7;\n                const lineLength = isElementWithCursor ? 5 : 7;\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._disableCursorEnabled = this.configuration.disableCursor;\n    }\n    onSetToolActive() {\n        this._disableCursorEnabled = this.configuration.disableCursor;\n        if (!this._disableCursorEnabled)\n            return;\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds)\n            return;\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element)\n                hideElementCursor(element.viewport.element);\n        });\n    }\n    onSetToolDisabled() {\n        if (!this._disableCursorEnabled)\n            return;\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds)\n            return;\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element)\n                resetElementCursor(element.viewport.element);\n        });\n    }\n    getActiveAnnotation(element) {\n        const annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations.length) {\n            return null;\n        }\n        const targetAnnotation = annotations[0];\n        return targetAnnotation;\n    }\n    updateAnnotationPosition(element, annotation) {\n        const worldPos = this._currentCursorWorldPosition;\n        if (!worldPos)\n            return;\n        if (!annotation.data?.handles?.points)\n            return;\n        annotation.data.handles.points = [[...worldPos]];\n        annotation.invalidated = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement)\n            return;\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!(annotations instanceof Array) || annotations.length === 0)\n            return [];\n        const annotation = annotations[0];\n        const viewport = getEnabledElement(element)?.viewport;\n        if (!viewport)\n            return [];\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, focalPoint } = camera;\n        if (!viewPlaneNormal || !focalPoint)\n            return [];\n        const points = annotation.data?.handles?.points;\n        if (!(points instanceof Array) || points.length !== 1)\n            return [];\n        const worldPos = points[0];\n        const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n        const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n        return distance < this.configuration.displayThreshold ? [annotation] : [];\n    }\n    updateViewportImage(viewport) {\n        const currentMousePosition = this._currentCursorWorldPosition;\n        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e)))\n            return;\n        if (viewport instanceof StackViewport) {\n            const closestIndex = utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);\n            if (closestIndex === null)\n                return;\n            if (closestIndex !== viewport.getCurrentImageIdIndex())\n                viewport.setImageIdIndex(closestIndex);\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n            if (!focalPoint || !viewPlaneNormal)\n                return;\n            const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const currentDistance = utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);\n            if (Math.abs(currentDistance) < 0.5)\n                return;\n            const normalizedViewPlane = vec3.normalize(vec3.create(), vec3.fromValues(...viewPlaneNormal));\n            const scaledPlaneNormal = vec3.scale(vec3.create(), normalizedViewPlane, currentDistance);\n            const newFocalPoint = vec3.add(vec3.create(), vec3.fromValues(...focalPoint), scaledPlaneNormal);\n            const isInBounds = true;\n            if (isInBounds) {\n                viewport.setCamera({ focalPoint: newFocalPoint });\n                const renderingEngine = viewport.getRenderingEngine();\n                if (renderingEngine)\n                    renderingEngine.renderViewport(viewport.id);\n            }\n        }\n    }\n}\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n//# sourceMappingURL=ReferenceCursors.js.map","import { vec3 } from 'gl-matrix';\nimport { getRenderingEngines, CONSTANTS, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass ReferenceLines extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceViewportId: '',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = {};\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            let viewports = renderingEngine.getViewports();\n            viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);\n            if (!sourceViewport || !sourceViewport.getImageData()) {\n                return;\n            }\n            const { element } = sourceViewport;\n            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n            const sourceViewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(sourceViewport);\n            let annotation = this.editData.annotation;\n            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n            if (!annotation) {\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: sourceViewportCanvasCornersInWorld,\n                        },\n                    },\n                };\n                addAnnotation(newAnnotation, element);\n                annotation = newAnnotation;\n            }\n            else {\n                this.editData.annotation.data.handles.points =\n                    sourceViewportCanvasCornersInWorld;\n            }\n            this.editData = {\n                sourceViewport,\n                renderingEngine,\n                annotation,\n            };\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewports\n                .filter((viewport) => viewport.id !== sourceViewport.id)\n                .map((viewport) => viewport.id));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport: targetViewport } = enabledElement;\n            const { annotation, sourceViewport } = this.editData;\n            let renderStatus = false;\n            if (!sourceViewport) {\n                return renderStatus;\n            }\n            if (sourceViewport.id === targetViewport.id) {\n                return renderStatus;\n            }\n            if (!annotation || !annotation?.data?.handles?.points) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const topLeft = annotation.data.handles.points[0];\n            const topRight = annotation.data.handles.points[1];\n            const bottomLeft = annotation.data.handles.points[2];\n            const bottomRight = annotation.data.handles.points[3];\n            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();\n            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            let pointSetToUse = pointSet1;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const newNormal = vec3.cross(vec3.create(), topBottomVec, topRightVec);\n            if (this.isParallel(newNormal, viewPlaneNormal)) {\n                return renderStatus;\n            }\n            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                pointSetToUse = pointSet2;\n            }\n            const lineStartWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n            const lineEndWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n            const { annotationUID } = annotation;\n            styleSpecifier.annotationUID = annotationUID;\n            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n            const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n            const dataId = `${annotationUID}-line`;\n            const lineUID = '1';\n            drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, dataId);\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n}\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n//# sourceMappingURL=ReferenceLinesTool.js.map","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport { getEnabledElementByIds, getRenderingEngines, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg, drawTextBox as drawTextBoxSvg, } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            viewportId: '',\n            scaleLocation: 'bottom',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = {};\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportIds)\n                return;\n            const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n            let { viewport } = enabledElements[0];\n            const { FrameOfReferenceUID } = enabledElements[0];\n            if (this.configuration.viewportId) {\n                enabledElements.forEach((element) => {\n                    if (element.viewport.id == this.configuration.viewportId) {\n                        viewport = element.viewport;\n                    }\n                });\n            }\n            if (!viewport) {\n                return;\n            }\n            const { viewUp, viewPlaneNormal } = viewport.getCamera();\n            const viewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(viewport);\n            let annotation = this.editData.annotation;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (annotations.length) {\n                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n            }\n            if (!viewportsWithAnnotations.includes(viewport.id)) {\n                const newAnnotation = {\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: viewportCanvasCornersInWorld,\n                        },\n                        viewportId: viewport.id,\n                    },\n                };\n                viewportsWithAnnotations.push(viewport.id);\n                addAnnotation(newAnnotation, viewport.element);\n                annotation = newAnnotation;\n            }\n            else if (this.editData.annotation.data.viewportId == viewport.id) {\n                this.editData.annotation.data.handles.points =\n                    viewportCanvasCornersInWorld;\n                this.editData.annotation.data.viewportId = viewport.id;\n            }\n            this.editData = {\n                viewport,\n                renderingEngine,\n                annotation,\n            };\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this.configuration.viewportId = evt.detail.viewportId;\n            this._init();\n        };\n        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {\n            const scaleSizes = [\n                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n            ];\n            let currentScaleSize;\n            if (location == 'top' || location == 'bottom') {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&\n                    scaleSize > worldWidthViewport * 0.2);\n            }\n            else {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&\n                    scaleSize > worldHeightViewport * 0.2);\n            }\n            return currentScaleSize[0];\n        };\n        this.computeEndScaleTicks = (canvasCoordinates, location) => {\n            const locationTickOffset = {\n                bottom: [\n                    [0, -10],\n                    [0, -10],\n                ],\n                top: [\n                    [0, 10],\n                    [0, 10],\n                ],\n                left: [\n                    [0, 0],\n                    [10, 0],\n                ],\n                right: [\n                    [0, 0],\n                    [-10, 0],\n                ],\n            };\n            const endTick1 = [\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            const endTick2 = [\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            return {\n                endTick1: endTick1,\n                endTick2: endTick2,\n            };\n        };\n        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {\n            let canvasScaleSize;\n            if (location == 'bottom' || location == 'top') {\n                canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n            }\n            else if (location == 'left' || location == 'right') {\n                canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n            }\n            const tickIds = [];\n            const tickUIDs = [];\n            const tickCoordinates = [];\n            let numberSmallTicks = scaleSize;\n            if (scaleSize >= 50) {\n                numberSmallTicks = scaleSize / 10;\n            }\n            const tickSpacing = canvasScaleSize / numberSmallTicks;\n            for (let i = 0; i < numberSmallTicks - 1; i++) {\n                const locationOffset = {\n                    bottom: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), 5],\n                    ],\n                    top: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), -5],\n                    ],\n                    left: [\n                        [0, tickSpacing * (i + 1)],\n                        [-5, tickSpacing * (i + 1)],\n                    ],\n                    right: [\n                        [0, tickSpacing * (i + 1)],\n                        [5, tickSpacing * (i + 1)],\n                    ],\n                };\n                tickIds.push(`${annotationUID}-tick${i}`);\n                tickUIDs.push(`tick${i}`);\n                if ((i + 1) % 5 == 0) {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][0][0],\n                            leftTick[1][1] + locationOffset[location][0][1],\n                        ],\n                    ]);\n                }\n                else {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][1][0],\n                            leftTick[1][1] + locationOffset[location][1][1],\n                        ],\n                    ]);\n                }\n            }\n            return { tickIds, tickUIDs, tickCoordinates };\n        };\n        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n            let worldCoordinates;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const midpointLocation = {\n                bottom: [pointSet[1], pointSet[2]],\n                top: [pointSet[0], pointSet[3]],\n                right: [pointSet[2], pointSet[3]],\n                left: [pointSet[0], pointSet[1]],\n            };\n            const midpoint = vec3\n                .add(vec3.create(), midpointLocation[location][0], midpointLocation[location][0])\n                .map((i) => i / 2);\n            const offset = scaleSize /\n                2 /\n                Math.sqrt(Math.pow(topBottomVec[0], 2) +\n                    Math.pow(topBottomVec[1], 2) +\n                    Math.pow(topBottomVec[2], 2));\n            if (location == 'top' || location == 'bottom') {\n                worldCoordinates = [\n                    vec3.subtract(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                    vec3.add(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                worldCoordinates = [\n                    vec3.add(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                    vec3.subtract(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                ];\n            }\n            return worldCoordinates;\n        };\n        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {\n            let scaleCanvasCoordinates;\n            if (location == 'top' || location == 'bottom') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];\n                scaleCanvasCoordinates = [\n                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];\n                scaleCanvasCoordinates = [\n                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n                ];\n            }\n            return scaleCanvasCoordinates;\n        };\n        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {\n            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n            const locationBounds = {\n                bottom: [-vReduction, -hReduction],\n                top: [vReduction, hReduction],\n                left: [vReduction, hReduction],\n                right: [-vReduction, -hReduction],\n            };\n            const canvasBounds = {\n                bottom: [canvasSize.height, canvasSize.width],\n                top: [0, canvasSize.width],\n                left: [canvasSize.height, 0],\n                right: [canvasSize.height, canvasSize.width],\n            };\n            return {\n                height: canvasBounds[location][0] + locationBounds[location][0],\n                width: canvasBounds[location][1] + locationBounds[location][1],\n            };\n        };\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.editData.viewport) {\n            return;\n        }\n        const location = this.configuration.scaleLocation;\n        const { viewport } = enabledElement;\n        const annotations = getAnnotations(this.getToolName(), viewport.element);\n        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n        const canvas = enabledElement.viewport.canvas;\n        const renderStatus = false;\n        if (!viewport) {\n            return renderStatus;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        const canvasSize = {\n            width: canvas.width,\n            height: canvas.height,\n        };\n        const topLeft = annotation.data.handles.points[0];\n        const topRight = annotation.data.handles.points[1];\n        const bottomLeft = annotation.data.handles.points[2];\n        const bottomRight = annotation.data.handles.points[3];\n        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n        const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n        const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);\n        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));\n        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);\n        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);\n        const { annotationUID } = annotation;\n        styleSpecifier.annotationUID = annotationUID;\n        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n        const color = this.getStyle('color', styleSpecifier, annotation);\n        const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n        const scaleId = `${annotationUID}-scaleline`;\n        const scaleLineUID = '1';\n        drawLineSvg(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, scaleId);\n        const leftTickId = `${annotationUID}-left`;\n        const leftTickUID = '2';\n        drawLineSvg(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, leftTickId);\n        const rightTickId = `${annotationUID}-right`;\n        const rightTickUID = '3';\n        drawLineSvg(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, rightTickId);\n        const locationTextOffest = {\n            bottom: [-10, -42],\n            top: [-12, -35],\n            left: [-40, -20],\n            right: [-50, -20],\n        };\n        const textCanvasCoordinates = [\n            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n        ];\n        const textBoxLines = this._getTextLines(scaleSize);\n        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);\n        for (let i = 0; i < tickUIDs.length; i++) {\n            drawLineSvg(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, tickIds[i]);\n        }\n        const textUID = 'text0';\n        drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {\n            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            fontSize: '14px',\n            lineDash: '2,3',\n            lineWidth: '1',\n            shadow: true,\n            color: color,\n        });\n        return renderStatus;\n    }\n    _getTextLines(scaleSize) {\n        let scaleSizeDisplayValue;\n        let scaleSizeUnits;\n        if (scaleSize >= 50) {\n            scaleSizeDisplayValue = scaleSize / 10;\n            scaleSizeUnits = ' cm';\n        }\n        else {\n            scaleSizeDisplayValue = scaleSize;\n            scaleSizeUnits = ' mm';\n        }\n        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n        return textLines;\n    }\n}\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n//# sourceMappingURL=ScaleOverlayTool.js.map","import { getEnabledElementByIds, VolumeViewport, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nclass StackScrollTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.deltaY = 1;\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        const targetId = this.getTargetId(viewport);\n        const { debounceIfNotLoaded, invert, loop } = this.configuration;\n        const deltaPointY = deltaPoints.canvas[1];\n        let volumeId;\n        if (viewport instanceof VolumeViewport) {\n            volumeId = targetId.split('volumeId:')[1];\n        }\n        const pixelsPerImage = this._getPixelPerImage(viewport);\n        const deltaY = deltaPointY + this.deltaY;\n        if (!pixelsPerImage) {\n            return;\n        }\n        if (Math.abs(deltaY) >= pixelsPerImage) {\n            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n            scroll(viewport, {\n                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n                volumeId,\n                debounceLoading: debounceIfNotLoaded,\n                loop: loop,\n            });\n            this.deltaY = deltaY % pixelsPerImage;\n        }\n        else {\n            this.deltaY = deltaY;\n        }\n    }\n    _getPixelPerImage(viewport) {\n        const { element } = viewport;\n        const numberOfSlices = this._getNumberOfSlices(viewport);\n        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n    }\n    _getNumberOfSlices(viewport) {\n        if (viewport instanceof VolumeViewport) {\n            const { numberOfSlices } = csUtils.getImageSliceDataForVolumeViewport(viewport);\n            return numberOfSlices;\n        }\n        else if (viewport instanceof StackViewport) {\n            return viewport.getImageIds().length;\n        }\n    }\n}\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n//# sourceMappingURL=StackScrollTool.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport scroll from '../utilities/scroll';\nclass StackScrollMouseWheelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { wheel, element } = evt.detail;\n        const { direction } = wheel;\n        const { invert } = this.configuration;\n        const { viewport } = getEnabledElement(element);\n        const delta = direction * (invert ? -1 : 1);\n        const targetId = this.getTargetId(viewport);\n        const volumeId = targetId.split('volumeId:')[1];\n        scroll(viewport, {\n            delta,\n            debounceLoading: this.configuration.debounceIfNotLoaded,\n            loop: this.configuration.loop,\n            volumeId,\n        });\n    }\n}\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n//# sourceMappingURL=StackScrollToolMouseWheelTool.js.map","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nclass TrackballRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            rotateIncrementDegrees: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        const currentPointsCanvas = currentPoints.canvas;\n        const lastPointsCanvas = lastPoints.canvas;\n        const { rotateIncrementDegrees } = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const normalizedPosition = [\n            currentPointsCanvas[0] / width,\n            currentPointsCanvas[1] / height,\n        ];\n        const normalizedPreviousPosition = [\n            lastPointsCanvas[0] / width,\n            lastPointsCanvas[1] / height,\n        ];\n        const center = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(center);\n        const normalizedCenter = [0.5, 0.5];\n        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n        const op = [normalizedPreviousPosition[0], 0, 0];\n        const oe = [normalizedPosition[0], 0, 0];\n        const opsq = op[0] ** 2;\n        const oesq = oe[0] ** 2;\n        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n        const nop = [op[0], 0, lop];\n        vtkMath.normalize(nop);\n        const noe = [oe[0], 0, loe];\n        vtkMath.normalize(noe);\n        const dot = vtkMath.dot(nop, noe);\n        if (Math.abs(dot) > 0.0001) {\n            const angleX = -2 *\n                Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                rotateIncrementDegrees;\n            const upVec = camera.viewUp;\n            const atV = camera.viewPlaneNormal;\n            const rightV = [0, 0, 0];\n            const forwardV = [0, 0, 0];\n            vtkMath.cross(upVec, atV, rightV);\n            vtkMath.normalize(rightV);\n            vtkMath.cross(atV, rightV, forwardV);\n            vtkMath.normalize(forwardV);\n            vtkMath.normalize(upVec);\n            this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                rotateIncrementDegrees;\n            this.rotateCamera(viewport, centerWorld, rightV, angleY);\n            viewport.render();\n        }\n    }\n}\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n//# sourceMappingURL=TrackballRotateTool.js.map","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nconst DIRECTIONS = {\n    X: [1, 0, 0],\n    Y: [0, 1, 0],\n    Z: [0, 0, 1],\n    CUSTOM: [],\n};\nclass VolumeRotateMouseWheelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            direction: DIRECTIONS.Z,\n            rotateIncrementDegrees: 0.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { element, wheel } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { direction, rotateIncrementDegrees } = this.configuration;\n        const camera = viewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n        const { direction: deltaY } = wheel;\n        const [cx, cy, cz] = focalPoint;\n        const [ax, ay, az] = direction;\n        const angle = deltaY * rotateIncrementDegrees;\n        const newPosition = [0, 0, 0];\n        const newFocalPoint = [0, 0, 0];\n        const newViewUp = [0, 0, 0];\n        const transform = mat4.identity(new Float32Array(16));\n        mat4.translate(transform, transform, [cx, cy, cz]);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        mat4.translate(transform, transform, [-cx, -cy, -cz]);\n        vec3.transformMat4(newPosition, position, transform);\n        vec3.transformMat4(newFocalPoint, focalPoint, transform);\n        mat4.identity(transform);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        vec3.transformMat4(newViewUp, viewUp, transform);\n        viewport.setCamera({\n            position: newPosition,\n            viewUp: newViewUp,\n            focalPoint: newFocalPoint,\n        });\n        viewport.render();\n    }\n}\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n//# sourceMappingURL=VolumeRotateMouseWheelTool.js.map","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport, StackViewport, utilities, cache, } from '@cornerstonejs/core';\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\nclass WindowLevelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n            const middleSliceIndex = Math.floor(dimensions[2] / 2);\n            const frameLength = dimensions[0] * dimensions[1];\n            let bytesPerVoxel;\n            let TypedArrayConstructor;\n            if (scalarData instanceof Float32Array) {\n                bytesPerVoxel = 4;\n                TypedArrayConstructor = Float32Array;\n            }\n            else if (scalarData instanceof Uint8Array) {\n                bytesPerVoxel = 1;\n                TypedArrayConstructor = Uint8Array;\n            }\n            else if (scalarData instanceof Uint16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Uint16Array;\n            }\n            else if (scalarData instanceof Int16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Int16Array;\n            }\n            const buffer = scalarData.buffer;\n            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n            const { max, min } = this._getMinMax(frame, frameLength);\n            return max - min;\n        };\n    }\n    touchDragCallback(evt) {\n        this.mouseDragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;\n        let isPreScaled = false;\n        if (viewport instanceof VolumeViewport) {\n            const targetId = this.getTargetId(viewport);\n            volumeId = targetId.split('volumeId:')[1];\n            viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(volumeId, renderingEngine.id);\n            const properties = viewport.getProperties();\n            ({ lower, upper } = properties.voiRange);\n            const volume = cache.getVolume(volumeId);\n            modality = volume.metadata.Modality;\n            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n        }\n        else if (viewport instanceof StackViewport) {\n            const properties = viewport.getProperties();\n            modality = viewport.modality;\n            ({ lower, upper } = properties.voiRange);\n            const { preScale } = viewport.getImageData();\n            isPreScaled =\n                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n        if (modality === PT) {\n            newRange = this.getPTScaledNewRange({\n                deltaPointsCanvas: deltaPoints.canvas,\n                lower,\n                upper,\n                clientHeight: element.clientHeight,\n                isPreScaled,\n                viewport,\n                volumeId,\n            });\n        }\n        else {\n            newRange = this.getNewRange({\n                viewport,\n                deltaPointsCanvas: deltaPoints.canvas,\n                volumeId,\n                lower,\n                upper,\n            });\n        }\n        if (viewport instanceof StackViewport) {\n            viewport.setProperties({\n                voiRange: newRange,\n            });\n            viewport.render();\n            return;\n        }\n        if (viewport instanceof VolumeViewport) {\n            viewport.setProperties({\n                voiRange: newRange,\n            });\n            viewportsContainingVolumeUID.forEach((vp) => {\n                vp.render();\n            });\n            return;\n        }\n    }\n    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (isPreScaled) {\n            multiplier = 5 / clientHeight;\n        }\n        else {\n            multiplier =\n                this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n                    DEFAULT_MULTIPLIER;\n        }\n        const deltaY = deltaPointsCanvas[1];\n        const wcDelta = deltaY * multiplier;\n        upper -= wcDelta;\n        upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n        return { lower, upper };\n    }\n    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n            DEFAULT_MULTIPLIER;\n        const wwDelta = deltaPointsCanvas[0] * multiplier;\n        const wcDelta = deltaPointsCanvas[1] * multiplier;\n        let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n        windowWidth += wwDelta;\n        windowCenter += wcDelta;\n        windowWidth = Math.max(windowWidth, 1);\n        return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n    }\n    _getMultiplierFromDynamicRange(viewport, volumeId) {\n        let imageDynamicRange;\n        if (volumeId) {\n            const imageVolume = cache.getVolume(volumeId);\n            const { dimensions } = imageVolume;\n            const scalarData = imageVolume.getScalarData();\n            const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n            const BitsStored = imageVolume?.metadata?.BitsStored;\n            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n            imageDynamicRange = Math.min(calculatedDynamicRange, metadataDynamicRange);\n        }\n        else {\n            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n        }\n        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (ratio > 1) {\n            multiplier = Math.round(ratio);\n        }\n        return multiplier;\n    }\n    _getImageDynamicRangeFromViewport(viewport) {\n        const { imageData } = viewport.getImageData();\n        const dimensions = imageData.getDimensions();\n        let scalarData;\n        if (imageData.getScalarData) {\n            scalarData = imageData.getScalarData();\n        }\n        else {\n            scalarData = imageData.getPointData().getScalars();\n        }\n        if (dimensions[2] !== 1) {\n            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n        }\n        let range;\n        if (scalarData.getRange) {\n            range = scalarData.getRange();\n        }\n        else {\n            const { min, max } = this._getMinMax(scalarData, scalarData.length);\n            range = [min, max];\n        }\n        return range[1] - range[0];\n    }\n    _getMinMax(frame, frameLength) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (let i = 0; i < frameLength; i++) {\n            const voxel = frame[i];\n            if (voxel < min) {\n                min = voxel;\n            }\n            if (voxel > max) {\n                max = voxel;\n            }\n        }\n        return { max, min };\n    }\n}\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n//# sourceMappingURL=WindowLevelTool.js.map","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass ZoomTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            zoomToCenter: false,\n            minZoomScale: 0.1,\n            maxZoomScale: 30,\n            pinchToZoom: true,\n            pan: true,\n            invert: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const camera = enabledElement.viewport.getCamera();\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            return false;\n        };\n        this.preTouchStartCallback = (evt) => {\n            if (!this.configuration.pinchToZoom) {\n                return this.preMouseDownCallback(evt);\n            }\n        };\n        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { parallelScale, focalPoint, position } = camera;\n            const zoomScale = 1.5 / size[1];\n            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n            let parallelScaleToSet = (1.0 - k) * parallelScale;\n            let focalPointToSet = focalPoint;\n            let positionToSet = position;\n            if (!this.configuration.zoomToCenter) {\n                const distanceToCanvasCenter = vec3.distance(focalPoint, this.initialMousePosWorld);\n                const zoomScale = 5 / size[1];\n                const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n                parallelScaleToSet = (1.0 - k) * parallelScale;\n                positionToSet = vec3.scaleAndAdd(vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);\n                focalPointToSet = vec3.scaleAndAdd(vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);\n            }\n            const imageData = viewport.getImageData();\n            let spacing = [1, 1, 1];\n            if (imageData) {\n                spacing = imageData.spacing;\n            }\n            const { minZoomScale, maxZoomScale } = this.configuration;\n            const t = element.clientHeight * spacing[1] * 0.5;\n            const scale = t / parallelScaleToSet;\n            let cappedParallelScale = parallelScaleToSet;\n            let thresholdExceeded = false;\n            if (imageData) {\n                if (scale < minZoomScale) {\n                    cappedParallelScale = t / minZoomScale;\n                    thresholdExceeded = true;\n                }\n                else if (scale >= maxZoomScale) {\n                    cappedParallelScale = t / maxZoomScale;\n                    thresholdExceeded = true;\n                }\n            }\n            viewport.setCamera({\n                parallelScale: cappedParallelScale,\n                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n                position: thresholdExceeded ? position : positionToSet,\n            });\n        };\n        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { position, focalPoint, viewPlaneNormal } = camera;\n            const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n            const zoomScale = Math.sqrt(distance) / size[1];\n            const directionOfProjection = [\n                -viewPlaneNormal[0],\n                -viewPlaneNormal[1],\n                -viewPlaneNormal[2],\n            ];\n            const k = this.configuration.invert\n                ? deltaY / zoomScale\n                : deltaY * zoomScale;\n            let tmp = k * directionOfProjection[0];\n            position[0] += tmp;\n            focalPoint[0] += tmp;\n            tmp = k * directionOfProjection[1];\n            position[1] += tmp;\n            focalPoint[1] += tmp;\n            tmp = k * directionOfProjection[2];\n            position[2] += tmp;\n            focalPoint[2] += tmp;\n            viewport.setCamera({ position, focalPoint });\n        };\n        this.initialMousePosWorld = [0, 0, 0];\n        this.dirVec = [0, 0, 0];\n        if (this.configuration.pinchToZoom) {\n            this.touchDragCallback = this._pinchCallback.bind(this);\n        }\n        else {\n            this.touchDragCallback = this._dragCallback.bind(this);\n        }\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _pinchCallback(evt) {\n        const pointsList = evt.detail\n            .currentPointsList;\n        if (pointsList.length > 1) {\n            const { element, currentPoints } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const worldPos = currentPoints.world;\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            if (camera.parallelProjection) {\n                this._dragParallelProjection(evt, viewport, camera, true);\n            }\n            else {\n                this._dragPerspectiveProjection(evt, viewport, camera, true);\n            }\n            viewport.render();\n        }\n        if (this.configuration.pan) {\n            this._panCallback(evt);\n        }\n    }\n    _dragCallback(evt) {\n        const { element } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        if (camera.parallelProjection) {\n            this._dragParallelProjection(evt, viewport, camera);\n        }\n        else {\n            this._dragPerspectiveProjection(evt, viewport, camera);\n        }\n        viewport.render();\n    }\n    _panCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n//# sourceMappingURL=ZoomTool.js.map","import { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass AngleTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId]) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const textLines = this._getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _getTextLines(data, targetId) {\n        const cachedVolumeStats = data.cachedStats[targetId];\n        const { angle } = cachedVolumeStats;\n        if (angle === undefined) {\n            return;\n        }\n        const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n        return textLines;\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId } = enabledElement;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            cachedStats[targetId] = {\n                angle,\n            };\n        }\n        annotation.invalidated = false;\n        const eventType = Events.ANNOTATION_MODIFIED;\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return cachedStats;\n    }\n}\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n//# sourceMappingURL=AngleTool.js.map","import { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass ArrowAnnotateTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const { arrowFirst } = this.configuration;\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    text: '',\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        arrowFirst,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { viewportId, renderingEngineId, renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((text) => {\n                    if (!text) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.text = text;\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                });\n            }\n            else {\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportId,\n                    renderingEngineId,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, text } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!text) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [text], textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.text = updatedText;\n        const { renderingEngine, viewportId, renderingEngineId } = getEnabledElement(element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        const eventType = Events.ANNOTATION_MODIFIED;\n        triggerEvent(eventTarget, eventType, {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        });\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n//# sourceMappingURL=ArrowAnnotateTool.js.map","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit === undefined) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const textLines = this._getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._getTextLines = (data, targetId) => {\n            const { cachedStats } = data;\n            const { length, width, unit } = cachedStats[targetId];\n            if (length === undefined) {\n                return;\n            }\n            const textLines = [\n                `L: ${length.toFixed(2)} ${unit}`,\n                `W: ${width.toFixed(2)} ${unit}`,\n            ];\n            return textLines;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportId, renderingEngineId } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions, hasPixelSpacing } = image;\n                const dist1 = this._calculateLength(worldPos1, worldPos2);\n                const dist2 = this._calculateLength(worldPos3, worldPos4);\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit: hasPixelSpacing ? 'mm' : 'px',\n                };\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        return annotation;\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n//# sourceMappingURL=BidirectionalTool.js.map","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, eventTarget, triggerEvent, utilities as csUtils, } from '@cornerstonejs/core';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            centerPointRadius: 0,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const radius = getCanvasCircleRadius(canvasCoordinates);\n            const radiusPoint = getCanvasCircleRadius([\n                canvasCoordinates[0],\n                canvasCoords,\n            ]);\n            if (Math.abs(radiusPoint - radius) < proximity / 2)\n                return true;\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                data.handles.points[0],\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0) {\n                const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n                const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n                const canvasCenter = currentCanvasPoints;\n                const canvasEnd = [\n                    canvasCoordinates[1][0] + dXCanvas,\n                    canvasCoordinates[1][1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasCenter);\n                points[1] = canvasToWorld(canvasEnd);\n            }\n            else {\n                points[1] = canvasToWorld(currentCanvasPoints);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius(canvasCoordinates);\n                const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit === undefined) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const isPreScaled = isViewportPreScaled(viewport, targetId);\n                const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n                const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getTextLines = (data, targetId, isPreScaled, isSuvScaled) => {\n            const cachedVolumeStats = data.cachedStats[targetId];\n            const { radius, radiusUnit, area, mean, stdDev, max, isEmptyArea, Modality, areaUnit, } = cachedVolumeStats;\n            const textLines = [];\n            const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n            if (radius) {\n                const radiusLine = isEmptyArea\n                    ? `Radius: Oblique not supported`\n                    : `Radius: ${radius.toFixed(2)} ${radiusUnit}`;\n                textLines.push(radiusLine);\n            }\n            if (area) {\n                const areaLine = isEmptyArea\n                    ? `Area: Oblique not supported`\n                    : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n                textLines.push(areaLine);\n            }\n            if (mean) {\n                textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n            }\n            if (max) {\n                textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n            }\n            if (stdDev) {\n                textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n            }\n            return textLines;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { viewportId, renderingEngineId } = enabledElement;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n                const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const ellipseObj = {\n                        center,\n                        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2));\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    let max = -Infinity;\n                    const meanMaxCalculator = ({ value: newValue }) => {\n                        if (newValue > max) {\n                            max = newValue;\n                        }\n                        mean += newValue;\n                        count += 1;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), meanMaxCalculator, boundsIJK);\n                    mean /= count;\n                    const stdCalculator = ({ value }) => {\n                        const valueMinusMean = value - mean;\n                        stdDev += valueMinusMean * valueMinusMean;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), stdCalculator, boundsIJK);\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        max,\n                        stdDev,\n                        isEmptyArea,\n                        areaUnit: hasPixelSpacing ? 'mm' : 'px',\n                        radius: worldWidth / 2,\n                        radiusUnit: hasPixelSpacing ? 'mm' : 'px',\n                        perimeter: 2 * Math.PI * (worldWidth / 2),\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n}\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n//# sourceMappingURL=CircleROITool.js.map","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass CobbAngleTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3, point4] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDownCallback = (evt) => {\n            const { annotation, handleIndex } = this.editData;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { data } = annotation;\n            if (handleIndex === 1) {\n                data.handles.points[1] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[1][0] !== data.handles.points[0][0] ||\n                        data.handles.points[1][1] !== data.handles.points[0][0];\n                return;\n            }\n            if (handleIndex === 3) {\n                data.handles.points[3] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[3][0] !== data.handles.points[2][0] ||\n                        data.handles.points[3][1] !== data.handles.points[2][0];\n                this.angleStartedNotYetCompleted = false;\n                return;\n            }\n            this.editData.hasMoved = false;\n            hideElementCursor(element);\n            data.handles.points[2] = data.handles.points[3] = worldPos;\n            this.editData.handleIndex = data.handles.points.length - 1;\n        };\n        this._mouseDragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId]) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = '3';\n                const mid1 = midPoint2(canvasCoordinates[0], canvasCoordinates[1]);\n                const mid2 = midPoint2(canvasCoordinates[2], canvasCoordinates[3]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const textLines = this._getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _getTextLines(data, targetId) {\n        const cachedVolumeStats = data.cachedStats[targetId];\n        const { angle } = cachedVolumeStats;\n        if (angle === undefined) {\n            return;\n        }\n        const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n        return textLines;\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId } = enabledElement;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const seg1 = [null, null];\n        const seg2 = [null, null];\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 2; i += 1) {\n            for (let j = 2; j < 4; j += 1) {\n                const dist = vec3.distance(data.handles.points[i], data.handles.points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    seg1[1] = data.handles.points[i];\n                    seg1[0] = data.handles.points[(i + 1) % 2];\n                    seg2[0] = data.handles.points[j];\n                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n                }\n            }\n        }\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines(seg1, seg2);\n            cachedStats[targetId] = {\n                angle,\n            };\n        }\n        annotation.invalidated = false;\n        const eventType = Events.ANNOTATION_MODIFIED;\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return cachedStats;\n    }\n}\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n//# sourceMappingURL=CobbAngleTool.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nclass DragProbeTool extends ProbeTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.postMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                isVisible: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.postTouchStartCallback = (evt) => {\n            return this.postMouseDownCallback(evt);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const annotation = this.editData.annotation;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const point = data.handles.points[0];\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            styleSpecifier.annotationUID = annotationUID;\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            if (!data.cachedStats[targetId]) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    index: null,\n                    value: null,\n                };\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n            renderStatus = true;\n            const isPreScaled = isViewportPreScaled(viewport, targetId);\n            const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n            const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n            if (textLines) {\n                const textCanvasCoordinates = [\n                    canvasCoordinates[0] + 6,\n                    canvasCoordinates[1] - 6,\n                ];\n                const textUID = '0';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            }\n            return renderStatus;\n        };\n    }\n}\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n//# sourceMappingURL=DragProbeTool.js.map","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, eventTarget, triggerEvent, utilities as csUtils, } from '@cornerstonejs/core';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawCircle as drawCircleSvg, drawEllipse as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            centerPointRadius: 0,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    initialRotation: viewport.getRotation(),\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerCanvas: canvasPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n            const [canvasPoint1, canvasPoint2] = canvasCorners;\n            const minorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n            };\n            const majorEllipse = {\n                left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n                top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n                width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n                height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas } = enabledElement.viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerCanvas,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld } = enabledElement.viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerCanvas, originalHandleCanvas, } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const rotation = Math.abs(viewport.getRotation() - (data.initialRotation || 0));\n                let canvasCorners;\n                if (rotation == 90 || rotation == 270) {\n                    canvasCorners = getCanvasEllipseCorners([\n                        canvasCoordinates[2],\n                        canvasCoordinates[3],\n                        canvasCoordinates[0],\n                        canvasCoordinates[1],\n                    ]);\n                }\n                else {\n                    canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                }\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit === undefined) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCorners[0], canvasCorners[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const isPreScaled = isViewportPreScaled(viewport, targetId);\n                const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n                const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getTextLines = (data, targetId, isPreScaled, isSuvScaled) => {\n            const cachedVolumeStats = data.cachedStats[targetId];\n            const { area, mean, stdDev, max, isEmptyArea, Modality, areaUnit } = cachedVolumeStats;\n            const textLines = [];\n            const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n            if (area) {\n                const areaLine = isEmptyArea\n                    ? `Area: Oblique not supported`\n                    : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n                textLines.push(areaLine);\n            }\n            if (mean) {\n                textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n            }\n            if (max) {\n                textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n            }\n            if (stdDev) {\n                textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n            }\n            return textLines;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { viewportId, renderingEngineId } = enabledElement;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n                const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const ellipseObj = {\n                        center,\n                        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const area = Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2));\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    let max = -Infinity;\n                    const meanMaxCalculator = ({ value: newValue }) => {\n                        if (newValue > max) {\n                            max = newValue;\n                        }\n                        mean += newValue;\n                        count += 1;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), meanMaxCalculator, boundsIJK);\n                    mean /= count;\n                    const stdCalculator = ({ value }) => {\n                        const valueMinusMean = value - mean;\n                        stdDev += valueMinusMean * valueMinusMean;\n                    };\n                    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), stdCalculator, boundsIJK);\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        max,\n                        stdDev,\n                        isEmptyArea,\n                        areaUnit: hasPixelSpacing ? 'mm' : 'px',\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    _pointInEllipseCanvas(ellipse, location) {\n        const xRadius = ellipse.width / 2;\n        const yRadius = ellipse.height / 2;\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n        const normalized = [location[0] - center[0], location[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n//# sourceMappingURL=EllipticalROITool.js.map","import { Events } from '../../enums';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit === undefined) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const textLines = this._getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _getTextLines(data, targetId) {\n        const cachedVolumeStats = data.cachedStats[targetId];\n        const { length, unit } = cachedVolumeStats;\n        if (length === undefined || length === null || isNaN(length)) {\n            return;\n        }\n        const textLines = [`${length.toFixed(2)} ${unit}`];\n        return textLines;\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId } = enabledElement;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetIdImage(targetId, renderingEngine);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions, hasPixelSpacing } = image;\n            const length = this._calculateLength(worldPos1, worldPos2);\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            this._isInsideVolume(index1, index2, dimensions)\n                ? (this.isHandleOutsideImage = false)\n                : (this.isHandleOutsideImage = true);\n            cachedStats[targetId] = {\n                length,\n                unit: hasPixelSpacing ? 'mm' : 'px',\n            };\n        }\n        annotation.invalidated = false;\n        const eventType = Events.ANNOTATION_MODIFIED;\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n//# sourceMappingURL=LengthTool.js.map","import { CONSTANTS, getEnabledElement, triggerEvent, eventTarget, StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getIntersectionCoordinatesWithPolyline } from '../../utilities/math/polyline/getIntersectionWithPolyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            subPixelResolution: 4,\n            interpolation: {\n                interpolateOnAdd: false,\n                interpolateOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            calculateStats: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        points: [],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    polyline: [[...worldPos]],\n                    label: '',\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.isOpenContour) {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const points = annotation.data.polyline;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const distance = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (distance === true) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (annotation.data.isOpenContour) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            const distance = pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n            if (distance === true) {\n                return true;\n            }\n            return false;\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationCompleted = (annotation) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const targetId = this.getTargetId(viewport);\n            let annotations = (getAnnotations(this.getToolName(), element));\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n                annotations.forEach((annotation) => {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                });\n            }\n            else {\n                const activeAnnotationUID = this.commonData.annotation.annotationUID;\n                annotations.forEach((annotation) => {\n                    if (annotation.annotationUID === activeAnnotationUID) {\n                        if (isDrawing) {\n                            this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                        }\n                        else if (isEditingClosed) {\n                            this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                        }\n                        else if (isEditingOpen) {\n                            this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                        }\n                        else {\n                            throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                        }\n                    }\n                    else {\n                        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                    }\n                });\n                renderStatus = true;\n            }\n            if (!this.configuration.calculateStats)\n                return;\n            annotations.forEach((annotation) => {\n                const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n                if (annotation.annotationUID === activeAnnotationUID &&\n                    !this.commonData?.movingTextBox)\n                    return;\n                if (!this.commonData?.movingTextBox) {\n                    const { data } = annotation;\n                    if (!data.cachedStats[targetId] ||\n                        data.cachedStats[targetId].areaUnit === undefined) {\n                        data.cachedStats[targetId] = {\n                            Modality: null,\n                            area: null,\n                            max: null,\n                            mean: null,\n                            stdDev: null,\n                            areaUnit: null,\n                        };\n                        this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    }\n                    else if (annotation.invalidated) {\n                        this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    }\n                }\n                this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n            });\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const data = annotation.data;\n            const { cachedStats, polyline: points } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata, hasPixelSpacing } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const area = polyline.calculateAreaOfPoints(canvasCoordinates);\n                const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n                worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n                worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n                worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n                let iMin = worldPosIndex[0];\n                let iMax = worldPosIndex[0];\n                let jMin = worldPosIndex[1];\n                let jMax = worldPosIndex[1];\n                let kMin = worldPosIndex[2];\n                let kMax = worldPosIndex[2];\n                for (let j = 1; j < points.length; j++) {\n                    const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n                    worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n                    worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n                    worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n                    iMin = Math.min(iMin, worldPosIndex[0]);\n                    iMax = Math.max(iMax, worldPosIndex[0]);\n                    jMin = Math.min(jMin, worldPosIndex[1]);\n                    jMax = Math.max(jMax, worldPosIndex[1]);\n                    kMin = Math.min(kMin, worldPosIndex[2]);\n                    kMax = Math.max(kMax, worldPosIndex[2]);\n                }\n                const iDelta = 0.01 * (iMax - iMin);\n                const jDelta = 0.01 * (jMax - jMin);\n                const kDelta = 0.01 * (kMax - kMin);\n                iMin = Math.floor(iMin - iDelta);\n                iMax = Math.ceil(iMax + iDelta);\n                jMin = Math.floor(jMin - jDelta);\n                jMax = Math.ceil(jMax + jDelta);\n                kMin = Math.floor(kMin - kDelta);\n                kMax = Math.ceil(kMax + kDelta);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n                const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n                let count = 0;\n                let sum = 0;\n                let sumSquares = 0;\n                let max = -Infinity;\n                const statCalculator = ({ value: newValue }) => {\n                    if (newValue > max) {\n                        max = newValue;\n                    }\n                    sum += newValue;\n                    sumSquares += newValue ** 2;\n                    count += 1;\n                };\n                let curRow = 0;\n                let intersections = [];\n                let intersectionCounter = 0;\n                pointInShapeCallback(imageData, (pointLPS, pointIJK) => {\n                    let result = true;\n                    const point = viewport.worldToCanvas(pointLPS);\n                    if (point[1] != curRow) {\n                        intersectionCounter = 0;\n                        curRow = point[1];\n                        intersections = getIntersectionCoordinatesWithPolyline(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                        intersections.sort((function (index) {\n                            return function (a, b) {\n                                return a[index] === b[index]\n                                    ? 0\n                                    : a[index] < b[index]\n                                        ? -1\n                                        : 1;\n                            };\n                        })(0));\n                    }\n                    if (intersections.length && point[0] > intersections[0][0]) {\n                        intersections.shift();\n                        intersectionCounter++;\n                    }\n                    if (intersectionCounter % 2 === 0) {\n                        result = false;\n                    }\n                    return result;\n                }, statCalculator, boundsIJK);\n                const mean = sum / count;\n                let stdDev = sumSquares / count - mean ** 2;\n                stdDev = Math.sqrt(stdDev);\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    mean,\n                    max,\n                    stdDev,\n                    areaUnit: hasPixelSpacing ? 'mm' : 'px',\n                };\n            }\n            annotation.invalidated = false;\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            const isPreScaled = isViewportPreScaled(viewport, targetId);\n            const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n            const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n            if (!textLines || textLines.length === 0)\n                return;\n            const canvasCoordinates = data.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this._getTextLines = (data, targetId, isPreScaled, isSuvScaled) => {\n            const cachedVolumeStats = data.cachedStats[targetId];\n            const { area, mean, stdDev, max, isEmptyArea, Modality, areaUnit } = cachedVolumeStats;\n            const textLines = [];\n            const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n            if (area) {\n                const areaLine = isEmptyArea\n                    ? `Area: Oblique not supported`\n                    : `Area: ${area.toFixed(2)} ${areaUnit}\\xb2`;\n                textLines.push(areaLine);\n            }\n            if (mean) {\n                textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n            }\n            if (max) {\n                textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n            }\n            if (stdDev) {\n                textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n            }\n            return textLines;\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof StackViewport) {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n        }\n        else {\n            throw new Error(`Viewport Type ${viewport.type} not supported`);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n}\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n//# sourceMappingURL=PlanarFreehandROITool.js.map","import { vec2 } from 'gl-matrix';\nimport { getEnabledElement, VolumeViewport, triggerEvent, eventTarget, utilities as csUtils, utilities, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass ProbeTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const { viewportId } = enabledElement;\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const annotationUID = annotation.annotationUID;\n                const data = annotation.data;\n                const point = data.handles.points[0];\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                styleSpecifier.annotationUID = annotationUID;\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!data.cachedStats[targetId]) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        index: null,\n                        value: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const handleGroupUID = '0';\n                drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n                renderStatus = true;\n                const isPreScaled = isViewportPreScaled(viewport, targetId);\n                const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n                const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n                if (textLines) {\n                    const textCanvasCoordinates = [\n                        canvasCoordinates[0] + 6,\n                        canvasCoordinates[1] - 6,\n                    ];\n                    const textUID = '0';\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                }\n            }\n            return renderStatus;\n        };\n    }\n    isPointNearTool() {\n        return false;\n    }\n    toolSelectedCallback() { }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n        if (near === true) {\n            return point;\n        }\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _getTextLines(data, targetId, isPreScaled, isSuvScaled) {\n        const cachedVolumeStats = data.cachedStats[targetId];\n        const { index, Modality, value, SUVBw, SUVLbm, SUVBsa } = cachedVolumeStats;\n        if (value === undefined && SUVBw === undefined) {\n            return;\n        }\n        const textLines = [];\n        const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n        textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n        if (Modality === 'PT' && isPreScaled === true && SUVBw !== undefined) {\n            textLines.push(`${SUVBw.toFixed(2)} SUV bw`);\n            if (SUVLbm) {\n                textLines.push(`${SUVLbm.toFixed(2)} SUV lbm`);\n            }\n            if (SUVBsa) {\n                textLines.push(`${SUVBsa.toFixed(2)} SUV bsa`);\n            }\n        }\n        else {\n            textLines.push(`${value.toFixed(2)} ${unit}`);\n        }\n        return textLines;\n    }\n    _getValueForModality(value, imageVolume, modality) {\n        const values = {};\n        values['value'] = value;\n        if (modality === 'PT' &&\n            imageVolume.scaling?.PET &&\n            (imageVolume.scaling.PET.suvbwToSuvbsa ||\n                imageVolume.scaling.PET.suvbwToSuvlbm)) {\n            const { suvbwToSuvlbm, suvbwToSuvbsa } = imageVolume.scaling.PET;\n            values['SUVBw'] = value;\n            if (suvbwToSuvlbm) {\n                const SUVLbm = value * suvbwToSuvlbm;\n                values['SUVLbm'] = SUVLbm;\n            }\n            if (suvbwToSuvbsa) {\n                const SUVBsa = value * suvbwToSuvbsa;\n                values['SUVBsa'] = SUVBsa;\n            }\n        }\n        return values;\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId } = enabledElement;\n        const worldPos = data.handles.points[0];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetIdImage(targetId, renderingEngine);\n            if (!image) {\n                continue;\n            }\n            const { dimensions, imageData, metadata } = image;\n            const scalarData = 'getScalarData' in image ? image.getScalarData() : image.scalarData;\n            const modality = metadata.Modality;\n            const index = transformWorldToIndex(imageData, worldPos);\n            index[0] = Math.round(index[0]);\n            index[1] = Math.round(index[1]);\n            index[2] = Math.round(index[2]);\n            if (csUtils.indexWithinDimensions(index, dimensions)) {\n                this.isHandleOutsideImage = false;\n                const yMultiple = dimensions[0];\n                const zMultiple = dimensions[0] * dimensions[1];\n                const value = scalarData[index[2] * zMultiple + index[1] * yMultiple + index[0]];\n                if (targetId.startsWith('imageId:')) {\n                    const imageId = targetId.split('imageId:')[1];\n                    const imageURI = csUtils.imageIdToURI(imageId);\n                    const viewports = utilities.getViewportsWithImageURI(imageURI, renderingEngineId);\n                    const viewport = viewports[0];\n                    index[2] = viewport.getCurrentImageIdIndex();\n                }\n                const values = this._getValueForModality(value, image, modality);\n                cachedStats[targetId] = {\n                    index,\n                    ...values,\n                    Modality: modality,\n                };\n            }\n            else {\n                this.isHandleOutsideImage = true;\n                cachedStats[targetId] = {\n                    index,\n                    Modality: modality,\n                };\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        }\n        return cachedStats;\n    }\n}\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n//# sourceMappingURL=ProbeTool.js.map","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRect as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            if (newAnnotation) {\n                const eventType = Events.ANNOTATION_COMPLETED;\n                const eventDetail = {\n                    annotation,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                const { renderingEngine } = enabledElement;\n                triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n                if (newAnnotation) {\n                    const eventType = Events.ANNOTATION_COMPLETED;\n                    const eventDetail = {\n                        annotation,\n                    };\n                    triggerEvent(eventTarget, eventType, eventDetail);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit === undefined) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const isPreScaled = isViewportPreScaled(viewport, targetId);\n                const isSuvScaled = this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId);\n                const textLines = this._getTextLines(data, targetId, isPreScaled, isSuvScaled);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._getTextLines = (data, targetId, isPreScaled, isSuvScaled) => {\n            const cachedVolumeStats = data.cachedStats[targetId];\n            const { area, mean, max, stdDev, Modality, areaUnit } = cachedVolumeStats;\n            if (mean === undefined) {\n                return;\n            }\n            const textLines = [];\n            const unit = getModalityUnit(Modality, isPreScaled, isSuvScaled);\n            textLines.push(`Area: ${area.toFixed(2)} ${areaUnit}\\xb2`);\n            textLines.push(`Mean: ${mean.toFixed(2)} ${unit}`);\n            textLines.push(`Max: ${max.toFixed(2)} ${unit}`);\n            textLines.push(`Std Dev: ${stdDev.toFixed(2)} ${unit}`);\n            return textLines;\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportId, renderingEngineId } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetIdImage(targetId, renderingEngine);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n                const scalarData = 'getScalarData' in image ? image.getScalarData() : image.scalarData;\n                const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const area = Math.abs(worldWidth * worldHeight);\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    let max = -Infinity;\n                    const yMultiple = dimensions[0];\n                    const zMultiple = dimensions[0] * dimensions[1];\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                if (value > max) {\n                                    max = value;\n                                }\n                                count++;\n                                mean += value;\n                            }\n                        }\n                    }\n                    mean /= count;\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                const valueMinusMean = value - mean;\n                                stdDev += valueMinusMean * valueMinusMean;\n                            }\n                        }\n                    }\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        stdDev,\n                        max,\n                        areaUnit: hasPixelSpacing ? 'mm' : 'px',\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n}\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n//# sourceMappingURL=RectangleROITool.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { getInterpolatedPoints, shouldInterpolate, } from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, calculateAreaOfPoints, } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    const worldPoints = fusedCanvasPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = false;\n    this.triggerAnnotationModified(annotation, enabledElement);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n    };\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = calculateAreaOfPoints(pointSet1);\n    const areaPointSet2 = calculateAreaOfPoints(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldInterpolate(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n        annotation.data.polyline = worldPoints;\n        annotation.data.isOpenContour = false;\n        this.triggerAnnotationModified(annotation, enabledElement);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n//# sourceMappingURL=closedContourEditLoop.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { Events } from '../../../enums';\nimport { state } from '../../../store';\nimport { vec3 } from 'gl-matrix';\nimport { shouldInterpolate, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstIntersectionWithPolyline, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints } = this.drawData;\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n    }\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element);\n    }\n    else {\n        this.completeDrawClosedContour(element);\n    }\n}\nfunction completeDrawClosedContour(element) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldInterpolate(this.configuration)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = false;\n    this.triggerAnnotationCompleted(annotation);\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstIntersectionWithPolyline(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n    }\n}\nfunction completeDrawOpenContour(element) {\n    const { canvasPoints } = this.drawData;\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldInterpolate(this.configuration)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    this.triggerAnnotationCompleted(annotation);\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstIntersectionWithPolyline(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    for (let i = 0; i < crossingIndex; i++) {\n        canvasPoints.shift();\n    }\n    if (this.completeDrawClosedContour(element)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element);\n    }\n    else {\n        this.completeDrawClosedContour(element);\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n//# sourceMappingURL=drawLoop.js.map","import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstIntersectionWithPolyline } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstIntersectionWithPolyline(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstIntersectionWithPolyline(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstIntersectionWithPolyline(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstIntersectionWithPolyline(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstIntersectionWithPolyline(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstIntersectionWithPolyline(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstIntersectionWithPolyline(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n//# sourceMappingURL=editLoopCommon.js.map","import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n//# sourceMappingURL=findOpenUShapedContourVectorToPeak.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport { shouldInterpolate, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    const worldPoints = fusedCanvasPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    this.triggerAnnotationModified(annotation, enabledElement);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    const worldPoints = fusedCanvasPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    this.triggerAnnotationModified(annotation, enabledElement);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldInterpolate(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const worldPoints = updatedPoints.map((canvasPoint) => viewport.canvasToWorld(canvasPoint));\n        annotation.data.polyline = worldPoints;\n        annotation.data.isOpenContour = true;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        this.triggerAnnotationModified(annotation, enabledElement);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n//# sourceMappingURL=openContourEditLoop.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n//# sourceMappingURL=openContourEndEditLoop.js.map","import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const isOpenContour = annotation.data.isOpenContour;\n    const options = {\n        color: color === undefined ? undefined : color,\n        width: lineWidth === undefined ? undefined : lineWidth,\n        lineDash: lineDash === undefined ? undefined : lineDash,\n        connectLastToFirst: !isOpenContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.isOpenContour) {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n    else {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { polyline, openUShapeContourVectorToPeak } = annotation.data;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        connectLastToFirst: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        connectLastToFirst: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.connectLastToFirst = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n//# sourceMappingURL=renderMethods.js.map","import { utilities, getEnabledElement, VolumeViewport, StackViewport, cache, } from '@cornerstonejs/core';\nimport { vec4 } from 'gl-matrix';\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nclass AnnotationDisplayTool extends BaseTool {\n    constructor() {\n        super(...arguments);\n        this.onImageSpacingCalibrated = (evt) => {\n            const { element, rowScale, columnScale, imageId, imageData: calibratedImageData, worldToIndex: nonCalibratedWorldToIndex, } = evt.detail;\n            const { viewport } = getEnabledElement(element);\n            if (viewport instanceof VolumeViewport) {\n                throw new Error('Cannot calibrate a volume viewport');\n            }\n            const calibratedIndexToWorld = calibratedImageData.getIndexToWorld();\n            const imageURI = utilities.imageIdToURI(imageId);\n            const stateManager = getAnnotationManager();\n            const framesOfReference = stateManager.getFramesOfReference();\n            framesOfReference.forEach((frameOfReference) => {\n                const frameOfReferenceSpecificAnnotations = stateManager.getAnnotations(frameOfReference);\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];\n                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n                    return;\n                }\n                toolSpecificAnnotations.forEach((annotation) => {\n                    const referencedImageURI = utilities.imageIdToURI(annotation.metadata.referencedImageId);\n                    if (referencedImageURI === imageURI) {\n                        annotation.invalidated = true;\n                        annotation.data.cachedStats = {};\n                        annotation.data.handles.points = annotation.data.handles.points.map((point) => {\n                            const p = vec4.fromValues(...point, 1);\n                            const pCalibrated = vec4.fromValues(0, 0, 0, 1);\n                            const nonCalibratedIndexVec4 = vec4.create();\n                            vec4.transformMat4(nonCalibratedIndexVec4, p, nonCalibratedWorldToIndex);\n                            const calibratedIndex = [\n                                columnScale * nonCalibratedIndexVec4[0],\n                                rowScale * nonCalibratedIndexVec4[1],\n                                nonCalibratedIndexVec4[2],\n                            ];\n                            vec4.transformMat4(pCalibrated, vec4.fromValues(calibratedIndex[0], calibratedIndex[1], calibratedIndex[2], 1), calibratedIndexToWorld);\n                            return pCalibrated.slice(0, 3);\n                        });\n                    }\n                });\n                triggerAnnotationRender(element);\n            });\n        };\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        return filterAnnotationsForDisplay(viewport, annotations);\n    }\n    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        else {\n            const volumeId = targetId.split('volumeId:')[1];\n            const imageVolume = cache.getVolume(volumeId);\n            referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n        }\n        return referencedImageId;\n    }\n    getStyle(property, specifications, annotation) {\n        return getStyleProperty(property, specifications, getState(annotation), this.mode);\n    }\n}\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n//# sourceMappingURL=AnnotationDisplayTool.js.map","import { BaseVolumeViewport, StackViewport, cache, getEnabledElement, metaData, } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass AnnotationTool extends AnnotationDisplayTool {\n    constructor() {\n        super(...arguments);\n        this.mouseMoveCallback = (evt, filteredAnnotations) => {\n            if (!filteredAnnotations) {\n                return false;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let annotationsNeedToBeRedrawn = false;\n            for (const annotation of filteredAnnotations) {\n                if (isAnnotationLocked(annotation) ||\n                    !isAnnotationVisible(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data } = annotation;\n                const activateHandleIndex = data.handles\n                    ? data.handles.activeHandleIndex\n                    : undefined;\n                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n                const notNearToolAndMarkedActive = !near && annotation.highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !annotation.highlighted;\n                    annotationsNeedToBeRedrawn = true;\n                }\n                else if (data.handles &&\n                    data.handles.activeHandleIndex !== activateHandleIndex) {\n                    annotationsNeedToBeRedrawn = true;\n                }\n            }\n            return annotationsNeedToBeRedrawn;\n        };\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const { points, textBox } = data.handles;\n        const { worldBoundingBox } = textBox;\n        if (worldBoundingBox) {\n            const canvasBoundingBox = {\n                topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n                topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n                bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n                bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n            };\n            if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n                canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n                canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n                canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {\n                data.handles.activeHandleIndex = null;\n                return textBox;\n            }\n        }\n        for (let i = 0; i < points.length; i++) {\n            const point = points[i];\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n            if (near === true) {\n                data.handles.activeHandleIndex = i;\n                return point;\n            }\n        }\n        data.handles.activeHandleIndex = null;\n    }\n    getLinkedTextBoxStyle(specifications, annotation) {\n        return {\n            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n            color: this.getStyle('textBoxColor', specifications, annotation),\n            shadow: this.getStyle('textBoxShadow', specifications, annotation),\n            background: this.getStyle('textBoxBackground', specifications, annotation),\n            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n        };\n    }\n    isSuvScaled(viewport, targetId, imageId) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = targetId.split('volumeId:')[1];\n            const volume = cache.getVolume(volumeId);\n            return volume.scaling?.PET !== undefined;\n        }\n        else if (viewport instanceof StackViewport) {\n            const scalingModule = imageId && metaData.get('scalingModule', imageId);\n            return typeof scalingModule?.suvbw === 'number';\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n    }\n    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {\n        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n        if (handleNearImagePoint) {\n            return true;\n        }\n        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');\n        if (toolNewImagePoint) {\n            return true;\n        }\n    }\n}\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n//# sourceMappingURL=AnnotationTool.js.map","import { StackViewport, utilities, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { ToolModes } from '../../enums';\nclass BaseTool {\n    constructor(toolProps, defaultToolProps) {\n        const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;\n        if (!configuration.strategies) {\n            configuration.strategies = {};\n            configuration.defaultStrategy = undefined;\n            configuration.activeStrategy = undefined;\n            configuration.strategyOptions = {};\n        }\n        this.toolGroupId = toolGroupId;\n        this.supportedInteractionTypes = supportedInteractionTypes || [];\n        this.configuration = Object.assign({}, configuration);\n        this.mode = ToolModes.Disabled;\n    }\n    getToolName() {\n        return this.constructor.toolName;\n    }\n    applyActiveStrategy(enabledElement, operationData) {\n        const { strategies, activeStrategy } = this.configuration;\n        return strategies[activeStrategy].call(this, enabledElement, operationData);\n    }\n    setConfiguration(newConfiguration) {\n        this.configuration = utilities.deepMerge(this.configuration, newConfiguration);\n    }\n    setActiveStrategy(strategyName) {\n        this.setConfiguration({ activeStrategy: strategyName });\n    }\n    getTargetVolumeId(viewport) {\n        if (this.configuration.volumeId) {\n            return this.configuration.volumeId;\n        }\n        const actorEntries = viewport.getActors();\n        if (!actorEntries) {\n            return;\n        }\n        return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;\n    }\n    getTargetIdImage(targetId, renderingEngine) {\n        if (targetId.startsWith('imageId:')) {\n            const imageId = targetId.split('imageId:')[1];\n            const imageURI = utilities.imageIdToURI(imageId);\n            let viewports = utilities.getViewportsWithImageURI(imageURI, renderingEngine.id);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            viewports = viewports.filter((viewport) => {\n                return viewport.getCurrentImageId() === imageId;\n            });\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('volumeId:')) {\n            const volumeId = targetId.split('volumeId:')[1];\n            const viewports = utilities.getViewportsWithVolumeId(volumeId, renderingEngine.id);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else {\n            throw new Error('getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"');\n        }\n    }\n    getTargetId(viewport) {\n        if (viewport instanceof StackViewport) {\n            return `imageId:${viewport.getCurrentImageId()}`;\n        }\n        else if (viewport instanceof BaseVolumeViewport) {\n            return `volumeId:${this.getTargetVolumeId(viewport)}`;\n        }\n        else {\n            throw new Error('getTargetId: viewport must be a StackViewport or VolumeViewport');\n        }\n    }\n}\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n//# sourceMappingURL=BaseTool.js.map","import BaseTool from './BaseTool';\nimport AnnotationTool from './AnnotationTool';\nexport { BaseTool, AnnotationTool };\n//# sourceMappingURL=index.js.map","import { cache } from '@cornerstonejs/core';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport { getPolyData, getSegmentSpecificConfig, validateGeometry, } from './utils';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\nexport function addContourSetsToElement(viewport, geometryIds, contourRepresentation, contourRepresentationConfig, contourActorUID) {\n    const { segmentationRepresentationUID, segmentsHidden } = contourRepresentation;\n    const appendPolyData = vtkAppendPolyData.newInstance();\n    const scalarToColorMap = new Map();\n    const segmentSpecificMap = new Map();\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.getSegmentIndex();\n        validateGeometry(geometry);\n        const segmentSpecificConfig = getSegmentSpecificConfig(contourRepresentation, geometryId, segmentIndex);\n        const contourSet = geometry.data;\n        const polyData = getPolyData(contourSet);\n        const color = contourSet.getColor();\n        const size = polyData.getPoints().getNumberOfPoints();\n        const scalars = vtkDataArray.newInstance({\n            size: size * 4,\n            numberOfComponents: 4,\n            dataType: 'Uint8Array',\n        });\n        for (let i = 0; i < size; ++i) {\n            scalars.setTuple(i, [...color, 255]);\n        }\n        polyData.getPointData().setScalars(scalars);\n        if (segmentSpecificConfig) {\n            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n        }\n        scalarToColorMap.set(segmentIndex, [\n            ...color,\n            segmentsHidden.has(segmentIndex) ? 0 : 255,\n        ]);\n        segmentIndex === 0\n            ? appendPolyData.setInputData(polyData)\n            : appendPolyData.addInputData(polyData);\n    });\n    const polyDataOutput = appendPolyData.getOutputData();\n    const outlineWidthActive = contourRepresentationConfig.representations.CONTOUR.outlineWidthActive;\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputData(polyDataOutput);\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.getProperty().setLineWidth(outlineWidthActive);\n    setConfigCache(segmentationRepresentationUID, Object.assign({}, getConfigCache(segmentationRepresentationUID), {\n        segmentsHidden: new Set(segmentsHidden),\n        segmentSpecificMap,\n        outlineWidthActive,\n    }));\n    actor.setForceOpaque(true);\n    viewport.addActor({\n        uid: contourActorUID,\n        actor: actor,\n    });\n    viewport.resetCamera();\n    viewport.render();\n}\n//# sourceMappingURL=addContourSetsToElement.js.map","import { addContourSetsToElement } from './addContourSetsToElement';\nimport { updateContourSets } from './updateContourSets';\nexport function addOrUpdateContourSets(viewport, geometryIds, contourRepresentation, contourRepresentationConfig) {\n    const { segmentationRepresentationUID } = contourRepresentation;\n    const actorUID = `CONTOUR_${segmentationRepresentationUID}`;\n    const actor = viewport.getActor(actorUID);\n    const addOrUpdateFn = actor ? updateContourSets : addContourSetsToElement;\n    addOrUpdateFn(viewport, geometryIds, contourRepresentation, contourRepresentationConfig, actorUID);\n}\n//# sourceMappingURL=addOrUpdateContourSets.js.map","const defaultContourConfig = {\n    renderOutline: true,\n    outlineWidthActive: 2,\n    outlineWidthInactive: 2,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n    renderFill: true,\n    fillAlpha: 1,\n    fillAlphaInactive: 0,\n};\nfunction getDefaultContourConfig() {\n    return defaultContourConfig;\n}\nexport default getDefaultContourConfig;\n//# sourceMappingURL=contourConfig.js.map","const configCachePerSegmentationRepresentationUID = new Map();\nexport function getConfigCache(segmentationRepresentationUID) {\n    return configCachePerSegmentationRepresentationUID.get(segmentationRepresentationUID);\n}\nexport function setConfigCache(segmentationRepresentationUID, config) {\n    configCachePerSegmentationRepresentationUID.set(segmentationRepresentationUID, config);\n}\nexport function deleteConfigCache(segmentationRepresentationUID) {\n    configCachePerSegmentationRepresentationUID.delete(segmentationRepresentationUID);\n}\n//# sourceMappingURL=contourConfigCache.js.map","import { getEnabledElementByIds, utilities as csUtils, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport { addOrUpdateContourSets } from './addOrUpdateContourSets';\nimport removeContourFromElement from './removeContourFromElement';\nimport { deleteConfigCache } from './contourConfigCache';\nasync function addSegmentationRepresentation(toolGroupId, representationInput, toolGroupSpecificConfig) {\n    const { segmentationId } = representationInput;\n    const segmentationRepresentationUID = csUtils.uuidv4();\n    const segmentsHidden = new Set();\n    const visibility = true;\n    const colorLUTIndex = 0;\n    const active = true;\n    const toolGroupSpecificRepresentation = {\n        segmentationId,\n        segmentationRepresentationUID,\n        type: Representations.Contour,\n        segmentsHidden,\n        colorLUTIndex,\n        active,\n        segmentationRepresentationSpecificConfig: {},\n        segmentSpecificConfig: {},\n        config: {},\n    };\n    if (toolGroupSpecificConfig) {\n        const currentToolGroupConfig = SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n        const mergedConfig = csUtils.deepMerge(currentToolGroupConfig, toolGroupSpecificConfig);\n        SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n            renderInactiveSegmentations: mergedConfig.renderInactiveSegmentations || true,\n            representations: {\n                ...mergedConfig.representations,\n            },\n        });\n    }\n    SegmentationState.addSegmentationRepresentation(toolGroupId, toolGroupSpecificRepresentation);\n    return segmentationRepresentationUID;\n}\nfunction removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID, renderImmediate = false) {\n    _removeContourFromToolGroupViewports(toolGroupId, segmentationRepresentationUID);\n    SegmentationState.removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID);\n    deleteConfigCache(segmentationRepresentationUID);\n    if (renderImmediate) {\n        const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            enabledElement.viewport.render();\n        });\n    }\n}\nasync function render(viewport, representationConfig, toolGroupConfig) {\n    const { segmentationId } = representationConfig;\n    const segmentation = SegmentationState.getSegmentation(segmentationId);\n    const contourData = segmentation.representationData[Representations.Contour];\n    const { geometryIds } = contourData;\n    if (!geometryIds?.length) {\n        console.warn(`No contours found for segmentationId ${segmentationId}. Skipping render.`);\n    }\n    addOrUpdateContourSets(viewport, geometryIds, representationConfig, toolGroupConfig);\n}\nfunction _removeContourFromToolGroupViewports(toolGroupId, segmentationRepresentationUID) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n    }\n    const { viewportsInfo } = toolGroup;\n    for (const viewportInfo of viewportsInfo) {\n        const { viewportId, renderingEngineId } = viewportInfo;\n        const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n        removeContourFromElement(enabledElement.viewport.element, segmentationRepresentationUID);\n    }\n}\nexport default {\n    render,\n    addSegmentationRepresentation,\n    removeSegmentationRepresentation,\n};\n//# sourceMappingURL=contourDisplay.js.map","import contourDisplay from './contourDisplay';\nexport { contourDisplay };\n//# sourceMappingURL=index.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nfunction removeContourFromElement(element, segmentationRepresentationUID, removeFromCache = false) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntries = viewport.getActors();\n    const actorUIDsToRemove = actorEntries\n        .map(({ uid }) => uid.includes(segmentationRepresentationUID) ? uid : undefined)\n        .filter(Boolean);\n    viewport.removeActors(actorUIDsToRemove);\n}\nexport default removeContourFromElement;\n//# sourceMappingURL=removeContourFromElement.js.map","import { cache } from '@cornerstonejs/core';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\nimport { getSegmentSpecificConfig } from './utils';\nexport function updateContourSets(viewport, geometryIds, contourRepresentation, contourRepresentationConfig, contourActorUID) {\n    const { segmentationRepresentationUID, segmentsHidden } = contourRepresentation;\n    const newContourConfig = contourRepresentationConfig.representations.CONTOUR;\n    const cachedConfig = getConfigCache(segmentationRepresentationUID);\n    const contourSetsActor = viewport.getActor(contourActorUID);\n    if (!contourSetsActor) {\n        console.warn(`No contour actor found for actorUID ${contourActorUID}. Skipping render.`);\n        return;\n    }\n    const { actor } = contourSetsActor;\n    const newOutlineWithActive = newContourConfig.outlineWidthActive;\n    if (cachedConfig?.outlineWidthActive !== newOutlineWithActive) {\n        actor\n            .getProperty()\n            .setLineWidth(newOutlineWithActive);\n        setConfigCache(segmentationRepresentationUID, Object.assign({}, cachedConfig, {\n            outlineWidthActive: newOutlineWithActive,\n        }));\n    }\n    const mapper = actor.getMapper();\n    const lut = mapper.getLookupTable();\n    const segmentsToSetToInvisible = [];\n    const segmentsToSetToVisible = [];\n    for (const segmentIndex of segmentsHidden) {\n        if (!cachedConfig.segmentsHidden.has(segmentIndex)) {\n            segmentsToSetToInvisible.push(segmentIndex);\n        }\n    }\n    for (const segmentIndex of cachedConfig.segmentsHidden) {\n        if (!segmentsHidden.has(segmentIndex)) {\n            segmentsToSetToVisible.push(segmentIndex);\n        }\n    }\n    const mergedInvisibleSegments = Array.from(cachedConfig.segmentsHidden)\n        .filter((segmentIndex) => !segmentsToSetToVisible.includes(segmentIndex))\n        .concat(segmentsToSetToInvisible);\n    const { contourSets, segmentSpecificConfigs } = geometryIds.reduce((acc, geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        const { data: contourSet } = geometry;\n        const segmentIndex = contourSet.getSegmentIndex();\n        const segmentSpecificConfig = getSegmentSpecificConfig(contourRepresentation, geometryId, segmentIndex);\n        acc.contourSets.push(contourSet);\n        acc.segmentSpecificConfigs[segmentIndex] = segmentSpecificConfig ?? {};\n        return acc;\n    }, { contourSets: [], segmentSpecificConfigs: {} });\n    const affectedSegments = [\n        ...mergedInvisibleSegments,\n        ...segmentsToSetToVisible,\n    ];\n    const hasCustomSegmentSpecificConfig = Object.values(segmentSpecificConfigs).some((config) => Object.keys(config).length > 0);\n    let polyDataModified = false;\n    if (affectedSegments.length || hasCustomSegmentSpecificConfig) {\n        const appendPolyData = mapper.getInputData();\n        const appendScalars = appendPolyData.getPointData().getScalars();\n        const appendScalarsData = appendScalars.getData();\n        let offset = 0;\n        contourSets.forEach((contourSet) => {\n            const segmentIndex = contourSet.getSegmentIndex();\n            const size = contourSet.getTotalNumberOfPoints();\n            if (affectedSegments.includes(segmentIndex) ||\n                segmentSpecificConfigs[segmentIndex]?.fillAlpha) {\n                const color = contourSet.getColor();\n                let visibility = mergedInvisibleSegments.includes(segmentIndex)\n                    ? 0\n                    : 255;\n                const segmentConfig = segmentSpecificConfigs[segmentIndex];\n                if (segmentConfig.fillAlpha !== undefined) {\n                    visibility = segmentConfig.fillAlpha * 255;\n                }\n                for (let i = 0; i < size; ++i) {\n                    appendScalarsData[offset + i * 4] = color[0];\n                    appendScalarsData[offset + i * 4 + 1] = color[1];\n                    appendScalarsData[offset + i * 4 + 2] = color[2];\n                    appendScalarsData[offset + i * 4 + 3] = visibility;\n                }\n                polyDataModified = true;\n            }\n            offset = offset + size * 4;\n        });\n        if (polyDataModified) {\n            appendPolyData.modified();\n        }\n        setConfigCache(segmentationRepresentationUID, Object.assign({}, cachedConfig, {\n            segmentsHidden: new Set(segmentsHidden),\n        }));\n        mapper.setLookupTable(lut);\n    }\n    viewport.render();\n}\n//# sourceMappingURL=updateContourSets.js.map","import { Enums } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nexport function getSegmentSpecificConfig(contourRepresentation, segmentId, index) {\n    let segmentSpecificConfig = contourRepresentation.segmentSpecificConfig?.[segmentId];\n    if (!segmentSpecificConfig) {\n        segmentSpecificConfig =\n            contourRepresentation.segmentSpecificConfig?.[index];\n    }\n    if (!segmentSpecificConfig) {\n        return null;\n    }\n    return segmentSpecificConfig.CONTOUR;\n}\nexport function validateGeometry(geometry) {\n    if (!geometry) {\n        throw new Error(`No contours found for geometryId ${geometry.id}`);\n    }\n    const geometryId = geometry.id;\n    if (geometry.type !== Enums.GeometryType.CONTOUR) {\n        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);\n    }\n    if (!geometry.data) {\n        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);\n        return;\n    }\n}\nexport function getPolyData(contourSet) {\n    const pointArray = [];\n    const points = vtkPoints.newInstance();\n    const lines = vtkCellArray.newInstance();\n    let pointIndex = 0;\n    contourSet.getContours().forEach((contour) => {\n        const pointList = contour.getPoints();\n        const flatPoints = contour.getFlatPointsArray();\n        const type = contour.getType();\n        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);\n        if (type === Enums.ContourType.CLOSED_PLANAR) {\n            pointIndexes.push(pointIndexes[0]);\n        }\n        const linePoints = Float32Array.from(flatPoints);\n        pointArray.push(...linePoints);\n        lines.insertNextCell([...pointIndexes]);\n        pointIndex = pointIndex + pointList.length;\n    });\n    points.setData(pointArray, 3);\n    const polygon = vtkPolyData.newInstance();\n    polygon.setPoints(points);\n    polygon.setLines(lines);\n    return polygon;\n}\n//# sourceMappingURL=utils.js.map","import { getEnabledElement, addVolumesToViewports, Enums, } from '@cornerstonejs/core';\nasync function addLabelmapToElement(element, volumeId, segmentationRepresentationUID) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { id: viewportId } = viewport;\n    const visibility = true;\n    const immediateRender = false;\n    const suppressEvents = true;\n    const volumeInputs = [\n        {\n            volumeId,\n            actorUID: segmentationRepresentationUID,\n            visibility,\n            blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        },\n    ];\n    await addVolumesToViewports(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);\n}\nexport default addLabelmapToElement;\n//# sourceMappingURL=addLabelmapToElement.js.map","import labelmapDisplay from './labelmapDisplay';\nimport labelmapConfig from './labelmapConfig';\nexport { labelmapDisplay, labelmapConfig };\n//# sourceMappingURL=index.js.map","const defaultLabelmapConfig = {\n    renderOutline: true,\n    outlineWidthActive: 3,\n    outlineWidthInactive: 2,\n    renderFill: true,\n    renderFillInactive: true,\n    fillAlpha: 0.7,\n    fillAlphaInactive: 0.65,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n};\nfunction getDefaultLabelmapConfig() {\n    return defaultLabelmapConfig;\n}\nfunction isValidLabelmapConfig(config) {\n    return (config &&\n        typeof config.renderOutline === 'boolean' &&\n        typeof config.outlineWidthActive === 'number' &&\n        typeof config.outlineWidthInactive === 'number' &&\n        typeof config.renderFill === 'boolean' &&\n        typeof config.renderFillInactive === 'boolean' &&\n        typeof config.fillAlpha === 'number' &&\n        typeof config.fillAlphaInactive === 'number' &&\n        typeof config.outlineOpacity === 'number' &&\n        typeof config.outlineOpacityInactive === 'number');\n}\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n//# sourceMappingURL=labelmapConfig.js.map","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport { cache, getEnabledElementByIds, utilities, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\nasync function addSegmentationRepresentation(toolGroupId, representationInput, toolGroupSpecificConfig) {\n    const { segmentationId } = representationInput;\n    const segmentationRepresentationUID = utilities.uuidv4();\n    const segmentsHidden = new Set();\n    const colorLUTIndex = 0;\n    const active = true;\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    const toolGroupSpecificRepresentation = {\n        segmentationId,\n        segmentationRepresentationUID,\n        type: Representations.Labelmap,\n        segmentsHidden,\n        colorLUTIndex,\n        active,\n        segmentationRepresentationSpecificConfig: {},\n        segmentSpecificConfig: {},\n        config: {\n            cfun,\n            ofun,\n        },\n    };\n    if (toolGroupSpecificConfig) {\n        const currentToolGroupConfig = SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n        const mergedConfig = utilities.deepMerge(currentToolGroupConfig, toolGroupSpecificConfig);\n        SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n            renderInactiveSegmentations: mergedConfig.renderInactiveSegmentations || true,\n            representations: {\n                ...mergedConfig.representations,\n            },\n        });\n    }\n    SegmentationState.addSegmentationRepresentation(toolGroupId, toolGroupSpecificRepresentation);\n    return segmentationRepresentationUID;\n}\nfunction removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID, renderImmediate = false) {\n    _removeLabelmapFromToolGroupViewports(toolGroupId, segmentationRepresentationUID);\n    SegmentationState.removeSegmentationRepresentation(toolGroupId, segmentationRepresentationUID);\n    if (renderImmediate) {\n        const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            enabledElement.viewport.render();\n        });\n    }\n}\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\n    if (!referencedVolumeId) {\n        return true;\n    }\n    const defaultActor = viewport.getDefaultActor();\n    if (!defaultActor) {\n        return false;\n    }\n    const { uid: defaultActorUID } = defaultActor;\n    const volume = cache.getVolume(defaultActorUID);\n    if (volume) {\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        if (referencedVolume &&\n            volume.metadata.FrameOfReferenceUID ===\n                referencedVolume.metadata.FrameOfReferenceUID) {\n            return true;\n        }\n    }\n    return false;\n}\nasync function render(viewport, representation, toolGroupConfig) {\n    const { colorLUTIndex, active, segmentationId, segmentationRepresentationUID, segmentsHidden, config: renderingConfig, } = representation;\n    const segmentation = SegmentationState.getSegmentation(segmentationId);\n    const labelmapData = segmentation.representationData[Representations.Labelmap];\n    const { volumeId: labelmapUID } = labelmapData;\n    const labelmap = cache.getVolume(labelmapUID);\n    if (!labelmap) {\n        throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n    }\n    if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\n        return;\n    }\n    let actorEntry = viewport.getActor(segmentationRepresentationUID);\n    if (!actorEntry) {\n        const segmentation = SegmentationState.getSegmentation(segmentationId);\n        const { volumeId } = segmentation.representationData[Representations.Labelmap];\n        await _addLabelmapToViewport(viewport, volumeId, segmentationRepresentationUID);\n        actorEntry = viewport.getActor(segmentationRepresentationUID);\n    }\n    if (!actorEntry) {\n        return;\n    }\n    const { cfun, ofun } = renderingConfig;\n    const renderInactiveSegmentations = toolGroupConfig.renderInactiveSegmentations;\n    _setLabelmapColorAndOpacity(viewport.id, actorEntry, cfun, ofun, colorLUTIndex, toolGroupConfig.representations[Representations.Labelmap], representation, active, renderInactiveSegmentations, segmentsHidden);\n}\nfunction _setLabelmapColorAndOpacity(viewportId, actorEntry, cfun, ofun, colorLUTIndex, toolGroupLabelmapConfig, segmentationRepresentation, isActiveLabelmap, renderInactiveSegmentations, segmentsHidden) {\n    const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } = segmentationRepresentation;\n    const segmentationRepresentationLabelmapConfig = segmentationRepresentationSpecificConfig[Representations.Labelmap];\n    const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n    const numColors = Math.min(256, colorLUT.length);\n    const volumeActor = actorEntry.actor;\n    const { uid: actorUID } = actorEntry;\n    const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(toolGroupLabelmapConfig, segmentationRepresentationLabelmapConfig, isActiveLabelmap);\n    for (let i = 0; i < numColors; i++) {\n        const segmentIndex = i;\n        const segmentColor = colorLUT[segmentIndex];\n        const segmentSpecificLabelmapConfig = segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(toolGroupLabelmapConfig, segmentationRepresentationLabelmapConfig, isActiveLabelmap, segmentSpecificLabelmapConfig);\n        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            segmentColor,\n            outlineWidth,\n            segmentsHidden,\n        });\n        if (forceColorUpdate) {\n            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);\n        }\n        if (forceOpacityUpdate) {\n            if (renderFill) {\n                const segmentOpacity = segmentsHidden.has(segmentIndex)\n                    ? 0\n                    : (segmentColor[3] / 255) * fillAlpha;\n                ofun.removePoint(segmentIndex);\n                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n            }\n            else {\n                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n            }\n        }\n    }\n    volumeActor.getProperty().setRGBTransferFunction(0, cfun);\n    ofun.setClamping(false);\n    volumeActor.getProperty().setScalarOpacity(0, ofun);\n    volumeActor.getProperty().setInterpolationTypeToNearest();\n    volumeActor.getProperty().setUseLabelOutline(renderOutline);\n    volumeActor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n    volumeActor.getProperty().setLabelOutlineThickness(outlineWidth);\n    const visible = isActiveLabelmap || renderInactiveSegmentations;\n    volumeActor.setVisibility(visible);\n}\nfunction _getLabelmapConfig(toolGroupLabelmapConfig, segmentationRepresentationLabelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {\n    const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n    const configToUse = {\n        ...toolGroupLabelmapConfig,\n        ...segmentationRepresentationLabelmapConfig,\n        ...segmentLabelmapConfig,\n    };\n    const fillAlpha = isActiveLabelmap\n        ? configToUse.fillAlpha\n        : configToUse.fillAlphaInactive;\n    const outlineWidth = isActiveLabelmap\n        ? configToUse.outlineWidthActive\n        : configToUse.outlineWidthInactive;\n    const renderFill = isActiveLabelmap\n        ? configToUse.renderFill\n        : configToUse.renderFillInactive;\n    const renderOutline = configToUse.renderOutline;\n    const outlineOpacity = isActiveLabelmap\n        ? configToUse.outlineOpacity\n        : configToUse.outlineOpacityInactive;\n    return {\n        fillAlpha,\n        outlineWidth,\n        renderFill,\n        renderOutline,\n        outlineOpacity,\n    };\n}\nfunction _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, }) {\n    const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n    const oldConfig = labelMapConfigCache.get(cacheUID);\n    if (!oldConfig) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor,\n            segmentsHidden: new Set(segmentsHidden),\n        });\n        return {\n            forceOpacityUpdate: true,\n            forceColorUpdate: true,\n        };\n    }\n    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, } = oldConfig;\n    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||\n        oldSegmentColor[1] !== segmentColor[1] ||\n        oldSegmentColor[2] !== segmentColor[2];\n    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||\n        oldFillAlpha !== fillAlpha ||\n        oldRenderFill !== renderFill ||\n        oldRenderOutline !== renderOutline ||\n        oldOutlineWidth !== outlineWidth ||\n        oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n    labelMapConfigCache.set(cacheUID, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        outlineWidth,\n        segmentColor: segmentColor.slice(),\n        segmentsHidden: new Set(segmentsHidden),\n    });\n    return {\n        forceOpacityUpdate,\n        forceColorUpdate,\n    };\n}\nfunction _removeLabelmapFromToolGroupViewports(toolGroupId, segmentationRepresentationUID) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n    }\n    const { viewportsInfo } = toolGroup;\n    for (const viewportInfo of viewportsInfo) {\n        const { viewportId, renderingEngineId } = viewportInfo;\n        const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n        removeLabelmapFromElement(enabledElement.viewport.element, segmentationRepresentationUID);\n    }\n}\nasync function _addLabelmapToViewport(viewport, volumeId, segmentationRepresentationUID) {\n    await addLabelmapToElement(viewport.element, volumeId, segmentationRepresentationUID);\n}\nexport default {\n    render,\n    addSegmentationRepresentation,\n    removeSegmentationRepresentation,\n};\n//# sourceMappingURL=labelmapDisplay.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nfunction removeLabelmapFromElement(element, segmentationRepresentationUID, removeFromCache = false) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    viewport.removeVolumeActors([\n        segmentationRepresentationUID,\n    ]);\n}\nexport default removeLabelmapFromElement;\n//# sourceMappingURL=removeLabelmapFromElement.js.map","import { cache } from '@cornerstonejs/core';\nfunction validate(segmentationInput) {\n    if (!segmentationInput.representation.data) {\n        throw new Error('The segmentationInput.representationData.data is undefined, please provide a valid representationData.data');\n    }\n    const representationData = segmentationInput.representation\n        .data;\n    if (!representationData.volumeId) {\n        throw new Error('The segmentationInput.representationData.volumeId is undefined, please provide a valid representationData.volumeId');\n    }\n    const cachedVolume = cache.getVolume(representationData.volumeId);\n    if (!cachedVolume) {\n        throw new Error(`volumeId of ${representationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);\n    }\n}\nexport default validate;\n//# sourceMappingURL=validateRepresentationData.js.map","import { getEnabledElementByIds, utilities as csUtils, } from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { BaseTool } from '../base';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\nclass SegmentationDisplayTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {},\n    }) {\n        super(toolProps, defaultToolProps);\n        this.renderSegmentation = (toolGroupId) => {\n            const toolGroup = getToolGroup(toolGroupId);\n            if (!toolGroup) {\n                return;\n            }\n            const toolGroupSegmentationRepresentations = getSegmentationRepresentations(toolGroupId);\n            if (!toolGroupSegmentationRepresentations ||\n                toolGroupSegmentationRepresentations.length === 0) {\n                return;\n            }\n            const toolGroupViewports = toolGroup.viewportsInfo.map(({ renderingEngineId, viewportId }) => {\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                if (enabledElement) {\n                    return enabledElement.viewport;\n                }\n            });\n            const segmentationRenderList = toolGroupSegmentationRepresentations.map((representation) => {\n                const config = this._getMergedRepresentationsConfig(toolGroupId);\n                const viewportsRenderList = [];\n                for (const viewport of toolGroupViewports) {\n                    if (representation.type == Representations.Labelmap) {\n                        viewportsRenderList.push(labelmapDisplay.render(viewport, representation, config));\n                    }\n                    else if (representation.type == Representations.Contour) {\n                        viewportsRenderList.push(contourDisplay.render(viewport, representation, config));\n                    }\n                }\n                return viewportsRenderList;\n            });\n            Promise.allSettled(segmentationRenderList).then(() => {\n                toolGroupViewports.forEach((viewport) => {\n                    viewport.render();\n                });\n            });\n        };\n    }\n    onSetToolEnabled() {\n        const toolGroupId = this.toolGroupId;\n        const toolGroupSegmentationRepresentations = getSegmentationRepresentations(toolGroupId);\n        if (!toolGroupSegmentationRepresentations ||\n            toolGroupSegmentationRepresentations.length === 0) {\n            return;\n        }\n        toolGroupSegmentationRepresentations.forEach((segmentationRepresentation) => {\n            setSegmentationVisibility(toolGroupId, segmentationRepresentation.segmentationRepresentationUID, true);\n        });\n    }\n    onSetToolDisabled() {\n        const toolGroupId = this.toolGroupId;\n        const toolGroupSegmentationRepresentations = getSegmentationRepresentations(toolGroupId);\n        if (!toolGroupSegmentationRepresentations ||\n            toolGroupSegmentationRepresentations.length === 0) {\n            return;\n        }\n        toolGroupSegmentationRepresentations.forEach((segmentationRepresentation) => {\n            setSegmentationVisibility(toolGroupId, segmentationRepresentation.segmentationRepresentationUID, false);\n        });\n    }\n    _getMergedRepresentationsConfig(toolGroupId) {\n        const toolGroupConfig = segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n        const globalConfig = segmentationConfig.getGlobalConfig();\n        const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n        return mergedConfig;\n    }\n}\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n//# sourceMappingURL=SegmentationDisplayTool.js.map","import { BaseTool, AnnotationTool } from './base';\nimport PanTool from './PanTool';\nimport TrackballRotateTool from './TrackballRotateTool';\nimport WindowLevelTool from './WindowLevelTool';\nimport StackScrollTool from './StackScrollTool';\nimport PlanarRotateTool from './PlanarRotateTool';\nimport StackScrollMouseWheelTool from './StackScrollToolMouseWheelTool';\nimport ZoomTool from './ZoomTool';\nimport VolumeRotateMouseWheelTool from './VolumeRotateMouseWheelTool';\nimport MIPJumpToClickTool from './MIPJumpToClickTool';\nimport CrosshairsTool from './CrosshairsTool';\nimport MagnifyTool from './MagnifyTool';\nimport ReferenceLinesTool from './ReferenceLinesTool';\nimport BidirectionalTool from './annotation/BidirectionalTool';\nimport LengthTool from './annotation/LengthTool';\nimport ProbeTool from './annotation/ProbeTool';\nimport DragProbeTool from './annotation/DragProbeTool';\nimport RectangleROITool from './annotation/RectangleROITool';\nimport EllipticalROITool from './annotation/EllipticalROITool';\nimport CircleROITool from './annotation/CircleROITool';\nimport PlanarFreehandROITool from './annotation/PlanarFreehandROITool';\nimport ArrowAnnotateTool from './annotation/ArrowAnnotateTool';\nimport AngleTool from './annotation/AngleTool';\nimport CobbAngleTool from './annotation/CobbAngleTool';\nimport ReferenceCursors from './ReferenceCursors';\nimport ReferenceLines from './ReferenceLinesTool';\nimport ScaleOverlayTool from './ScaleOverlayTool';\nimport SegmentationDisplayTool from './displayTools/SegmentationDisplayTool';\nimport RectangleScissorsTool from './segmentation/RectangleScissorsTool';\nimport CircleScissorsTool from './segmentation/CircleScissorsTool';\nimport SphereScissorsTool from './segmentation/SphereScissorsTool';\nimport RectangleROIThresholdTool from './segmentation/RectangleROIThresholdTool';\nimport RectangleROIStartEndThresholdTool from './segmentation/RectangleROIStartEndThresholdTool';\nimport BrushTool from './segmentation/BrushTool';\nimport PaintFillTool from './segmentation/PaintFillTool';\nexport { BaseTool, AnnotationTool, PanTool, TrackballRotateTool, DragProbeTool, WindowLevelTool, StackScrollTool, PlanarRotateTool, StackScrollMouseWheelTool, ZoomTool, VolumeRotateMouseWheelTool, MIPJumpToClickTool, CrosshairsTool, ReferenceLinesTool, BidirectionalTool, LengthTool, ProbeTool, RectangleROITool, EllipticalROITool, CircleROITool, PlanarFreehandROITool, ArrowAnnotateTool, AngleTool, CobbAngleTool, ReferenceCursors, SegmentationDisplayTool, RectangleScissorsTool, CircleScissorsTool, SphereScissorsTool, RectangleROIThresholdTool, RectangleROIStartEndThresholdTool, BrushTool, MagnifyTool, ReferenceLines, PaintFillTool, ScaleOverlayTool, };\n//# sourceMappingURL=index.js.map","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events, ToolModes } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, state as segmentationState, activeSegmentation, } from '../../stateManagement/segmentation';\nclass BrushTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n            },\n            strategySpecificConfiguration: {\n                THRESHOLD_INSIDE_CIRCLE: {\n                    threshold: [-150, -70],\n                },\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            brushSize: 25,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolPassive = () => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = () => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Not implemented yet');\n            }\n            const toolGroupId = this.toolGroupId;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using the brush tool');\n            }\n            const { segmentationId, type } = activeSegmentationRepresentation;\n            const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n            const { representationData } = segmentationState.getSegmentation(segmentationId);\n            const { volumeId } = representationData[type];\n            const segmentation = cache.getVolume(volumeId);\n            const actors = viewport.getActors();\n            const firstVolumeActorUID = actors[0].uid;\n            const imageVolume = cache.getVolume(firstVolumeActorUID);\n            const viewportIdsToRender = [viewport.id];\n            this._editData = {\n                segmentation,\n                imageVolume,\n                segmentsLocked,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportUIDs(renderingEngine, viewportIdsToRender);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n            }\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const { imageVolume, segmentation, segmentsLocked } = this._editData;\n            this.updateCursor(evt);\n            const { segmentIndex, segmentationId, segmentationRepresentationUID, brushCursor, viewportIdsToRender, } = this._hoverData;\n            const { data } = brushCursor;\n            const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n            triggerAnnotationRenderForViewportUIDs(renderingEngine, viewportIdsToRender);\n            const operationData = {\n                points: data.handles.points,\n                volume: segmentation,\n                imageVolume,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                toolGroupId: this.toolGroupId,\n                segmentationId,\n                segmentationRepresentationUID,\n                viewUp,\n                strategySpecificConfiguration: this.configuration.strategySpecificConfiguration,\n            };\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { imageVolume, segmentation, segmentsLocked } = this._editData;\n            const { segmentIndex, segmentationId, segmentationRepresentationUID, brushCursor, } = this._hoverData;\n            const { data } = brushCursor;\n            const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._editData = null;\n            this.updateCursor(evt);\n            if (viewport instanceof StackViewport) {\n                throw new Error('Not implemented yet');\n            }\n            const operationData = {\n                points: data.handles.points,\n                volume: segmentation,\n                imageVolume,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                toolGroupId: this.toolGroupId,\n                segmentationId,\n                segmentationRepresentationUID,\n                viewUp,\n                strategySpecificConfiguration: this.configuration.strategySpecificConfiguration,\n            };\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const toolGroupId = this.toolGroupId;\n        const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n        if (!activeSegmentationRepresentation) {\n            console.warn('No active segmentation detected, create one before using the brush tool');\n            return;\n        }\n        const { segmentationRepresentationUID, segmentationId } = activeSegmentationRepresentation;\n        const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n        const segmentColor = segmentationConfig.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);\n        const viewportIdsToRender = [viewport.id];\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        this._hoverData = {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            segmentationId,\n            segmentationRepresentationUID,\n            segmentColor,\n            viewportIdsToRender,\n        };\n        this._calculateCursor(element, centerCanvas);\n        triggerAnnotationRenderForViewportUIDs(renderingEngine, viewportIdsToRender);\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const { brushSize } = this.configuration;\n        const radius = brushSize;\n        const bottomCanvas = [\n            centerCanvas[0],\n            centerCanvas[1] + radius,\n        ];\n        const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n        const leftCanvas = [\n            centerCanvas[0] - radius,\n            centerCanvas[1],\n        ];\n        const rightCanvas = [\n            centerCanvas[0] + radius,\n            centerCanvas[1],\n        ];\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            canvasToWorld(bottomCanvas),\n            canvasToWorld(topCanvas),\n            canvasToWorld(leftCanvas),\n            canvasToWorld(rightCanvas),\n        ];\n        data.invalidated = false;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData !== undefined) {\n            const { data } = this._hoverData.brushCursor;\n            data.invalidated = true;\n        }\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n        });\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n//# sourceMappingURL=BrushTool.js.map","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, config as segmentationConfig, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nclass CircleScissorsTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideCircle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const toolGroupId = this.toolGroupId;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationRepresentationUID, segmentationId, type } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n            const segmentColor = segmentationConfig.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const { volumeId } = representationData[type];\n            const segmentation = cache.getVolume(volumeId);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    isDrawing: true,\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                segmentation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentation, segmentIndex, segmentsLocked, segmentationId, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Not implemented yet');\n            }\n            const operationData = {\n                points: data.handles.points,\n                volume: segmentation,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                segmentationId,\n                viewUp,\n            };\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n//# sourceMappingURL=CircleScissorsTool.js.map","import { cache, getEnabledElement, utilities as csUtils, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, } from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nconst { transformWorldToIndex, isEqual } = csUtils;\nclass PaintFillTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal } = camera;\n            const toolGroupId = this.toolGroupId;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId, type } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n            const { representationData } = getSegmentation(segmentationId);\n            const { volumeId } = representationData[type];\n            const segmentation = cache.getVolume(volumeId);\n            const { dimensions, direction } = segmentation;\n            const scalarData = segmentation.getScalarData();\n            const index = transformWorldToIndex(segmentation.imageData, worldPos);\n            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n            if (fixedDimension === undefined) {\n                console.warn('Oblique paint fill not yet supported');\n                return;\n            }\n            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n            if (index[0] < 0 ||\n                index[0] >= dimensions[0] ||\n                index[1] < 0 ||\n                index[1] >= dimensions[1] ||\n                index[2] < 0 ||\n                index[2] >= dimensions[2]) {\n                return;\n            }\n            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n            if (segmentsLocked.includes(clickedLabelValue)) {\n                return;\n            }\n            const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n            const { flooded } = floodFillResult;\n            flooded.forEach((index) => {\n                const scalarDataPosition = getScalarDataPositionFromPlane(index[0], index[1]);\n                scalarData[scalarDataPosition] = segmentIndex;\n            });\n            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);\n            triggerSegmentationDataModified(segmentationId, framesModified);\n            return true;\n        };\n        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {\n            const { boundaries } = floodFillResult;\n            if (fixedDimension === 2) {\n                return [fixedDimensionValue];\n            }\n            let minJ = Infinity;\n            let maxJ = -Infinity;\n            for (let b = 0; b < boundaries.length; b++) {\n                const j = boundaries[b][1];\n                if (j < minJ)\n                    minJ = j;\n                if (j > maxJ)\n                    maxJ = j;\n            }\n            const framesModified = [];\n            for (let frame = minJ; frame <= maxJ; frame++) {\n                framesModified.push(frame);\n            }\n            return framesModified;\n        };\n        this.generateHelpers = (scalarData, dimensions, seedIndex3D, fixedDimension = 2) => {\n            let fixedDimensionValue;\n            let inPlaneSeedPoint;\n            switch (fixedDimension) {\n                case 0:\n                    fixedDimensionValue = seedIndex3D[0];\n                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];\n                    break;\n                case 1:\n                    fixedDimensionValue = seedIndex3D[1];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];\n                    break;\n                case 2:\n                    fixedDimensionValue = seedIndex3D[2];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            const getScalarDataPosition = (x, y, z) => {\n                return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n            };\n            const getLabelValue = (x, y, z) => {\n                return scalarData[getScalarDataPosition(x, y, z)];\n            };\n            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);\n            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);\n            return {\n                getScalarDataPositionFromPlane,\n                getLabelValue,\n                floodFillGetter,\n                inPlaneSeedPoint,\n                fixedDimensionValue,\n            };\n        };\n        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {\n            let floodFillGetter;\n            switch (fixedDimension) {\n                case 0:\n                    floodFillGetter = (y, z) => {\n                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    floodFillGetter = (x, z) => {\n                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    floodFillGetter = (x, y) => {\n                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return floodFillGetter;\n        };\n        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {\n            let getScalarDataPositionFromPlane;\n            switch (fixedDimension) {\n                case 0:\n                    getScalarDataPositionFromPlane = (y, z) => {\n                        return getScalarDataPosition(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    getScalarDataPositionFromPlane = (x, z) => {\n                        return getScalarDataPosition(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    getScalarDataPositionFromPlane = (x, y) => {\n                        return getScalarDataPosition(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return getScalarDataPositionFromPlane;\n        };\n    }\n    getFixedDimension(viewPlaneNormal, direction) {\n        const xDirection = direction.slice(0, 3);\n        const yDirection = direction.slice(3, 6);\n        const zDirection = direction.slice(6, 9);\n        const absoluteOfViewPlaneNormal = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const absoluteOfXDirection = [\n            Math.abs(xDirection[0]),\n            Math.abs(xDirection[1]),\n            Math.abs(xDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n            return 0;\n        }\n        const absoluteOfYDirection = [\n            Math.abs(yDirection[0]),\n            Math.abs(yDirection[1]),\n            Math.abs(yDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n            return 1;\n        }\n        const absoluteOfZDirection = [\n            Math.abs(zDirection[0]),\n            Math.abs(zDirection[1]),\n            Math.abs(zDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n            return 2;\n        }\n    }\n}\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n//# sourceMappingURL=PaintFillTool.js.map","import { getEnabledElement, cache, StackViewport, metaData, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport RectangleROITool from '../annotation/RectangleROITool';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            numSlicesToPropagate: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = targetId.split('volumeId:')[1];\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            if (!referencedImageId) {\n                throw new Error('This tool does not work on non-acquisition planes');\n            }\n            const startIndex = viewport.getCurrentImageIdIndex();\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const endIndex = this._getEndSliceIndex(imageVolume, worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                    spacingInNormal,\n                },\n                data: {\n                    label: '',\n                    startSlice: startIndex,\n                    endSlice: endIndex,\n                    cachedStats: {\n                        projectionPoints: [],\n                        projectionPointsImageIds: [referencedImageId],\n                    },\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: null,\n                            worldBoundingBox: null,\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const sliceIndex = viewport.getCurrentImageIdIndex();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { startSlice, endSlice } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (sliceIndex < Math.min(startSlice, endSlice) ||\n                    sliceIndex > Math.max(startSlice, endSlice)) {\n                    continue;\n                }\n                if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, enabledElement);\n                }\n                let firstOrLastSlice = false;\n                if (sliceIndex === startSlice || sliceIndex === endSlice) {\n                    firstOrLastSlice = true;\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    firstOrLastSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineDashToUse = lineDash;\n                if (!firstOrLastSlice) {\n                    lineDashToUse = 2;\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth,\n                });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, 100, { trailing: true });\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startSlice, endSlice } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        if (startIJK[2] !== startSlice) {\n            throw new Error('Start slice does not match');\n        }\n        const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        const distance = vec3.distance(startWorld, endWorld);\n        const newProjectionPoints = [];\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(points.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n        const projectionPointsImageIds = [];\n        for (const RectanglePoints of newProjectionPoints) {\n            const imageId = csUtils.getClosestImageId(imageVolume, RectanglePoints[0], viewPlaneNormal);\n            projectionPointsImageIds.push(imageId);\n        }\n        data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewportId, renderingEngineId, viewport } = enabledElement;\n        const { cachedStats } = data;\n        const volumeId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(volumeId.split('volumeId:')[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        annotation.invalidated = false;\n        const eventType = Events.ANNOTATION_MODIFIED;\n        const eventDetail = {\n            annotation,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return cachedStats;\n    }\n    _getEndSliceIndex(imageVolume, worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);\n        const halfSpacingInNormalDirection = spacingInNormal / 2;\n        const { imageIds } = imageVolume;\n        let imageIdIndex;\n        for (let i = 0; i < imageIds.length; i++) {\n            const imageId = imageIds[i];\n            const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n            const dir = vec3.create();\n            vec3.sub(dir, endPos, imagePositionPatient);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                imageIdIndex = i;\n            }\n        }\n        return imageIdIndex;\n    }\n}\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n//# sourceMappingURL=RectangleROIStartEndThresholdTool.js.map","import { getEnabledElement, cache, StackViewport, triggerEvent, eventTarget, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { Events } from '../../enums';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport RectangleROITool from '../annotation/RectangleROITool';\nclass RectangleROIThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const targetId = this.getTargetId(viewport);\n            let referencedImageId, volumeId;\n            if (viewport instanceof StackViewport) {\n                referencedImageId = targetId.split('imageId:')[1];\n            }\n            else {\n                volumeId = targetId.split('volumeId:')[1];\n                const imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: null,\n                            worldBoundingBox: null,\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    segmentationId: null,\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return annotation;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngineId } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportId: viewport.id,\n                    renderingEngineId,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotation) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n}\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n//# sourceMappingURL=RectangleROIThresholdTool.js.map","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { Events } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nclass RectangleScissorsTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideRectangle,\n                ERASE_INSIDE: eraseInsideRectangle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const toolGroupId = this.toolGroupId;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationRepresentationUID, segmentationId, type } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n            const segmentColor = segmentationConfig.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const { volumeId } = representationData[type];\n            const segmentation = cache.getVolume(volumeId);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                segmentation,\n                segmentIndex,\n                segmentsLocked,\n                segmentColor,\n                segmentationId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            points[handleIndex] = [...worldPos];\n            let bottomLeftCanvas;\n            let bottomRightCanvas;\n            let topLeftCanvas;\n            let topRightCanvas;\n            let bottomLeftWorld;\n            let bottomRightWorld;\n            let topLeftWorld;\n            let topRightWorld;\n            switch (handleIndex) {\n                case 0:\n                case 3:\n                    bottomLeftCanvas = worldToCanvas(points[0]);\n                    topRightCanvas = worldToCanvas(points[3]);\n                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                    bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                    topLeftWorld = canvasToWorld(topLeftCanvas);\n                    points[1] = bottomRightWorld;\n                    points[2] = topLeftWorld;\n                    break;\n                case 1:\n                case 2:\n                    bottomRightCanvas = worldToCanvas(points[1]);\n                    topLeftCanvas = worldToCanvas(points[2]);\n                    bottomLeftCanvas = [\n                        topLeftCanvas[0],\n                        bottomRightCanvas[1],\n                    ];\n                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];\n                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                    topRightWorld = canvasToWorld(topRightCanvas);\n                    points[0] = bottomLeftWorld;\n                    points[3] = topRightWorld;\n                    break;\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentation, segmentationId, segmentIndex, segmentsLocked, } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Not implemented yet');\n            }\n            const operationData = {\n                points: data.handles.points,\n                volume: segmentation,\n                segmentationId,\n                segmentIndex,\n                segmentsLocked,\n            };\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const rectangleUID = '0';\n            drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n//# sourceMappingURL=RectangleScissorsTool.js.map","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nclass SphereScissorsTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideSphere,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const toolGroupId = this.toolGroupId;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationRepresentationUID, segmentationId, type } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n            const segmentColor = segmentationConfig.color.getColorForSegmentIndex(toolGroupId, segmentationRepresentationUID, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const { volumeId } = representationData[type];\n            const segmentation = cache.getVolume(volumeId);\n            this.isDrawing = true;\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    highlighted: true,\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                segmentation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentsLocked,\n                segmentColor,\n                segmentationId,\n                toolGroupId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentation, segmentIndex, segmentsLocked, segmentationId, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.editData = null;\n            this.isDrawing = false;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Not implemented yet');\n            }\n            const operationData = {\n                points: data.handles.points,\n                volume: segmentation,\n                segmentIndex,\n                segmentsLocked,\n                segmentationId,\n                viewPlaneNormal,\n                viewUp,\n            };\n            this.applyActiveStrategy(enabledElement, operationData);\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n//# sourceMappingURL=SphereScissorsTool.js.map","import { fillInsideCircle } from './fillCircle';\nexport function eraseInsideCircle(enabledElement, operationData) {\n    const eraseOperationData = {\n        ...operationData,\n        segmentIndex: 0,\n    };\n    fillInsideCircle(enabledElement, eraseOperationData);\n}\n//# sourceMappingURL=eraseCircle.js.map","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInShapeCallback } from '../../../utilities';\nconst { transformWorldToIndex } = csUtils;\nfunction eraseRectangle(enabledElement, operationData, inside = true) {\n    const { volume: segmentation, points, segmentsLocked, segmentationId, } = operationData;\n    const { imageData, dimensions } = segmentation;\n    const scalarData = segmentation.getScalarData();\n    const rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(imageData, world);\n    });\n    const boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n    if (boundsIJK.every(([min, max]) => min !== max)) {\n        throw new Error('Oblique segmentation tools are not supported yet');\n    }\n    const pointInShape = () => true;\n    const callback = ({ value, index }) => {\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        scalarData[index] = 0;\n    };\n    pointInShapeCallback(imageData, pointInShape, callback, boundsIJK);\n    triggerSegmentationDataModified(segmentationId);\n}\nexport function eraseInsideRectangle(enabledElement, operationData) {\n    eraseRectangle(enabledElement, operationData, true);\n}\nexport function eraseOutsideRectangle(enabledElement, operationData) {\n    eraseRectangle(enabledElement, operationData, false);\n}\n//# sourceMappingURL=eraseRectangle.js.map","import { fillInsideSphere } from './fillSphere';\nexport function eraseInsideSphere(enabledElement, operationData) {\n    const eraseOperationData = Object.assign({}, operationData, {\n        segmentIndex: 0,\n    });\n    fillInsideSphere(enabledElement, eraseOperationData);\n}\n//# sourceMappingURL=eraseSphere.js.map","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getCanvasEllipseCorners, pointInEllipse, } from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInShapeCallback } from '../../../utilities';\nconst { transformWorldToIndex } = csUtils;\nfunction fillCircle(enabledElement, operationData, threshold = false) {\n    const { volume: segmentationVolume, imageVolume, points, segmentsLocked, segmentIndex, segmentationId, strategySpecificConfiguration, } = operationData;\n    const { imageData, dimensions } = segmentationVolume;\n    const scalarData = segmentationVolume.getScalarData();\n    const { viewport } = enabledElement;\n    const center = vec3.fromValues(0, 0, 0);\n    points.forEach((point) => {\n        vec3.add(center, center, point);\n    });\n    vec3.scale(center, center, 1 / points.length);\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const [topLeftCanvas, bottomRightCanvas] = getCanvasEllipseCorners(canvasCoordinates);\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const ellipsoidCornersIJK = [\n        transformWorldToIndex(imageData, topLeftWorld),\n        transformWorldToIndex(imageData, bottomRightWorld),\n    ];\n    const boundsIJK = getBoundingBoxAroundShape(ellipsoidCornersIJK, dimensions);\n    if (boundsIJK.every(([min, max]) => min !== max)) {\n        throw new Error('Oblique segmentation tools are not supported yet');\n    }\n    const ellipseObj = {\n        center: center,\n        xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n        yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n        zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n    };\n    const modifiedSlicesToUse = new Set();\n    let callback;\n    if (threshold) {\n        callback = ({ value, index, pointIJK }) => {\n            if (segmentsLocked.includes(value)) {\n                return;\n            }\n            if (isWithinThreshold(index, imageVolume, strategySpecificConfiguration)) {\n                scalarData[index] = segmentIndex;\n                modifiedSlicesToUse.add(pointIJK[2]);\n            }\n        };\n    }\n    else {\n        callback = ({ value, index, pointIJK }) => {\n            if (segmentsLocked.includes(value)) {\n                return;\n            }\n            scalarData[index] = segmentIndex;\n            modifiedSlicesToUse.add(pointIJK[2]);\n        };\n    }\n    pointInShapeCallback(imageData, (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS), callback, boundsIJK);\n    const arrayOfSlices = Array.from(modifiedSlicesToUse);\n    triggerSegmentationDataModified(segmentationId, arrayOfSlices);\n}\nfunction isWithinThreshold(index, imageVolume, strategySpecificConfiguration) {\n    const { THRESHOLD_INSIDE_CIRCLE } = strategySpecificConfiguration;\n    const voxelValue = imageVolume.getScalarData()[index];\n    const { threshold } = THRESHOLD_INSIDE_CIRCLE;\n    return threshold[0] <= voxelValue && voxelValue <= threshold[1];\n}\nexport function fillInsideCircle(enabledElement, operationData) {\n    fillCircle(enabledElement, operationData, false);\n}\nexport function thresholdInsideCircle(enabledElement, operationData) {\n    const { volume, imageVolume } = operationData;\n    if (!csUtils.isEqual(volume.dimensions, imageVolume.dimensions) ||\n        !csUtils.isEqual(volume.direction, imageVolume.direction)) {\n        throw new Error('Only source data the same dimensions/size/orientation as the segmentation currently supported.');\n    }\n    fillCircle(enabledElement, operationData, true);\n}\nexport function fillOutsideCircle(enabledElement, operationData) {\n    throw new Error('Not yet implemented');\n}\n//# sourceMappingURL=fillCircle.js.map","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { pointInShapeCallback } from '../../../utilities';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nconst { transformWorldToIndex } = csUtils;\nfunction fillRectangle(enabledElement, operationData, inside = true) {\n    const { volume: segmentation, points, segmentsLocked, segmentIndex, segmentationId, constraintFn, } = operationData;\n    const { imageData, dimensions } = segmentation;\n    const scalarData = segmentation.getScalarData();\n    let rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(imageData, world);\n    });\n    rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n        return point.map((coord) => {\n            return Math.round(coord);\n        });\n    });\n    const boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n    if (boundsIJK.every(([min, max]) => min !== max)) {\n        throw new Error('Oblique segmentation tools are not supported yet');\n    }\n    const pointInRectangle = () => true;\n    const callback = ({ value, index, pointIJK }) => {\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        if (!constraintFn) {\n            scalarData[index] = segmentIndex;\n            return;\n        }\n        if (constraintFn(pointIJK)) {\n            scalarData[index] = segmentIndex;\n        }\n    };\n    pointInShapeCallback(imageData, pointInRectangle, callback, boundsIJK);\n    triggerSegmentationDataModified(segmentationId);\n}\nexport function fillInsideRectangle(enabledElement, operationData) {\n    fillRectangle(enabledElement, operationData, true);\n}\nexport function fillOutsideRectangle(enabledElement, operationData) {\n    fillRectangle(enabledElement, operationData, false);\n}\n//# sourceMappingURL=fillRectangle.js.map","import { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInSurroundingSphereCallback } from '../../../utilities';\nfunction fillSphere(enabledElement, operationData, _inside = true) {\n    const { viewport } = enabledElement;\n    const { volume: segmentation, segmentsLocked, segmentIndex, segmentationId, points, } = operationData;\n    const { imageData, dimensions } = segmentation;\n    const scalarData = segmentation.getScalarData();\n    const scalarIndex = [];\n    const callback = ({ index, value }) => {\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        scalarData[index] = segmentIndex;\n        scalarIndex.push(index);\n    };\n    pointInSurroundingSphereCallback(imageData, [points[0], points[1]], callback, viewport);\n    const zMultiple = dimensions[0] * dimensions[1];\n    const minSlice = Math.floor(scalarIndex[0] / zMultiple);\n    const maxSlice = Math.floor(scalarIndex[scalarIndex.length - 1] / zMultiple);\n    const sliceArray = Array.from({ length: maxSlice - minSlice + 1 }, (v, k) => k + minSlice);\n    triggerSegmentationDataModified(segmentationId, sliceArray);\n}\nexport function fillInsideSphere(enabledElement, operationData) {\n    fillSphere(enabledElement, operationData, true);\n}\nexport function fillOutsideSphere(enabledElement, operationData) {\n    fillSphere(enabledElement, operationData, false);\n}\n//# sourceMappingURL=fillSphere.js.map","export {};\n//# sourceMappingURL=index.js.map","function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {\n    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n    if (sliceNormalIndex === -1) {\n        throw new Error('3D bounding boxes not supported in an oblique plane');\n    }\n    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n    return boundsIJK;\n}\nexport default extend2DBoundingBoxInViewAxis;\n//# sourceMappingURL=extend2DBoundingBoxInViewAxis.js.map","function getBoundingBoxAroundShape(points, dimensions) {\n    let xMin = Infinity;\n    let xMax = 0;\n    let yMin = Infinity;\n    let yMax = 0;\n    let zMin = Infinity;\n    let zMax = 0;\n    points.forEach((p) => {\n        xMin = Math.min(p[0], xMin);\n        xMax = Math.max(p[0], xMax);\n        yMin = Math.min(p[1], yMin);\n        yMax = Math.max(p[1], yMax);\n        zMin = Math.min(p[2], zMin);\n        zMax = Math.max(p[2], zMax);\n    });\n    xMin = Math.floor(xMin);\n    xMax = Math.floor(xMax);\n    yMin = Math.floor(yMin);\n    yMax = Math.floor(yMax);\n    zMin = Math.floor(zMin);\n    zMax = Math.floor(zMax);\n    if (dimensions) {\n        const [width, height, depth] = dimensions;\n        xMin = Math.max(0, xMin);\n        xMax = Math.min(width - 1, xMax);\n        yMin = Math.max(0, yMin);\n        yMax = Math.min(height - 1, yMax);\n        zMin = Math.max(0, zMin);\n        zMax = Math.min(depth - 1, zMax);\n    }\n    return [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n    ];\n}\nexport default getBoundingBoxAroundShape;\n//# sourceMappingURL=getBoundingBoxAroundShape.js.map","import extend2DBoundingBoxInViewAxis from './extend2DBoundingBoxInViewAxis';\nimport getBoundingBoxAroundShape from './getBoundingBoxAroundShape';\nexport { extend2DBoundingBoxInViewAxis, getBoundingBoxAroundShape };\n//# sourceMappingURL=index.js.map","import { utilities } from '@cornerstonejs/core';\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\nexport default function calibrateImageSpacing(imageId, renderingEngine, rowPixelSpacing, columnPixelSpacing) {\n    if (!columnPixelSpacing) {\n        columnPixelSpacing = rowPixelSpacing;\n    }\n    calibratedPixelSpacingMetadataProvider.add(imageId, {\n        rowPixelSpacing,\n        columnPixelSpacing,\n    });\n    const viewports = renderingEngine.getStackViewports();\n    viewports.forEach((viewport) => {\n        const imageIds = viewport.getImageIds();\n        if (imageIds.includes(imageId)) {\n            viewport.calibrateSpacing(imageId);\n        }\n    });\n}\n//# sourceMappingURL=calibrateImageSpacing.js.map","var Events;\n(function (Events) {\n    Events[\"CLIP_STOPPED\"] = \"CORNERSTONE_CINE_TOOL_STOPPED\";\n    Events[\"CLIP_STARTED\"] = \"CORNERSTONE_CINE_TOOL_STARTED\";\n})(Events || (Events = {}));\nexport default Events;\n//# sourceMappingURL=events.js.map","import { playClip, stopClip } from './playClip';\nimport Events from './events';\nimport { getToolState, addToolState } from './state';\nexport { playClip, stopClip, Events, getToolState, addToolState };\n//# sourceMappingURL=index.js.map","import { glMatrix, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, getEnabledElement, StackViewport, VolumeViewport, cache, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState } from './state';\nimport scroll from '../scroll';\nconst { triggerEvent } = csUtils;\nconst debounced = true;\nconst loop = true;\nconst dynamicVolumesPlayingMap = new Map();\nfunction playClip(element, playClipOptions) {\n    let playClipTimeouts;\n    let playClipIsTimeVarying;\n    if (element === undefined) {\n        throw new Error('playClip: element must not be undefined');\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('playClip: element must be a valid Cornerstone enabled element');\n    }\n    playClipOptions.dynamicCineEnabled =\n        playClipOptions.dynamicCineEnabled ?? true;\n    const { viewport } = enabledElement;\n    const volume = _getVolumeFromViewport(viewport);\n    const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n    let playClipData = getToolState(element);\n    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n    if (isDynamicCinePlaying) {\n        _stopDynamicVolumeCine(element);\n    }\n    if (!playClipData) {\n        playClipData = {\n            intervalId: undefined,\n            framesPerSecond: 30,\n            lastFrameTimeStamp: undefined,\n            ignoreFrameTimeVector: false,\n            usingFrameTimeVector: false,\n            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n            reverse: playClipOptions.reverse ?? false,\n            loop: playClipOptions.loop ?? true,\n        };\n        addToolState(element, playClipData);\n    }\n    else {\n        _stopClip(element, isDynamicCinePlaying);\n    }\n    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n    if (playClipOptions.framesPerSecond < 0 ||\n        playClipOptions.framesPerSecond > 0) {\n        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n        playClipData.reverse = playClipData.framesPerSecond < 0;\n        playClipData.ignoreFrameTimeVector = true;\n    }\n    if (playClipData.ignoreFrameTimeVector !== true &&\n        playClipData.frameTimeVector &&\n        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n        playClipContext.frameTimeVectorEnabled) {\n        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);\n        playClipTimeouts = timeouts;\n        playClipIsTimeVarying = isTimeVarying;\n    }\n    const playClipAction = () => {\n        const { numScrollSteps, currentStepIndex } = playClipContext;\n        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n        const newStepIndexOutOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;\n        if (!loop && newStepIndexOutOfRange) {\n            _stopClip(element, isDynamicCinePlaying);\n            const eventDetail = { element };\n            triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n            return;\n        }\n        if (newStepIndex >= numScrollSteps) {\n            newStepIndex = 0;\n        }\n        else if (newStepIndex < 0) {\n            newStepIndex = numScrollSteps - 1;\n        }\n        const delta = newStepIndex - currentStepIndex;\n        if (delta) {\n            playClipContext.scroll(delta);\n        }\n    };\n    if (isDynamicCinePlaying) {\n        dynamicVolumesPlayingMap.set(volume.volumeId, element);\n    }\n    if (playClipTimeouts &&\n        playClipTimeouts.length > 0 &&\n        playClipIsTimeVarying) {\n        playClipData.usingFrameTimeVector = true;\n        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {\n            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);\n            playClipAction();\n        }, 0);\n    }\n    else {\n        playClipData.usingFrameTimeVector = false;\n        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));\n    }\n    const eventDetail = {\n        element,\n    };\n    triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\nfunction stopClip(element) {\n    _stopClip(element, true);\n}\nfunction _stopClip(element, stopDynamicCine) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement)\n        return;\n    const { viewport } = enabledElement;\n    const cineToolData = getToolState(viewport.element);\n    if (cineToolData) {\n        _stopClipWithData(cineToolData);\n    }\n    if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n        _stopDynamicVolumeCine(element);\n    }\n}\nfunction _stopDynamicVolumeCine(element) {\n    const { viewport } = getEnabledElement(element);\n    const volume = _getVolumeFromViewport(viewport);\n    if (volume?.isDynamicVolume()) {\n        const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n        dynamicVolumesPlayingMap.delete(volume.volumeId);\n        if (dynamicCineElement && dynamicCineElement !== element) {\n            stopClip(dynamicCineElement);\n        }\n    }\n}\nfunction _getPlayClipTimeouts(vector, speed) {\n    let i;\n    let sample;\n    let delay;\n    let sum = 0;\n    const limit = vector.length;\n    const timeouts = [];\n    let isTimeVarying = false;\n    if (typeof speed !== 'number' || speed <= 0) {\n        speed = 1;\n    }\n    for (i = 1; i < limit; i++) {\n        delay = (Number(vector[i]) / speed) | 0;\n        timeouts.push(delay);\n        if (i === 1) {\n            sample = delay;\n        }\n        else if (delay !== sample) {\n            isTimeVarying = true;\n        }\n        sum += delay;\n    }\n    if (timeouts.length > 0) {\n        if (isTimeVarying) {\n            delay = (sum / timeouts.length) | 0;\n        }\n        else {\n            delay = timeouts[0];\n        }\n        timeouts.push(delay);\n    }\n    return { timeouts, isTimeVarying };\n}\nfunction _stopClipWithData(playClipData) {\n    const id = playClipData.intervalId;\n    if (typeof id !== 'undefined') {\n        playClipData.intervalId = undefined;\n        if (playClipData.usingFrameTimeVector) {\n            clearTimeout(id);\n        }\n        else {\n            clearInterval(id);\n        }\n    }\n}\nfunction _getVolumesFromViewport(viewport) {\n    return viewport\n        .getActors()\n        .map((actor) => cache.getVolume(actor.uid))\n        .filter((volume) => !!volume);\n}\nfunction _getVolumeFromViewport(viewport) {\n    const volumes = _getVolumesFromViewport(viewport);\n    const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n    return dynamicVolume ?? volumes[0];\n}\nfunction _createStackViewportCinePlayContext(viewport) {\n    const imageIds = viewport.getImageIds();\n    return {\n        get numScrollSteps() {\n            return imageIds.length;\n        },\n        get currentStepIndex() {\n            return viewport.getTargetImageIdIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        scroll(delta) {\n            scroll(viewport, { delta, debounceLoading: debounced });\n        },\n    };\n}\nfunction _createVolumeViewportCinePlayContext(viewport, volume) {\n    const { volumeId } = volume;\n    const cachedScrollInfo = {\n        viewPlaneNormal: vec3.create(),\n        scrollInfo: null,\n    };\n    const getScrollInfo = () => {\n        const camera = viewport.getCamera();\n        const updateCache = !cachedScrollInfo.scrollInfo ||\n            !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n        if (updateCache) {\n            const scrollInfo = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n            cachedScrollInfo.scrollInfo = scrollInfo;\n        }\n        return cachedScrollInfo.scrollInfo;\n    };\n    return {\n        get numScrollSteps() {\n            return getScrollInfo().numScrollSteps;\n        },\n        get currentStepIndex() {\n            return getScrollInfo().currentStepIndex;\n        },\n        get frameTimeVectorEnabled() {\n            const camera = viewport.getCamera();\n            const volumeViewPlaneNormal = volume.direction\n                .slice(6, 9)\n                .map((x) => -x);\n            const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n            return glMatrix.equals(dot, 1);\n        },\n        scroll(delta) {\n            getScrollInfo().currentStepIndex += delta;\n            scroll(viewport, { delta });\n        },\n    };\n}\nfunction _createDynamicVolumeViewportCinePlayContext(volume) {\n    return {\n        get numScrollSteps() {\n            return volume.numTimePoints;\n        },\n        get currentStepIndex() {\n            return volume.timePointIndex;\n        },\n        get frameTimeVectorEnabled() {\n            return false;\n        },\n        scroll(delta) {\n            volume.timePointIndex += delta;\n        },\n    };\n}\nfunction _createCinePlayContext(viewport, playClipOptions) {\n    if (viewport instanceof StackViewport) {\n        return _createStackViewportCinePlayContext(viewport);\n    }\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n            return _createDynamicVolumeViewportCinePlayContext(volume);\n        }\n        return _createVolumeViewportCinePlayContext(viewport, volume);\n    }\n    throw new Error('Unknown viewport type');\n}\nexport { playClip, stopClip };\n//# sourceMappingURL=playClip.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nconst state = {};\nfunction addToolState(element, data) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    state[viewportId] = data;\n}\nfunction getToolState(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    return state[viewportId];\n}\nexport { addToolState, getToolState };\n//# sourceMappingURL=state.js.map","export function clip(val, low, high) {\n    return Math.min(Math.max(low, val), high);\n}\nexport function clipToBox(point, box) {\n    point.x = clip(point.x, 0, box.width);\n    point.y = clip(point.y, 0, box.height);\n}\nexport default clip;\n//# sourceMappingURL=clip.js.map","import isObject from './isObject';\nfunction debounce(func, wait, options) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = Number(wait) || 0;\n    if (isObject(options)) {\n        leading = Boolean(options.leading);\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\nexport default debounce;\n//# sourceMappingURL=debounce.js.map","export default function getTextBoxCoordsCanvas(annotationCanvasPoints) {\n    const corners = _determineCorners(annotationCanvasPoints);\n    const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n    const textBoxCanvas = [corners.right[0], centerY];\n    return textBoxCanvas;\n}\nfunction _determineCorners(canvasPoints) {\n    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n    const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n    const top = handlesTopToBottom[0];\n    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n    return {\n        top,\n        bottom,\n        right,\n    };\n    function _compareX(a, b) {\n        return a[0] < b[0] ? -1 : 1;\n    }\n    function _compareY(a, b) {\n        return a[1] < b[1] ? -1 : 1;\n    }\n}\n//# sourceMappingURL=getTextBoxCoordsCanvas.js.map","import getTextBoxCoordsCanvas from './getTextBoxCoordsCanvas';\nexport { getTextBoxCoordsCanvas };\n//# sourceMappingURL=index.js.map","import { Enums } from '@cornerstonejs/core';\nfunction generateImageFromTimeData(dynamicVolume, operation, frameNumbers) {\n    const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n    const numFrames = frames.length;\n    if (frames.length <= 1) {\n        throw new Error('Please provide two or more time points');\n    }\n    const typedArrays = dynamicVolume.getScalarDataArrays();\n    const arrayLength = typedArrays[0].length;\n    const finalArray = new Float32Array(arrayLength);\n    if (operation === Enums.DynamicOperatorType.SUM) {\n        for (let i = 0; i < numFrames; i++) {\n            const currentArray = typedArrays[frames[i]];\n            for (let j = 0; j < arrayLength; j++) {\n                finalArray[j] += currentArray[j];\n            }\n        }\n        return finalArray;\n    }\n    if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n        if (frames.length > 2) {\n            throw new Error('Please provide only 2 time points for subtraction.');\n        }\n        for (let j = 0; j < arrayLength; j++) {\n            finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n        }\n        return finalArray;\n    }\n    if (operation === Enums.DynamicOperatorType.AVERAGE) {\n        for (let i = 0; i < numFrames; i++) {\n            const currentArray = typedArrays[frames[i]];\n            for (let j = 0; j < arrayLength; j++) {\n                finalArray[j] += currentArray[j];\n            }\n        }\n        for (let k = 0; k < arrayLength; k++) {\n            finalArray[k] = finalArray[k] / numFrames;\n        }\n        return finalArray;\n    }\n}\nexport default generateImageFromTimeData;\n//# sourceMappingURL=generateImageFromTimeData.js.map","import { utilities, cache } from '@cornerstonejs/core';\nfunction getDataInTime(dynamicVolume, options) {\n    let dataInTime;\n    const frames = options.frameNumbers || [\n        ...Array(dynamicVolume.numTimePoints).keys(),\n    ];\n    if (!options.maskVolumeId && !options.imageCoordinate) {\n        throw new Error('No ROI provided');\n    }\n    if (options.maskVolumeId && options.imageCoordinate) {\n        throw new Error('Please provide only one ROI');\n    }\n    if (options.maskVolumeId) {\n        const segmentationVolume = cache.getVolume(options.maskVolumeId);\n        const indexArray = segmentationVolume\n            .getScalarData()\n            .map((_, i) => i)\n            .filter((i) => segmentationVolume.getScalarData()[i] !== 0);\n        const dataInTime = _getTimePointDataMask(frames, indexArray, dynamicVolume);\n        return dataInTime;\n    }\n    if (options.imageCoordinate) {\n        const dataInTime = _getTimePointDataCoordinate(frames, options.imageCoordinate, dynamicVolume);\n        return dataInTime;\n    }\n    return dataInTime;\n}\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n    const { dimensions, imageData } = volume;\n    const index = imageData.worldToIndex(coordinate);\n    index[0] = Math.floor(index[0]);\n    index[1] = Math.floor(index[1]);\n    index[2] = Math.floor(index[2]);\n    if (!utilities.indexWithinDimensions(index, dimensions)) {\n        throw new Error('outside bounds');\n    }\n    const yMultiple = dimensions[0];\n    const zMultiple = dimensions[0] * dimensions[1];\n    const allScalarData = volume.getScalarDataArrays();\n    const value = [];\n    frames.forEach((frame) => {\n        const activeScalarData = allScalarData[frame];\n        const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n        value.push(activeScalarData[scalarIndex]);\n    });\n    return value;\n}\nfunction _getTimePointDataMask(frames, indexArray, volume) {\n    const allScalarData = volume.getScalarDataArrays();\n    const value = [];\n    for (let i = 0; i < indexArray.length; i++) {\n        const indexValues = [];\n        frames.forEach((frame) => {\n            const activeScalarData = allScalarData[frame];\n            indexValues.push(activeScalarData[indexArray[i]]);\n        });\n        value.push(indexValues);\n    }\n    return value;\n}\nexport default getDataInTime;\n//# sourceMappingURL=getDataInTime.js.map","import getDataInTime from './getDataInTime';\nimport generateImageFromTimeData from './generateImageFromTimeData';\nexport { getDataInTime };\nexport { generateImageFromTimeData };\n//# sourceMappingURL=index.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\nfunction getAnnotationNearPoint(element, canvasPoint, proximity = 5) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('getAnnotationNearPoint: enabledElement not found');\n    }\n    return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);\n}\nfunction getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const { _toolInstances: tools } = toolGroup;\n    for (const name in tools) {\n        const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);\n        if (found) {\n            return found;\n        }\n    }\n    return null;\n}\nfunction findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {\n    const { viewport } = enabledElement;\n    const annotations = getAnnotations(tool.constructor.toolName, viewport?.element);\n    const currentId = viewport?.getCurrentImageId?.();\n    if (annotations?.length) {\n        const { element } = enabledElement.viewport;\n        for (const annotation of annotations) {\n            const referencedImageId = annotation.metadata?.referencedImageId;\n            if ((currentId && referencedImageId && currentId !== referencedImageId) ||\n                !tool.isPointNearTool) {\n                continue;\n            }\n            if (tool.isPointNearTool(element, annotation, point, proximity, '') ||\n                tool.getHandleNearImagePoint(element, annotation, point, proximity)) {\n                return annotation;\n            }\n        }\n    }\n    return null;\n}\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n//# sourceMappingURL=getAnnotationNearPoint.js.map","function getModalityUnit(modality, isPreScaled, isSuvScaled) {\n    if (modality === 'CT') {\n        return 'HU';\n    }\n    else if (modality === 'PT' &&\n        isPreScaled === true &&\n        isSuvScaled === true) {\n        return 'SUV';\n    }\n    else {\n        return '';\n    }\n}\nexport { getModalityUnit };\n//# sourceMappingURL=getModalityUnit.js.map","import { ToolGroupManager } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nexport default function getToolsWithModesForElement(element, modesFilter) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return [];\n    }\n    const enabledTools = [];\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        if (!toolOptions) {\n            continue;\n        }\n        if (modesFilter.includes(toolOptions.mode)) {\n            const toolInstance = toolGroup.getToolInstance(toolName);\n            enabledTools.push(toolInstance);\n        }\n    }\n    return enabledTools;\n}\n//# sourceMappingURL=getToolsWithModesForElement.js.map","import { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, } from './getAnnotationNearPoint';\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport clip from './clip';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport jumpToSlice from './viewport/jumpToSlice';\nimport pointInShapeCallback from './pointInShapeCallback';\nimport pointInSurroundingSphereCallback from './pointInSurroundingSphereCallback';\nimport scroll from './scroll';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport * as stackPrefetch from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport { triggerEvent } from '@cornerstonejs/core';\nexport { math, planar, viewportFilters, drawing, debounce, dynamicVolume, throttle, orientation, isObject, touch, triggerEvent, calibrateImageSpacing, segmentation, triggerAnnotationRenderForViewportIds, triggerAnnotationRender, pointInShapeCallback, pointInSurroundingSphereCallback, getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, jumpToSlice, viewport, cine, clip, boundingBox, rectangleROITool, planarFreehandROITool, stackPrefetch, scroll, };\n//# sourceMappingURL=index.js.map","function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport default isObject;\n//# sourceMappingURL=isObject.js.map","import { vec3 } from 'gl-matrix';\nexport default function angleBetweenLines(line1, line2) {\n    const [p1, p2] = line1;\n    const [p3, p4] = line2;\n    const v1 = vec3.sub(vec3.create(), p2, p1);\n    const v2 = vec3.sub(vec3.create(), p3, p4);\n    const dot = vec3.dot(v1, v2);\n    const v1Length = vec3.length(v1);\n    const v2Length = vec3.length(v2);\n    const cos = dot / (v1Length * v2Length);\n    const radian = Math.acos(cos);\n    return (radian * 180) / Math.PI;\n}\n//# sourceMappingURL=angleBetweenLines.js.map","import { distanceToPoint } from '../point';\nexport default function getCanvasCircleCorners(circleCanvasPoints) {\n    const [center, end] = circleCanvasPoints;\n    const radius = distanceToPoint(center, end);\n    const topLeft = [center[0] - radius, center[1] - radius];\n    const bottomRight = [center[0] + radius, center[1] + radius];\n    return [topLeft, bottomRight];\n}\n//# sourceMappingURL=getCanvasCircleCorners.js.map","import { distanceToPoint } from '../point';\nexport default function getCanvasCircleRadius(circleCanvasPoints) {\n    const [center, end] = circleCanvasPoints;\n    return distanceToPoint(center, end);\n}\n//# sourceMappingURL=getCanvasCircleRadius.js.map","import getCanvasCircleRadius from './getCanvasCircleRadius';\nimport getCanvasCircleCorners from './getCanvasCircleCorners';\nexport { getCanvasCircleRadius, getCanvasCircleCorners };\n//# sourceMappingURL=index.js.map","export default function getCanvasEllipseCorners(ellipseCanvasPoints) {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [topLeft, bottomRight];\n}\n//# sourceMappingURL=getCanvasEllipseCorners.js.map","import pointInEllipse from './pointInEllipse';\nimport getCanvasEllipseCorners from './getCanvasEllipseCorners';\nexport { pointInEllipse, getCanvasEllipseCorners };\n//# sourceMappingURL=index.js.map","export default function pointInEllipse(ellipse, pointLPS) {\n    const { center: circleCenterWorld, xRadius, yRadius, zRadius } = ellipse;\n    const [x, y, z] = pointLPS;\n    const [x0, y0, z0] = circleCenterWorld;\n    let inside = 0;\n    if (xRadius !== 0) {\n        inside += ((x - x0) * (x - x0)) / (xRadius * xRadius);\n    }\n    if (yRadius !== 0) {\n        inside += ((y - y0) * (y - y0)) / (yRadius * yRadius);\n    }\n    if (zRadius !== 0) {\n        inside += ((z - z0) * (z - z0)) / (zRadius * zRadius);\n    }\n    return inside <= 1;\n}\n//# sourceMappingURL=pointInEllipse.js.map","import * as vec2 from './vec2';\nimport * as ellipse from './ellipse';\nimport * as lineSegment from './line';\nimport * as rectangle from './rectangle';\nimport * as polyline from './polyline';\nimport * as point from './point';\nexport { vec2, ellipse, lineSegment, rectangle, polyline, point };\n//# sourceMappingURL=index.js.map","import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(lineStart, lineEnd, point) {\n    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');\n    }\n    return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n//# sourceMappingURL=distanceToPoint.js.map","function dist2(p1, p2) {\n    return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n}\nexport default function distanceToPointSquared(lineStart, lineEnd, point) {\n    const d2 = dist2(lineStart, lineEnd);\n    if (d2 === 0) {\n        return dist2(point, lineStart);\n    }\n    const t = ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n        (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n        d2;\n    if (t < 0) {\n        return dist2(point, lineStart);\n    }\n    if (t > 1) {\n        return dist2(point, lineEnd);\n    }\n    const pt = [\n        lineStart[0] + t * (lineEnd[0] - lineStart[0]),\n        lineStart[1] + t * (lineEnd[1] - lineStart[1]),\n    ];\n    return dist2(point, pt);\n}\n//# sourceMappingURL=distanceToPointSquared.js.map","import distanceToPoint from './distanceToPoint';\nimport distanceToPointSquared from './distanceToPointSquared';\nimport intersectLine from './intersectLine';\nexport { distanceToPoint, distanceToPointSquared, intersectLine };\n//# sourceMappingURL=index.js.map","function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return;\n    }\n    const denom = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denom;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denom;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n//# sourceMappingURL=intersectLine.js.map","const midPoint = (...args) => {\n    const ret = args[0].length === 2 ? [0, 0] : [0, 0, 0];\n    const len = args.length;\n    for (const arg of args) {\n        ret[0] += arg[0] / len;\n        ret[1] += arg[1] / len;\n        if (ret.length === 3)\n            ret[2] += arg[2] / len;\n    }\n    return ret;\n};\nconst midPoint2 = midPoint;\nexport default midPoint;\nexport { midPoint2 };\n//# sourceMappingURL=midPoint.js.map","export default function distanceToPoint(p1, p2) {\n    if (p1?.length !== 2 || p2?.length !== 2) {\n        throw Error('points should have 2 elements of [x, y]');\n    }\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n//# sourceMappingURL=distanceToPoint.js.map","import distanceToPoint from './distanceToPoint';\nexport { distanceToPoint };\n//# sourceMappingURL=index.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nconst addCanvasPointsToArray = (element, canvasPoints, newCanvasPoint, commonData) => {\n    const { xDir, yDir, spacing } = commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const lastWorldPos = viewport.canvasToWorld(canvasPoints[canvasPoints.length - 1]);\n    const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    const numPointsToAdd = Math.max(Math.floor(xDist / spacing[0]), Math.floor(yDist / spacing[0]));\n    if (numPointsToAdd > 1) {\n        const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n        const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n        const canvasDir = vec2.create();\n        vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n        vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n        const distPerPoint = canvasDist / numPointsToAdd;\n        for (let i = 1; i <= numPointsToAdd; i++) {\n            canvasPoints.push([\n                lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n                lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n            ]);\n        }\n    }\n    else {\n        canvasPoints.push(newCanvasPoint);\n    }\n    return numPointsToAdd;\n};\nexport default addCanvasPointsToArray;\n//# sourceMappingURL=addCanvasPointsToArray.js.map","export default function calculateAreaOfPoints(points) {\n    const n = points.length;\n    let area = 0.0;\n    let j = n - 1;\n    for (let i = 0; i < n; i++) {\n        area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n        j = i;\n    }\n    return Math.abs(area / 2.0);\n}\n//# sourceMappingURL=calculateAreaOfPoints.js.map","import { vec2 } from 'gl-matrix';\nfunction getAllIntersectionsWithPolyline(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    const intersections = [];\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (doesIntersect(p1, q1, p2, q2)) {\n            intersections.push([j, i]);\n        }\n        j = i;\n    }\n    return intersections;\n}\nfunction getIntersectionCoordinatesWithPolyline(points, p1, q1, closed = true) {\n    const result = [];\n    const polylineIndexes = getAllIntersectionsWithPolyline(points, p1, q1, closed);\n    for (let i = 0; i < polylineIndexes.length; i++) {\n        const p2 = points[polylineIndexes[i][0]];\n        const q2 = points[polylineIndexes[i][1]];\n        const intersection = getIntersection(p1, q1, p2, q2);\n        result.push(intersection);\n    }\n    return result;\n}\nfunction getFirstIntersectionWithPolyline(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (doesIntersect(p1, q1, p2, q2)) {\n            return [j, i];\n        }\n        j = i;\n    }\n}\nfunction getClosestIntersectionWithPolyline(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    const intersections = [];\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (doesIntersect(p1, q1, p2, q2)) {\n            intersections.push([j, i]);\n        }\n        j = i;\n    }\n    if (intersections.length === 0) {\n        return;\n    }\n    const distances = [];\n    intersections.forEach((intersection) => {\n        const intersectionPoints = [\n            points[intersection[0]],\n            points[intersection[1]],\n        ];\n        const midpoint = [\n            (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n            (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n        ];\n        distances.push(vec2.distance(midpoint, p1));\n    });\n    const minDistance = Math.min(...distances);\n    const indexOfMinDistance = distances.indexOf(minDistance);\n    return {\n        segment: intersections[indexOfMinDistance],\n        distance: minDistance,\n    };\n}\nfunction doesIntersect(p1, q1, p2, q2) {\n    let result = false;\n    const orient = [\n        orientation(p1, q1, p2),\n        orientation(p1, q1, q2),\n        orientation(p2, q2, p1),\n        orientation(p2, q2, q1),\n    ];\n    if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n        return true;\n    }\n    if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n        result = true;\n    }\n    else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n        result = true;\n    }\n    else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n        result = true;\n    }\n    else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n        result = true;\n    }\n    return result;\n}\nfunction orientation(p, q, r) {\n    const orientationValue = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    if (orientationValue === 0) {\n        return 0;\n    }\n    return orientationValue > 0 ? 1 : 2;\n}\nfunction onSegment(p, q, r) {\n    if (q[0] <= Math.max(p[0], r[0]) &&\n        q[0] >= Math.min(p[0], r[0]) &&\n        q[1] <= Math.max(p[1], r[1]) &&\n        q[1] >= Math.min(p[1], r[1])) {\n        return true;\n    }\n    return false;\n}\nfunction getIntersection(p1, q1, p2, q2) {\n    const denominator = (q2[1] - p2[1]) * (q1[0] - p1[0]) - (q2[0] - p2[0]) * (q1[1] - p1[1]);\n    if (denominator == 0) {\n        return;\n    }\n    let a = p1[1] - p2[1];\n    let b = p1[0] - p2[0];\n    const numerator1 = (q2[0] - p2[0]) * a - (q2[1] - p2[1]) * b;\n    const numerator2 = (q1[0] - p1[0]) * a - (q1[1] - p1[1]) * b;\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n    const resultX = p1[0] + a * (q1[0] - p1[0]);\n    const resultY = p1[1] + a * (q1[1] - p1[1]);\n    return [resultX, resultY];\n}\nexport { getAllIntersectionsWithPolyline, getFirstIntersectionWithPolyline, getClosestIntersectionWithPolyline, getIntersectionCoordinatesWithPolyline, };\n//# sourceMappingURL=getIntersectionWithPolyline.js.map","import { StackViewport } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst EPSILON = 1e-3;\nconst getSubPixelSpacingAndXYDirections = (viewport, subPixelResolution) => {\n    let spacing;\n    let xDir;\n    let yDir;\n    if (viewport instanceof StackViewport) {\n        const imageData = viewport.getImageData();\n        xDir = imageData.direction.slice(0, 3);\n        yDir = imageData.direction.slice(3, 6);\n        spacing = imageData.spacing;\n    }\n    else {\n        const imageData = viewport.getImageData();\n        const { direction, spacing: volumeSpacing } = imageData;\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const iVector = direction.slice(0, 3);\n        const jVector = direction.slice(3, 6);\n        const kVector = direction.slice(6, 9);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n        const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n        const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n        let xSpacing;\n        if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n            xSpacing = volumeSpacing[0];\n            xDir = iVector;\n        }\n        else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n            xSpacing = volumeSpacing[1];\n            xDir = jVector;\n        }\n        else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n            xSpacing = volumeSpacing[2];\n            xDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n        const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n        const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n        let ySpacing;\n        if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n            ySpacing = volumeSpacing[0];\n            yDir = iVector;\n        }\n        else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n            ySpacing = volumeSpacing[1];\n            yDir = jVector;\n        }\n        else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n            ySpacing = volumeSpacing[2];\n            yDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        spacing = [xSpacing, ySpacing];\n    }\n    const subPixelSpacing = [\n        spacing[0] / subPixelResolution,\n        spacing[1] / subPixelResolution,\n    ];\n    return { spacing: subPixelSpacing, xDir, yDir };\n};\nexport default getSubPixelSpacingAndXYDirections;\n//# sourceMappingURL=getSubPixelSpacingAndXYDirections.js.map","import { getFirstIntersectionWithPolyline, getClosestIntersectionWithPolyline, } from './getIntersectionWithPolyline';\nimport getSubPixelSpacingAndXYDirections from './getSubPixelSpacingAndXYDirections';\nimport pointsAreWithinCloseContourProximity from './pointsAreWithinCloseContourProximity';\nimport addCanvasPointsToArray from './addCanvasPointsToArray';\nimport pointCanProjectOnLine from './pointCanProjectOnLine';\nimport calculateAreaOfPoints from './calculateAreaOfPoints';\nexport { getFirstIntersectionWithPolyline, getClosestIntersectionWithPolyline, getSubPixelSpacingAndXYDirections, pointsAreWithinCloseContourProximity, addCanvasPointsToArray, pointCanProjectOnLine, calculateAreaOfPoints, };\n//# sourceMappingURL=index.js.map","import { vec2 } from 'gl-matrix';\nconst pointCanProjectOnLine = (p, p1, p2, proximity) => {\n    const p1p = [p[0] - p1[0], p[1] - p1[1]];\n    const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n    const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n    if (dot < 0) {\n        return false;\n    }\n    const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n    if (p1p2Mag === 0) {\n        return false;\n    }\n    const projectionVectorMag = dot / p1p2Mag;\n    const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n    const projectionVector = [\n        p1p2UnitVector[0] * projectionVectorMag,\n        p1p2UnitVector[1] * projectionVectorMag,\n    ];\n    const projectionPoint = [\n        p1[0] + projectionVector[0],\n        p1[1] + projectionVector[1],\n    ];\n    const distance = vec2.distance(p, projectionPoint);\n    if (distance > proximity) {\n        return false;\n    }\n    if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n        return false;\n    }\n    return true;\n};\nexport default pointCanProjectOnLine;\n//# sourceMappingURL=pointCanProjectOnLine.js.map","import { vec2 } from 'gl-matrix';\nconst pointsAreWithinCloseContourProximity = (p1, p2, closeContourProximity) => {\n    return vec2.dist(p1, p2) < closeContourProximity;\n};\nexport default pointsAreWithinCloseContourProximity;\n//# sourceMappingURL=pointsAreWithinCloseContourProximity.js.map","import * as lineSegment from '../line';\nfunction rectToLineSegments(left, top, width, height) {\n    const topLineStart = [left, top];\n    const topLineEnd = [left + width, top];\n    const rightLineStart = [left + width, top];\n    const rightLineEnd = [left + width, top + height];\n    const bottomLineStart = [left + width, top + height];\n    const bottomLineEnd = [left, top + height];\n    const leftLineStart = [left, top + height];\n    const leftLineEnd = [left, top];\n    const lineSegments = {\n        top: [topLineStart, topLineEnd],\n        right: [rightLineStart, rightLineEnd],\n        bottom: [bottomLineStart, bottomLineEnd],\n        left: [leftLineStart, leftLineEnd],\n    };\n    return lineSegments;\n}\nexport default function distanceToPoint(rect, point) {\n    if (rect.length !== 4 || point.length !== 2) {\n        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');\n    }\n    const [left, top, width, height] = rect;\n    let minDistance = 655535;\n    const lineSegments = rectToLineSegments(left, top, width, height);\n    Object.keys(lineSegments).forEach((segment) => {\n        const [lineStart, lineEnd] = lineSegments[segment];\n        const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n        if (distance < minDistance) {\n            minDistance = distance;\n        }\n    });\n    return minDistance;\n}\n//# sourceMappingURL=distanceToPoint.js.map","import distanceToPoint from './distanceToPoint';\nexport { distanceToPoint };\n//# sourceMappingURL=index.js.map","import pointInSphere from './pointInSphere';\nexport { pointInSphere };\n//# sourceMappingURL=index.js.map","export default function pointInSphere(sphere, pointLPS) {\n    const { center, radius } = sphere;\n    return ((pointLPS[0] - center[0]) ** 2 +\n        (pointLPS[1] - center[1]) ** 2 +\n        (pointLPS[2] - center[2]) ** 2 <=\n        radius ** 2);\n}\n//# sourceMappingURL=pointInSphere.js.map","export default function findClosestPoint(sourcePoints, targetPoint) {\n    let minPoint = [0, 0];\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    sourcePoints.forEach(function (sourcePoint) {\n        const distance = _distanceBetween(targetPoint, sourcePoint);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minPoint = [...sourcePoint];\n        }\n    });\n    return minPoint;\n}\nfunction _distanceBetween(p1, p2) {\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n//# sourceMappingURL=findClosestPoint.js.map","import findClosestPoint from './findClosestPoint';\nimport liangBarksyClip from './liangBarksyClip';\nexport { findClosestPoint, liangBarksyClip };\n//# sourceMappingURL=index.js.map","const EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\nfunction clipT(num, denom, c) {\n    const [tE, tL] = c;\n    if (Math.abs(denom) < EPSILON)\n        return num < 0;\n    const t = num / denom;\n    if (denom > 0) {\n        if (t > tL)\n            return 0;\n        if (t > tE)\n            c[0] = t;\n    }\n    else {\n        if (t < tE)\n            return 0;\n        if (t < tL)\n            c[1] = t;\n    }\n    return 1;\n}\nexport default function clip(a, b, box, da, db) {\n    const [x1, y1] = a;\n    const [x2, y2] = b;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    if (da === undefined || db === undefined) {\n        da = a;\n        db = b;\n    }\n    else {\n        da[0] = a[0];\n        da[1] = a[1];\n        db[0] = b[0];\n        db[1] = b[1];\n    }\n    if (Math.abs(dx) < EPSILON &&\n        Math.abs(dy) < EPSILON &&\n        x1 >= box[0] &&\n        x1 <= box[2] &&\n        y1 >= box[1] &&\n        y1 <= box[3]) {\n        return INSIDE;\n    }\n    const c = [0, 1];\n    if (clipT(box[0] - x1, dx, c) &&\n        clipT(x1 - box[2], -dx, c) &&\n        clipT(box[1] - y1, dy, c) &&\n        clipT(y1 - box[3], -dy, c)) {\n        const [tE, tL] = c;\n        if (tL < 1) {\n            db[0] = x1 + tL * dx;\n            db[1] = y1 + tL * dy;\n        }\n        if (tE > 0) {\n            da[0] += tE * dx;\n            da[1] += tE * dy;\n        }\n        return INSIDE;\n    }\n    return OUTSIDE;\n}\n//# sourceMappingURL=liangBarksyClip.js.map","export default function getOrientationStringLPS(vector) {\n    let orientation = '';\n    const orientationX = vector[0] < 0 ? 'R' : 'L';\n    const orientationY = vector[1] < 0 ? 'A' : 'P';\n    const orientationZ = vector[2] < 0 ? 'F' : 'H';\n    const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n    const MIN = 0.0001;\n    for (let i = 0; i < 3; i++) {\n        if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n            orientation += orientationX;\n            abs[0] = 0;\n        }\n        else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n            orientation += orientationY;\n            abs[1] = 0;\n        }\n        else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n            orientation += orientationZ;\n            abs[2] = 0;\n        }\n        else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n            orientation += orientationX + orientationY;\n            abs[0] = 0;\n            abs[1] = 0;\n        }\n        else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n            orientation += orientationX + orientationZ;\n            abs[0] = 0;\n            abs[2] = 0;\n        }\n        else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n            orientation += orientationY + orientationZ;\n            abs[1] = 0;\n            abs[2] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return orientation;\n}\n//# sourceMappingURL=getOrientationStringLPS.js.map","import getOrientationStringLPS from './getOrientationStringLPS';\nimport invertOrientationStringLPS from './invertOrientationStringLPS';\nexport { getOrientationStringLPS, invertOrientationStringLPS };\n//# sourceMappingURL=index.js.map","export default function invertOrientationStringLPS(orientationString) {\n    let inverted = orientationString.replace('H', 'f');\n    inverted = inverted.replace('F', 'h');\n    inverted = inverted.replace('R', 'l');\n    inverted = inverted.replace('L', 'r');\n    inverted = inverted.replace('A', 'p');\n    inverted = inverted.replace('P', 'a');\n    inverted = inverted.toUpperCase();\n    return inverted;\n}\n//# sourceMappingURL=invertOrientationStringLPS.js.map","import { StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nexport default function filterAnnotationsForDisplay(viewport, annotations) {\n    if (viewport instanceof StackViewport) {\n        const imageId = viewport.getCurrentImageId();\n        const colonIndex = imageId.indexOf(':');\n        const imageURI = imageId.substring(colonIndex + 1);\n        return annotations.filter((annotation) => {\n            if (!annotation.isVisible) {\n                return false;\n            }\n            const imageId = annotation.metadata.referencedImageId;\n            if (imageId === undefined) {\n                return false;\n            }\n            const colonIndex = imageId.indexOf(':');\n            const referenceImageURI = imageId.substring(colonIndex + 1);\n            return referenceImageURI === imageURI;\n        });\n    }\n    else if (viewport instanceof VolumeViewport) {\n        const camera = viewport.getCamera();\n        const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n        return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n    }\n    else {\n        throw new Error(`Viewport Type ${viewport.type} not supported`);\n    }\n}\n//# sourceMappingURL=filterAnnotationsForDisplay.js.map","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport default function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n    const annotationsWithinSlice = [];\n    for (const annotation of annotationsWithParallelNormals) {\n        const data = annotation.data;\n        const point = data.handles.points[0];\n        if (!annotation.isVisible) {\n            continue;\n        }\n        const dir = vec3.create();\n        vec3.sub(dir, focalPoint, point);\n        const dot = vec3.dot(dir, viewPlaneNormal);\n        if (Math.abs(dot) < halfSpacingInNormalDirection) {\n            annotationsWithinSlice.push(annotation);\n        }\n    }\n    return annotationsWithinSlice;\n}\n//# sourceMappingURL=filterAnnotationsWithinSlice.js.map","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nexport default function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {\n    const camera = viewport.getCamera();\n    const { position: cameraPosition } = camera;\n    const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);\n    const step = spacingInNormalDirection * stepSize;\n    const bounds = viewport.getBounds();\n    const xMin = bounds[0];\n    const xMax = bounds[1];\n    const vector = [0, 0, 0];\n    let point = [0, 0, 0];\n    vtkMath.subtract(worldPos, cameraPosition, vector);\n    let pickedPoint;\n    for (let pointT = xMin; pointT <= xMax; pointT = pointT + step) {\n        point = [pointT, 0, 0];\n        const t = (pointT - cameraPosition[0]) / vector[0];\n        point[1] = t * vector[1] + cameraPosition[1];\n        point[2] = t * vector[2] + cameraPosition[2];\n        if (_inBounds(point, bounds)) {\n            const intensity = viewport.getIntensityFromWorld(point);\n            const pointToPick = criteriaFunction(intensity, point);\n            if (pointToPick) {\n                pickedPoint = pointToPick;\n            }\n        }\n    }\n    return pickedPoint;\n}\nconst _inBounds = function (point, bounds) {\n    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n    return (point[0] > xMin &&\n        point[0] < xMax &&\n        point[1] > yMin &&\n        point[1] < yMax &&\n        point[2] > zMin &&\n        point[2] < zMax);\n};\n//# sourceMappingURL=getPointInLineOfSightWithCriteria.js.map","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...topLeftWorld);\n    const pos2 = vec3.fromValues(...bottomRightWorld);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n//# sourceMappingURL=getWorldWidthAndHeightFromCorners.js.map","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n//# sourceMappingURL=getWorldWidthAndHeightFromTwoPoints.js.map","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\nexport default {\n    filterAnnotationsWithinSlice,\n    getWorldWidthAndHeightFromCorners,\n    filterAnnotationsForDisplay,\n    getPointInLineOfSightWithCriteria,\n};\nexport { filterAnnotationsWithinSlice, getWorldWidthAndHeightFromCorners, filterAnnotationsForDisplay, getPointInLineOfSightWithCriteria, };\n//# sourceMappingURL=index.js.map","import interpolateAnnotation from './interpolateAnnotation';\nexport default {\n    interpolateAnnotation,\n};\nexport { interpolateAnnotation };\n//# sourceMappingURL=index.js.map","import { PlanarFreehandROITool } from '../../tools';\nimport { ToolGroupManager } from '../../store';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nfunction shouldPreventInterpolation(enabledElement, annotation, knotsRatioPercentage) {\n    if (!annotation?.data?.polyline || knotsRatioPercentage <= 0) {\n        return true;\n    }\n    if (!enabledElement.viewport) {\n        return true;\n    }\n    const { renderingEngineId, viewportId, FrameOfReferenceUID } = enabledElement;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (annotation.metadata.FrameOfReferenceUID !== FrameOfReferenceUID) {\n        return true;\n    }\n    if (!toolGroup) {\n        return true;\n    }\n    const toolInstance = toolGroup.getToolInstance(annotation.metadata.toolName);\n    if (!(toolInstance instanceof PlanarFreehandROITool)) {\n        return true;\n    }\n    return (toolInstance.isDrawing ||\n        toolInstance.isEditingOpen ||\n        toolInstance.isEditingClosed);\n}\nexport default function interpolateAnnotation(enabledElement, annotation, knotsRatioPercentage) {\n    if (shouldPreventInterpolation(enabledElement, annotation, knotsRatioPercentage)) {\n        return false;\n    }\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n    const interpolatedCanvasPoints = (interpolateSegmentPoints(canvasPoints, 0, canvasPoints.length, knotsRatioPercentage));\n    if (interpolatedCanvasPoints === canvasPoints) {\n        return false;\n    }\n    annotation.data.polyline = interpolatedCanvasPoints.map(viewport.canvasToWorld);\n    return true;\n}\n//# sourceMappingURL=interpolateAnnotation.js.map","import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldInterpolate(configuration) {\n    return (configuration?.interpolation?.interpolateOnAdd === true ||\n        configuration?.interpolation?.interpolateOnEdit === true);\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, interpolateOnAdd = false, interpolateOnEdit = false, } = interpolation;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? interpolateOnEdit : interpolateOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=interpolatePoints.js.map","import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n//# sourceMappingURL=bspline.js.map","import { interpolatePoints } from './algorithms/bspline';\nfunction getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {\n    const result = [];\n    const [intervalIni, intervalEnd] = closedInterval;\n    const intervalSize = intervalEnd - intervalIni + 1;\n    const intensity = Math.floor(intervalSize / minDistributionDistance);\n    let x = 0;\n    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    while (continuosDistributionValue <= intervalEnd) {\n        result.push(continuosDistributionValue);\n        x++;\n        continuosDistributionValue =\n            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    }\n    return result;\n}\nexport default function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {\n    const segmentSize = endIndex - iniIndex + 1;\n    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n        return points;\n    }\n    if (segmentSize / minKnotDistance < 2) {\n        return points;\n    }\n    const interpolationIniIndex = Math.max(0, iniIndex);\n    const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);\n    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n        interpolationIniIndex,\n        interpolationEndIndex,\n    ]);\n    const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n    return [\n        ...segmentPointsUnchangedBeg,\n        ...interpolatedPoints,\n        ...segmentPointsUnchangedEnd,\n    ];\n}\n//# sourceMappingURL=interpolateSegmentPoints.js.map","import { vec3 } from 'gl-matrix';\nexport default function pointInShapeCallback(imageData, pointInShapeFn, callback, boundsIJK) {\n    let iMin, iMax, jMin, jMax, kMin, kMax;\n    let scalarData;\n    if (imageData.getScalarData) {\n        scalarData = imageData.getScalarData();\n    }\n    else {\n        scalarData = imageData\n            .getPointData()\n            .getScalars()\n            .getData();\n    }\n    const dimensions = imageData.getDimensions();\n    if (!boundsIJK) {\n        iMin = 0;\n        iMax = dimensions[0];\n        jMin = 0;\n        jMax = dimensions[1];\n        kMin = 0;\n        kMax = dimensions[2];\n    }\n    else {\n        [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n    }\n    const start = vec3.fromValues(iMin, jMin, kMin);\n    const direction = imageData.getDirection();\n    const rowCosines = direction.slice(0, 3);\n    const columnCosines = direction.slice(3, 6);\n    const scanAxisNormal = direction.slice(6, 9);\n    const spacing = imageData.getSpacing();\n    const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n    const worldPosStart = imageData.indexToWorld(start);\n    const rowStep = vec3.fromValues(rowCosines[0] * rowSpacing, rowCosines[1] * rowSpacing, rowCosines[2] * rowSpacing);\n    const columnStep = vec3.fromValues(columnCosines[0] * columnSpacing, columnCosines[1] * columnSpacing, columnCosines[2] * columnSpacing);\n    const scanAxisStep = vec3.fromValues(scanAxisNormal[0] * scanAxisSpacing, scanAxisNormal[1] * scanAxisSpacing, scanAxisNormal[2] * scanAxisSpacing);\n    const yMultiple = dimensions[0];\n    const zMultiple = dimensions[0] * dimensions[1];\n    for (let k = kMin; k <= kMax; k++) {\n        for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n                const pointIJK = [i, j, k];\n                const dI = i - iMin;\n                const dJ = j - jMin;\n                const dK = k - kMin;\n                const startWorld = worldPosStart;\n                const pointLPS = [\n                    startWorld[0] +\n                        dI * rowStep[0] +\n                        dJ * columnStep[0] +\n                        dK * scanAxisStep[0],\n                    startWorld[1] +\n                        dI * rowStep[1] +\n                        dJ * columnStep[1] +\n                        dK * scanAxisStep[1],\n                    startWorld[2] +\n                        dI * rowStep[2] +\n                        dJ * columnStep[2] +\n                        dK * scanAxisStep[2],\n                ];\n                if (pointInShapeFn(pointLPS, pointIJK)) {\n                    const index = k * zMultiple + j * yMultiple + i;\n                    const value = scalarData[index];\n                    callback({ value, index, pointIJK, pointLPS });\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=pointInShapeCallback.js.map","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback from './pointInShapeCallback';\nimport { getBoundingBoxAroundShape } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nexport default function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {\n    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);\n    const sphereObj = {\n        center: centerWorld,\n        radius: radiusWorld,\n    };\n    pointInShapeCallback(imageData, (pointLPS) => pointInSphere(sphereObj, pointLPS), callback, boundsIJK);\n}\nfunction _getBounds(circlePoints, imageData, viewport) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    let boundsIJK;\n    if (!viewport) {\n        const centerIJK = transformWorldToIndex(imageData, centerWorld);\n        const spacings = imageData.getSpacing();\n        const minSpacing = Math.min(...spacings);\n        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n        boundsIJK = [\n            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n        ];\n        return {\n            boundsIJK,\n            centerWorld: centerWorld,\n            radiusWorld,\n        };\n    }\n    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n    };\n}\nfunction _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {\n    const [bottom, top] = circlePoints;\n    const dimensions = imageData.getDimensions();\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n    const sphereCornersIJK = [\n        transformWorldToIndex(imageData, topLeftWorld),\n        (transformWorldToIndex(imageData, bottomRightWorld)),\n    ];\n    const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n    return boundsIJK;\n}\n//# sourceMappingURL=pointInSurroundingSphereCallback.js.map","import { utilities as csUtils } from '@cornerstonejs/core';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\nfunction getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {\n    const AllBoundsIJK = [];\n    annotations.forEach((annotation) => {\n        const { data } = annotation;\n        const { points } = data.handles;\n        const { imageData, dimensions } = referenceVolume;\n        let pointsToUse = points;\n        if (data.cachedStats?.projectionPoints) {\n            const { projectionPoints } = data.cachedStats;\n            pointsToUse = [].concat(...projectionPoints);\n        }\n        const rectangleCornersIJK = pointsToUse.map((world) => csUtils.transformWorldToIndex(imageData, world));\n        let boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n        if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n            boundsIJK = extend2DBoundingBoxInViewAxis(boundsIJK, options.numSlicesToProject);\n        }\n        AllBoundsIJK.push(boundsIJK);\n    });\n    if (AllBoundsIJK.length === 1) {\n        return AllBoundsIJK[0];\n    }\n    const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {\n        return {\n            iMin: Math.min(accumulator.iMin, currentValue.iMin),\n            jMin: Math.min(accumulator.jMin, currentValue.jMin),\n            kMin: Math.min(accumulator.kMin, currentValue.kMin),\n            iMax: Math.max(accumulator.iMax, currentValue.iMax),\n            jMax: Math.max(accumulator.jMax, currentValue.jMax),\n            kMax: Math.max(accumulator.kMax, currentValue.kMax),\n        };\n    }, {\n        iMin: Infinity,\n        jMin: Infinity,\n        kMin: Infinity,\n        iMax: -Infinity,\n        jMax: -Infinity,\n        kMax: -Infinity,\n    });\n    return boundsIJK;\n}\nexport default getBoundsIJKFromRectangleAnnotations;\n//# sourceMappingURL=getBoundsIJKFromRectangleAnnotations.js.map","import getBoundsIJKFromRectangleAnnotations from './getBoundsIJKFromRectangleAnnotations';\nexport { getBoundsIJKFromRectangleAnnotations };\n//# sourceMappingURL=index.js.map","import { StackViewport, VolumeViewport, eventTarget, EVENTS, utilities as csUtils, getEnabledElement, } from '@cornerstonejs/core';\nexport default function scroll(viewport, options) {\n    const enabledElement = getEnabledElement(viewport.element);\n    if (!enabledElement) {\n        throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n    }\n    if (viewport instanceof StackViewport &&\n        viewport.getImageIds().length === 0) {\n        throw new Error('Scroll::Stack Viewport has no images');\n    }\n    const { type: viewportType } = viewport;\n    const { volumeId, delta } = options;\n    if (viewport instanceof StackViewport) {\n        viewport.scroll(delta, options.debounceLoading, options.loop);\n    }\n    else if (viewport instanceof VolumeViewport) {\n        scrollVolume(viewport, volumeId, delta);\n    }\n    else {\n        throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n    }\n}\nexport function scrollVolume(viewport, volumeId, delta) {\n    const { numScrollSteps, currentStepIndex, sliceRangeInfo } = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n    if (!sliceRangeInfo) {\n        return;\n    }\n    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n    const { focalPoint, viewPlaneNormal, position } = camera;\n    const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);\n    viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n    });\n    viewport.render();\n    const desiredStepIndex = currentStepIndex + delta;\n    if ((desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n        viewport.getCurrentImageId()) {\n        const VolumeScrollEventDetail = {\n            volumeId,\n            viewport,\n            delta,\n            desiredStepIndex,\n            currentStepIndex,\n            numScrollSteps,\n            currentImageId: viewport.getCurrentImageId(),\n        };\n        csUtils.triggerEvent(eventTarget, EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS, VolumeScrollEventDetail);\n    }\n}\n//# sourceMappingURL=scroll.js.map","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\nexport function setBrushSizeForToolGroup(toolGroupId, brushSize) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.configuration.brushSize = brushSize;\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const { renderingEngineId } = viewportsInfoArray[0];\n    const viewportIds = toolGroup.getViewportIds();\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\nexport function getBrushSizeForToolGroup(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.brushSize;\n}\n//# sourceMappingURL=brushSizeForToolGroup.js.map","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\nexport function setBrushThresholdForToolGroup(toolGroupId, threshold) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.configuration.strategySpecificConfiguration.THRESHOLD_INSIDE_CIRCLE.threshold =\n            threshold;\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    if (!viewportsInfo.length) {\n        return;\n    }\n    const { renderingEngineId } = viewportsInfo[0];\n    const viewportIds = toolGroup.getViewportIds();\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\nexport function getBrushThresholdForToolGroup(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.strategySpecificConfiguration\n        .THRESHOLD_INSIDE_CIRCLE.threshold;\n}\n//# sourceMappingURL=brushThresholdForToolGroup.js.map","import { _cloneDeep } from 'lodash.clonedeep';\nimport { getEnabledElementByIds, volumeLoader, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nexport default async function createLabelmapVolumeForViewport(input) {\n    const { viewportId, renderingEngineId, options } = input;\n    let { segmentationId } = input;\n    const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n    if (!enabledElement) {\n        throw new Error('element disabled');\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof VolumeViewport)) {\n        throw new Error('Segmentation only supports VolumeViewport');\n    }\n    const { uid } = viewport.getDefaultActor();\n    if (segmentationId === undefined) {\n        segmentationId = `${uid}-based-segmentation-${options?.volumeId ?? csUtils.uuidv4().slice(0, 8)}`;\n    }\n    if (options) {\n        const properties = _cloneDeep(options);\n        await volumeLoader.createLocalVolume(properties, segmentationId);\n    }\n    else {\n        const { uid: volumeId } = viewport.getDefaultActor();\n        await volumeLoader.createAndCacheDerivedVolume(volumeId, {\n            volumeId: segmentationId,\n        });\n    }\n    return segmentationId;\n}\n//# sourceMappingURL=createLabelmapVolumeForViewport.js.map","import { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\nfunction createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = 'mergedLabelmap') {\n    labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n        if (!csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n            !csUtils.isEqual(direction, labelmaps[0].direction) ||\n            !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n            !csUtils.isEqual(origin, labelmaps[0].origin)) {\n            throw new Error('labelmaps must have the same size and shape');\n        }\n    });\n    const labelmap = labelmaps[0];\n    const arrayType = labelmap.getScalarData().constructor;\n    const outputData = new arrayType(labelmap.getScalarData().length);\n    labelmaps.forEach((labelmap) => {\n        const scalarData = labelmap.getScalarData();\n        for (let i = 0; i < scalarData.length; i++) {\n            if (scalarData[i] === segmentIndex) {\n                outputData[i] = segmentIndex;\n            }\n        }\n    });\n    const options = {\n        scalarData: outputData,\n        metadata: labelmap.metadata,\n        spacing: labelmap.spacing,\n        origin: labelmap.origin,\n        direction: labelmap.direction,\n        dimensions: labelmap.dimensions,\n    };\n    const preventCache = true;\n    const mergedVolume = volumeLoader.createLocalVolume(options, volumeId, preventCache);\n    return mergedVolume;\n}\nexport default createMergedLabelmapForIndex;\n//# sourceMappingURL=createMergedLabelmapForIndex.js.map","function floodFill(getter, seed, options = {}) {\n    const onFlood = options.onFlood;\n    const onBoundary = options.onBoundary;\n    const equals = options.equals || defaultEquals;\n    const diagonals = options.diagonals || false;\n    const startNode = get(seed);\n    const permutations = prunedPermutations();\n    const stack = [];\n    const flooded = [];\n    const visits = {};\n    const bounds = {};\n    stack.push({ currentArgs: seed });\n    while (stack.length > 0) {\n        flood(stack.pop());\n    }\n    return {\n        flooded,\n        boundaries: boundaries(),\n    };\n    function flood(job) {\n        const getArgs = job.currentArgs;\n        const prevArgs = job.previousArgs;\n        if (visited(getArgs)) {\n            return;\n        }\n        markAsVisited(getArgs);\n        if (member(getArgs)) {\n            markAsFlooded(getArgs);\n            pushAdjacent(getArgs);\n        }\n        else {\n            markAsBoundary(prevArgs);\n        }\n    }\n    function visited(key) {\n        return visits[key] === true;\n    }\n    function markAsVisited(key) {\n        visits[key] = true;\n    }\n    function member(getArgs) {\n        const node = safely(get, [getArgs]);\n        return safely(equals, [node, startNode]);\n    }\n    function markAsFlooded(getArgs) {\n        flooded.push(getArgs);\n        if (onFlood) {\n            onFlood(...getArgs);\n        }\n    }\n    function markAsBoundary(prevArgs) {\n        bounds[prevArgs] = prevArgs;\n        if (onBoundary) {\n            onBoundary(...prevArgs);\n        }\n    }\n    function pushAdjacent(getArgs) {\n        for (let i = 0; i < permutations.length; i += 1) {\n            const perm = permutations[i];\n            const nextArgs = getArgs.slice(0);\n            for (let j = 0; j < getArgs.length; j += 1) {\n                nextArgs[j] += perm[j];\n            }\n            stack.push({\n                currentArgs: nextArgs,\n                previousArgs: getArgs,\n            });\n        }\n    }\n    function get(getArgs) {\n        return getter(...getArgs);\n    }\n    function safely(f, args) {\n        try {\n            return f(...args);\n        }\n        catch (error) {\n            return;\n        }\n    }\n    function prunedPermutations() {\n        const permutations = permute(seed.length);\n        return permutations.filter(function (perm) {\n            const count = countNonZeroes(perm);\n            return count !== 0 && (count === 1 || diagonals);\n        });\n    }\n    function permute(length) {\n        const perms = [];\n        const permutation = function (string) {\n            return string.split('').map(function (c) {\n                return parseInt(c, 10) - 1;\n            });\n        };\n        for (let i = 0; i < Math.pow(3, length); i += 1) {\n            const string = lpad(i.toString(3), '0', length);\n            perms.push(permutation(string));\n        }\n        return perms;\n    }\n    function boundaries() {\n        const array = [];\n        for (const key in bounds) {\n            if (bounds[key] !== undefined) {\n                array.unshift(bounds[key]);\n            }\n        }\n        return array;\n    }\n}\nfunction defaultEquals(a, b) {\n    return a === b;\n}\nfunction countNonZeroes(array) {\n    let count = 0;\n    for (let i = 0; i < array.length; i += 1) {\n        if (array[i] !== 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction lpad(string, character, length) {\n    const array = new Array(length + 1);\n    const pad = array.join(character);\n    return (pad + string).slice(-length);\n}\nexport default floodFill;\n//# sourceMappingURL=floodFill.js.map","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nexport default function getDefaultRepresentationConfig(segmentation) {\n    const { type: representationType } = segmentation;\n    switch (representationType) {\n        case SegmentationRepresentation.Labelmap:\n            return getDefaultLabelmapConfig();\n        default:\n            throw new Error(`Unknown representation type: ${representationType}`);\n    }\n}\n//# sourceMappingURL=getDefaultRepresentationConfig.js.map","import thresholdVolumeByRange from './thresholdVolumeByRange';\nimport rectangleROIThresholdVolumeByRange from './rectangleROIThresholdVolumeByRange';\nimport createMergedLabelmapForIndex from './createMergedLabelmapForIndex';\nimport isValidRepresentationConfig from './isValidRepresentationConfig';\nimport getDefaultRepresentationConfig from './getDefaultRepresentationConfig';\nimport createLabelmapVolumeForViewport from './createLabelmapVolumeForViewport';\nimport { triggerSegmentationRender } from './triggerSegmentationRender';\nimport floodFill from './floodFill';\nimport { getBrushSizeForToolGroup, setBrushSizeForToolGroup, } from './brushSizeForToolGroup';\nimport { getBrushThresholdForToolGroup, setBrushThresholdForToolGroup, } from './brushThresholdForToolGroup';\nimport thresholdSegmentationByRange from './thresholdSegmentationByRange';\nexport { thresholdVolumeByRange, createMergedLabelmapForIndex, isValidRepresentationConfig, getDefaultRepresentationConfig, createLabelmapVolumeForViewport, rectangleROIThresholdVolumeByRange, triggerSegmentationRender, floodFill, getBrushSizeForToolGroup, setBrushSizeForToolGroup, getBrushThresholdForToolGroup, setBrushThresholdForToolGroup, thresholdSegmentationByRange, };\n//# sourceMappingURL=index.js.map","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nexport default function isValidRepresentationConfig(representationType, config) {\n    switch (representationType) {\n        case SegmentationRepresentation.Labelmap:\n            return isValidLabelmapConfig(config);\n        default:\n            throw new Error(`Unknown representation type: ${representationType}`);\n    }\n}\n//# sourceMappingURL=isValidRepresentationConfig.js.map","import { state } from '../../stateManagement/annotation';\nimport { RectangleROIStartEndThresholdTool, RectangleROIThresholdTool, } from '../../tools';\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nfunction rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {\n    const annotations = annotationUIDs.map((annotationUID) => {\n        return state.getAnnotation(annotationUID);\n    });\n    _validateAnnotations(annotations);\n    let boundsIJK;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const volumeSize = thresholdVolumeInformation[i].volume.getScalarData().length;\n        if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n            boundsIJK = getBoundsIJKFromRectangleAnnotations(annotations, thresholdVolumeInformation[i].volume, options);\n        }\n    }\n    const outputSegmentationVolume = thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK });\n    return outputSegmentationVolume;\n}\nfunction _validateAnnotations(annotations) {\n    const validToolNames = [\n        RectangleROIThresholdTool.toolName,\n        RectangleROIStartEndThresholdTool.toolName,\n    ];\n    for (const annotation of annotations) {\n        const name = annotation.metadata.toolName;\n        if (!validToolNames.includes(name)) {\n            throw new Error('rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations');\n        }\n    }\n}\nexport default rectangleROIThresholdVolumeByRange;\n//# sourceMappingURL=rectangleROIThresholdVolumeByRange.js.map","import { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes, } from './utilities';\nfunction thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType) {\n    const scalarData = segmentationVolume.getScalarData();\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    volumeInfoList.forEach((volumeInfo) => {\n        const { volumeSize } = volumeInfo;\n        if (volumeSize === scalarData.length) {\n            _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n        }\n        else {\n            _handleDifferentSizeVolume(scalarData, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);\n        }\n    });\n    triggerSegmentationDataModified(segmentationVolume.volumeId);\n    return segmentationVolume;\n}\nfunction _handleDifferentSizeVolume(scalarData, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {\n    const { imageData, lower, upper, dimensions } = volumeInfo;\n    let total, overlaps, range;\n    for (let i = 0; i < scalarData.length; i++) {\n        if (scalarData[i] === segmentationIndex) {\n            const overlapBounds = getVoxelOverlap(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));\n            const callbackOverlap = ({ value }) => {\n                total = total + 1;\n                if (value >= range.lower && value <= range.upper) {\n                    overlaps = overlaps + 1;\n                }\n            };\n            total = 0;\n            overlaps = 0;\n            range = { lower, upper };\n            let overlapTest = false;\n            pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n            overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n            scalarData[i] = overlapTest ? segmentationIndex : 0;\n        }\n    }\n    return { total, range, overlaps };\n}\nfunction _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo) {\n    const { referenceValues, lower, upper } = volumeInfo;\n    for (let i = 0; i < scalarData.length; i++) {\n        if (scalarData[i] === segmentationIndex) {\n            const value = referenceValues[i];\n            scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n        }\n    }\n}\nexport default thresholdSegmentationByRange;\n//# sourceMappingURL=thresholdSegmentationByRange.js.map","import { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes, } from './utilities';\nfunction thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const scalarData = segmentationVolume.getScalarData();\n    const { overwrite, boundsIJK } = options;\n    const overlapType = options?.overlapType || 0;\n    if (overwrite) {\n        for (let i = 0; i < scalarData.length; i++) {\n            scalarData[i] = 0;\n        }\n    }\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    let overlaps, total, range;\n    const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n        const callbackOverlap = ({ value }) => {\n            total = total + 1;\n            if (value >= range.lower && value <= range.upper) {\n                overlaps = overlaps + 1;\n            }\n        };\n        const { imageData, dimensions, lower, upper } = volumeInfo;\n        const overlapBounds = getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter);\n        total = 0;\n        overlaps = 0;\n        range = { lower, upper };\n        let overlapTest = false;\n        pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n        if (overlapType === 0) {\n            overlapTest = overlaps > 0;\n        }\n        else if (overlapType == 1) {\n            overlapTest = overlaps === total;\n        }\n        return overlapTest;\n    };\n    const testRange = (volumeInfo, pointIJK) => {\n        const { imageData, referenceValues, lower, upper } = volumeInfo;\n        const offset = imageData.computeOffsetIndex(pointIJK);\n        const value = referenceValues[offset];\n        if (value <= lower || value >= upper) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    const callback = ({ index, pointIJK, pointLPS }) => {\n        let insert = volumeInfoList.length > 0;\n        for (let i = 0; i < volumeInfoList.length; i++) {\n            if (volumeInfoList[i].volumeSize === scalarData.length) {\n                insert = testRange(volumeInfoList[i], pointIJK);\n            }\n            else {\n                insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);\n            }\n            if (!insert) {\n                break;\n            }\n        }\n        if (insert)\n            scalarData[index] = 1;\n    };\n    pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n    triggerSegmentationDataModified(segmentationVolume.volumeId);\n    return segmentationVolume;\n}\nexport default thresholdVolumeByRange;\n//# sourceMappingURL=thresholdVolumeByRange.js.map","import { triggerEvent, eventTarget, getRenderingEngine, Enums, } from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport { getToolGroup, getToolGroupForViewport, } from '../../store/ToolGroupManager';\nimport SegmentationDisplayTool from '../../tools/displayTools/SegmentationDisplayTool';\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._renderFlaggedToolGroups = () => {\n            this._throwIfDestroyed();\n            const toolGroupIds = Array.from(this._needsRender.values());\n            for (const toolGroupId of toolGroupIds) {\n                this._triggerRender(toolGroupId);\n                this._needsRender.delete(toolGroupId);\n                if (this._needsRender.size === 0) {\n                    this._animationFrameSet = false;\n                    this._animationFrameHandle = null;\n                    return;\n                }\n            }\n        };\n    }\n    removeToolGroup(toolGroupId) {\n        this._needsRender.delete(toolGroupId);\n        if (this._needsRender.size === 0) {\n            this._reset();\n        }\n    }\n    renderToolGroupSegmentations(toolGroupId) {\n        this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setToolGroupSegmentationToBeRenderedNextFrame(toolGroupIds) {\n        toolGroupIds.forEach((toolGroupId) => {\n            this._needsRender.add(toolGroupId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedToolGroups);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(toolGroupId) {\n        const toolGroup = getToolGroup(toolGroupId);\n        if (!toolGroup) {\n            console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n            return;\n        }\n        const { viewportsInfo } = toolGroup;\n        const viewports = [];\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            if (!renderingEngine) {\n                console.warn('rendering Engine has been destroyed');\n                return;\n            }\n            viewports.push(renderingEngine.getViewport(viewportId));\n        });\n        const segmentationDisplayToolInstance = toolGroup.getToolInstance(SegmentationDisplayTool.toolName);\n        if (!segmentationDisplayToolInstance) {\n            console.warn('No segmentation tool found inside', toolGroupId);\n            return;\n        }\n        function onSegmentationRender(evt) {\n            const { element, viewportId, renderingEngineId } = evt.detail;\n            element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n            if (!toolGroup) {\n                console.warn('toolGroup has been destroyed');\n                return;\n            }\n            const eventDetail = {\n                toolGroupId: toolGroup.id,\n                viewportId,\n            };\n            triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                ...eventDetail,\n            });\n        }\n        viewports.forEach(({ element }) => {\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n        });\n        segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n    }\n    _reset() {\n        window.cancelAnimationFrame(this._animationFrameHandle);\n        this._needsRender.clear();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n    }\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nfunction triggerSegmentationRender(toolGroupId) {\n    segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n//# sourceMappingURL=triggerSegmentationRender.js.map","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\nexport default function getBrushToolInstances(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof BrushTool);\n    return brushBasedToolInstances;\n}\nconst equalsCheck = (a, b) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\nexport function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {\n    const voxelCornersWorld = [];\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            for (let k = 0; k < 2; k++) {\n                const point = voxelCenter;\n                point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n                point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n                point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n                voxelCornersWorld.push(point);\n            }\n        }\n    }\n    const voxelCornersIJK = voxelCornersWorld.map((world) => csUtils.transformWorldToIndex(imageData, world));\n    const overlapBounds = getBoundingBoxAroundShape(voxelCornersIJK, dimensions);\n    return overlapBounds;\n}\nexport function processVolumes(segmentationVolume, thresholdVolumeInformation) {\n    const { spacing: segmentationSpacing, imageData: segmentationImageData } = segmentationVolume;\n    const scalarData = segmentationVolume.getScalarData();\n    const volumeInfoList = [];\n    let baseVolumeIdx = 0;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const { imageData, spacing, dimensions } = thresholdVolumeInformation[i].volume;\n        const volumeSize = thresholdVolumeInformation[i].volume.getScalarData().length;\n        if (volumeSize === scalarData.length &&\n            equalsCheck(spacing, segmentationSpacing)) {\n            baseVolumeIdx = i;\n        }\n        const referenceValues = imageData.getPointData().getScalars().getData();\n        const lower = thresholdVolumeInformation[i].lower;\n        const upper = thresholdVolumeInformation[i].upper;\n        volumeInfoList.push({\n            imageData,\n            referenceValues,\n            lower,\n            upper,\n            spacing,\n            dimensions,\n            volumeSize,\n        });\n    }\n    return {\n        volumeInfoList,\n        baseVolumeIdx,\n    };\n}\n//# sourceMappingURL=utilities.js.map","import { enable, disable, setConfiguration, getConfiguration, } from './stackPrefetch';\nexport { enable, disable, setConfiguration, getConfiguration };\n//# sourceMappingURL=index.js.map","import { getEnabledElement, StackViewport, imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, getConfiguration as getCoreConfiguration, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nconst requestType = Enums.RequestType.Prefetch;\nconst priority = 0;\nconst addToBeginning = true;\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    preserveExistingPool: false,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\nfunction range(lowEnd, highEnd) {\n    lowEnd = Math.round(lowEnd) || 0;\n    highEnd = Math.round(highEnd) || 0;\n    const arr = [];\n    let c = highEnd - lowEnd + 1;\n    if (c <= 0) {\n        return arr;\n    }\n    while (c--) {\n        arr[c] = highEnd--;\n    }\n    return arr;\n}\nfunction nearestIndex(arr, x) {\n    let low = 0;\n    let high = arr.length - 1;\n    arr.forEach((v, idx) => {\n        if (v < x) {\n            low = Math.max(idx, low);\n        }\n        else if (v > x) {\n            high = Math.min(idx, high);\n        }\n    });\n    return { low, high };\n}\nfunction getStackData(element) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('stackPrefetch: element must be a valid Cornerstone enabled element');\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof StackViewport)) {\n        throw new Error('stackPrefetch: element must be a StackViewport, VolumeViewport stackPrefetch not yet implemented');\n    }\n    return {\n        currentImageIdIndex: viewport.getCurrentImageIdIndex(),\n        imageIds: viewport.getImageIds(),\n    };\n}\nfunction prefetch(element) {\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = stackPrefetchData || {};\n    const stack = getStackData(element);\n    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    if (!stackPrefetch.indicesToRequest ||\n        !stackPrefetch.indicesToRequest.length) {\n        stackPrefetch.enabled = false;\n    }\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    indicesToRequestCopy.forEach(function (imageIdIndex) {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const imageLoadObject = cache.getImageLoadObject(imageId);\n        if (imageLoadObject) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n    const nearest = nearestIndex(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);\n    let imageId;\n    let nextImageIdIndex;\n    const preventCache = false;\n    function doneCallback(image) {\n        console.log('prefetch done: %s', image.imageId);\n        const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n        removeFromList(imageIdIndex);\n    }\n    let lowerIndex = nearest.low;\n    let higherIndex = nearest.high;\n    const imageIdsToPrefetch = [];\n    while (lowerIndex >= 0 ||\n        higherIndex < stackPrefetch.indicesToRequest.length) {\n        const currentIndex = stack.currentImageIdIndex;\n        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n            configuration.maxImagesToPrefetch;\n        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n            configuration.maxImagesToPrefetch;\n        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n        if (!shouldLoadHigher && !shouldLoadLower) {\n            break;\n        }\n        if (shouldLoadLower) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n        if (shouldLoadHigher) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n    }\n    const requestFn = (imageId, options) => imageLoader.loadAndCacheImage(imageId, options);\n    const { useNorm16Texture } = getCoreConfiguration().rendering;\n    imageIdsToPrefetch.forEach((imageId) => {\n        const options = {\n            targetBuffer: {\n                type: useNorm16Texture ? undefined : 'Float32Array',\n            },\n            preScale: {\n                enabled: true,\n            },\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction getPromiseRemovedHandler(element) {\n    return function (e) {\n        const eventData = e.detail;\n        let stackData;\n        try {\n            stackData = getStackData(element);\n        }\n        catch (error) {\n            return;\n        }\n        if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {\n            return;\n        }\n        const stack = stackData;\n        const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);\n        if (imageIdIndex < 0) {\n            return;\n        }\n        const stackPrefetchData = getToolState(element);\n        if (!stackPrefetchData ||\n            !stackPrefetchData.data ||\n            !stackPrefetchData.data.length) {\n            return;\n        }\n        stackPrefetchData.indicesToRequest.push(imageIdIndex);\n    };\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            prefetch(element);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nfunction enable(element) {\n    const stack = getStackData(element);\n    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = {\n        indicesToRequest: range(0, stack.imageIds.length - 1),\n        enabled: true,\n        direction: 1,\n    };\n    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);\n    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n    addToolState(element, stackPrefetchData);\n    prefetch(element);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n}\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData && stackPrefetchData.data.length) {\n        stackPrefetchData.enabled = false;\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nexport { enable, disable, getConfiguration, setConfiguration };\n//# sourceMappingURL=stackPrefetch.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nconst state = {};\nfunction addToolState(element, data) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    state[viewportId] = data;\n}\nfunction getToolState(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    return state[viewportId];\n}\nexport { addToolState, getToolState };\n//# sourceMappingURL=state.js.map","import debounce from './debounce';\nimport isObject from './isObject';\nfunction throttle(func, wait, options) {\n    let leading = true;\n    let trailing = true;\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    if (isObject(options)) {\n        leading = 'leading' in options ? Boolean(options.leading) : leading;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    return debounce(func, wait, {\n        leading,\n        trailing,\n        maxWait: wait,\n    });\n}\nexport default throttle;\n//# sourceMappingURL=throttle.js.map","function getDeltaPoints(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _subtractPoints2D(curr.page, last.page),\n        client: _subtractPoints2D(curr.client, last.client),\n        canvas: _subtractPoints2D(curr.canvas, last.canvas),\n        world: _subtractPoints3D(curr.world, last.world),\n    };\n}\nfunction getDeltaDistance(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _getDistance2D(curr.page, last.page),\n        client: _getDistance2D(curr.client, last.client),\n        canvas: _getDistance2D(curr.canvas, last.canvas),\n        world: _getDistance3D(curr.world, last.world),\n    };\n}\nfunction getDeltaRotation(currentPoints, lastPoints) {\n}\nfunction getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {\n    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n    const deltaDistance = {\n        page: currentDistance.page - lastDistance.page,\n        client: currentDistance.client - lastDistance.client,\n        canvas: currentDistance.canvas - lastDistance.canvas,\n        world: currentDistance.world - lastDistance.world,\n    };\n    return deltaDistance;\n}\nfunction copyPointsList(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction getMeanPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    });\n}\nfunction getMeanTouchPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n            touch: {\n                identifier: null,\n                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n                force: prev.touch.force + curr.touch.force / points.length,\n                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n            },\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n        touch: {\n            identifier: null,\n            radiusX: 0,\n            radiusY: 0,\n            force: 0,\n            rotationAngle: 0,\n        },\n    });\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nfunction _getMeanDistanceBetweenAllIPoints(points) {\n    const pairedDistance = [];\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n            if (i < j) {\n                pairedDistance.push({\n                    page: _getDistance2D(points[i].page, points[j].page),\n                    client: _getDistance2D(points[i].client, points[j].client),\n                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n                    world: _getDistance3D(points[i].world, points[j].world),\n                });\n            }\n        }\n    }\n    return pairedDistance.reduce((prev, curr) => {\n        return {\n            page: prev.page + curr.page / pairedDistance.length,\n            client: prev.client + curr.client / pairedDistance.length,\n            canvas: prev.canvas + curr.canvas / pairedDistance.length,\n            world: prev.world + curr.world / pairedDistance.length,\n        };\n    }, {\n        page: 0,\n        client: 0,\n        canvas: 0,\n        world: 0,\n    });\n}\nfunction _getDistance2D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));\n}\nfunction _getDistance3D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +\n        Math.pow(point0[1] - point1[1], 2) +\n        Math.pow(point0[2] - point1[2], 2));\n}\nexport { getMeanPoints, getMeanTouchPoints, copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaPoints, getDeltaDistance, getDeltaRotation, };\n//# sourceMappingURL=index.js.map","import { getEnabledElement, triggerEvent, getRenderingEngine, } from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nconst { Active, Passive, Enabled } = ToolModes;\nclass AnnotationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._renderFlaggedViewports = () => {\n            this._throwIfDestroyed();\n            const elements = Array.from(this._viewportElements.values());\n            for (let i = 0; i < elements.length; i++) {\n                const element = elements[i];\n                if (this._needsRender.has(element)) {\n                    this._triggerRender(element);\n                    this._needsRender.delete(element);\n                    if (this._needsRender.size === 0) {\n                        this._animationFrameSet = false;\n                        this._animationFrameHandle = null;\n                        return;\n                    }\n                }\n            }\n        };\n        this._viewportElements = new Map();\n    }\n    addViewportElement(viewportId, element) {\n        this._viewportElements.set(viewportId, element);\n    }\n    removeViewportElement(viewportId, element) {\n        this._viewportElements.delete(viewportId);\n        this._needsRender.delete(element);\n        this._reset();\n    }\n    renderViewport(element) {\n        this._setViewportsToBeRenderedNextFrame([element]);\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setAllViewportsToBeRenderedNextFrame() {\n        const elements = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            this._needsRender.add(element);\n        });\n        this._renderFlaggedViewports();\n    }\n    _setViewportsToBeRenderedNextFrame(elements) {\n        const elementsEnabled = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            if (elementsEnabled.indexOf(element) !== -1) {\n                this._needsRender.add(element);\n            }\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(element) {\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            console.warn('Element has been disabled');\n            return;\n        }\n        const renderingEngine = getRenderingEngine(enabledElement.renderingEngineId);\n        if (!renderingEngine) {\n            console.warn('rendering Engine has been destroyed');\n            return;\n        }\n        const enabledTools = getToolsWithModesForElement(element, [\n            Active,\n            Passive,\n            Enabled,\n        ]);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const eventDetail = {\n            element,\n            renderingEngineId,\n            viewportId,\n        };\n        drawSvg(element, (svgDrawingHelper) => {\n            let anyRendered = false;\n            const handleDrawSvg = (tool) => {\n                if (tool.renderAnnotation) {\n                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);\n                    anyRendered = anyRendered || rendered;\n                }\n            };\n            enabledTools.forEach(handleDrawSvg);\n            if (anyRendered) {\n                triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n            }\n        });\n    }\n    _reset() {\n        window.cancelAnimationFrame(this._animationFrameHandle);\n        this._needsRender.clear();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._setAllViewportsToBeRenderedNextFrame();\n    }\n}\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\nfunction triggerAnnotationRender(element) {\n    annotationRenderingEngine.renderViewport(element);\n}\nexport { annotationRenderingEngine, triggerAnnotationRender };\nexport default triggerAnnotationRender;\n//# sourceMappingURL=triggerAnnotationRender.js.map","import triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const { element } = renderingEngine.getViewport(viewportId);\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n//# sourceMappingURL=triggerAnnotationRenderForViewportIds.js.map","import { isViewportPreScaled } from './isViewportPreScaled';\nimport jumpToSlice from './jumpToSlice';\nimport jumpToWorld from './jumpToWorld';\nexport { isViewportPreScaled, jumpToSlice, jumpToWorld };\n//# sourceMappingURL=index.js.map","import { cache, StackViewport, BaseVolumeViewport, } from '@cornerstonejs/core';\nfunction isViewportPreScaled(viewport, targetId) {\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeId = targetId.split('volumeId:')[1];\n        const volume = cache.getVolume(volumeId);\n        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n    }\n    else if (viewport instanceof StackViewport) {\n        const { preScale } = viewport.getImageData() || {};\n        return !!preScale?.scaled;\n    }\n    else {\n        throw new Error('Viewport is not a valid type');\n    }\n}\nexport { isViewportPreScaled };\n//# sourceMappingURL=isViewportPreScaled.js.map","import { getEnabledElement, StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport clip from '../clip';\nimport scroll from '../scroll';\nasync function jumpToSlice(element, options = {}) {\n    const { imageIndex, debounceLoading, volumeId } = options;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('Element has been disabled');\n    }\n    const { viewport } = enabledElement;\n    const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(viewport, debounceLoading);\n    const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n    const delta = imageIndexToJump - currentImageIndex;\n    scroll(viewport, { delta, debounceLoading, volumeId });\n}\nfunction _getImageSliceData(viewport, debounceLoading) {\n    if (viewport instanceof StackViewport) {\n        return {\n            numberOfSlices: viewport.getImageIds().length,\n            imageIndex: debounceLoading\n                ? viewport.getTargetImageIdIndex()\n                : viewport.getCurrentImageIdIndex(),\n        };\n    }\n    else if (viewport instanceof VolumeViewport) {\n        return csUtils.getImageSliceDataForVolumeViewport(viewport);\n    }\n    else {\n        throw new Error('Unsupported viewport type');\n    }\n}\nfunction _getImageIndexToJump(numberOfSlices, imageIndex) {\n    const lastSliceIndex = numberOfSlices - 1;\n    return clip(imageIndex, 0, lastSliceIndex);\n}\nexport default jumpToSlice;\n//# sourceMappingURL=jumpToSlice.js.map","import { VolumeViewport } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nexport default function jumpToWorld(viewport, jumpWorld) {\n    if (!(viewport instanceof VolumeViewport)) {\n        return;\n    }\n    const { focalPoint } = viewport.getCamera();\n    const delta = [0, 0, 0];\n    vec3.sub(delta, jumpWorld, focalPoint);\n    _applyShift(viewport, delta);\n    return true;\n}\nfunction _applyShift(viewport, delta) {\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n    const dotProd = vec3.dot(delta, normal);\n    const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n    vec3.scale(projectedDelta, projectedDelta, dotProd);\n    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n        Math.abs(projectedDelta[1]) > 1e-3 ||\n        Math.abs(projectedDelta[2]) > 1e-3) {\n        const newFocalPoint = [0, 0, 0];\n        const newPosition = [0, 0, 0];\n        vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n        vec3.add(newPosition, camera.position, projectedDelta);\n        viewport.setCamera({\n            focalPoint: newFocalPoint,\n            position: newPosition,\n        });\n        viewport.render();\n    }\n}\n//# sourceMappingURL=jumpToWorld.js.map","export default function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {\n    const numViewports = viewports.length;\n    const viewportsWithFrameOfReferenceUID = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n            viewportsWithFrameOfReferenceUID.push(viewport);\n        }\n    }\n    return viewportsWithFrameOfReferenceUID;\n}\n//# sourceMappingURL=filterViewportsWithFrameOfReferenceUID.js.map","import { vec3 } from 'gl-matrix';\nexport function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {\n    return viewports.filter((viewport) => {\n        const vpCamera = viewport.getCamera();\n        const isParallel = Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n            EPS;\n        return isParallel;\n    });\n}\nexport default filterViewportsWithParallelNormals;\n//# sourceMappingURL=filterViewportsWithParallelNormals.js.map","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nconst { Active, Passive, Enabled } = ToolModes;\nexport default function filterViewportsWithToolEnabled(viewports, toolName) {\n    const numViewports = viewports.length;\n    const viewportsWithToolEnabled = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        const toolGroup = ToolGroupManager.getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n        if (!toolGroup) {\n            continue;\n        }\n        const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);\n        if (hasTool) {\n            viewportsWithToolEnabled.push(viewport);\n        }\n    }\n    return viewportsWithToolEnabled;\n}\nfunction _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {\n    const { toolOptions } = toolGroup;\n    const tool = toolOptions[toolName];\n    if (!tool) {\n        return false;\n    }\n    const toolMode = tool.mode;\n    return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n//# sourceMappingURL=filterViewportsWithToolEnabled.js.map","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport default function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);\n    viewports = filterViewportsWithToolEnabled(viewports, toolName);\n    const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n    if (requireParallelNormals) {\n        viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());\n    }\n    const viewportIds = viewports.map((vp) => vp.id);\n    return viewportIds;\n}\n//# sourceMappingURL=getViewportIdsWithToolToRender.js.map","import filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport getViewportIdsWithToolToRender from './getViewportIdsWithToolToRender';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport { filterViewportsWithToolEnabled, filterViewportsWithFrameOfReferenceUID, getViewportIdsWithToolToRender, filterViewportsWithParallelNormals, };\n//# sourceMappingURL=index.js.map","import macro from '../../macros.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport vtkPoints from '../../Common/Core/Points.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport { DesiredOutputPrecision } from '../../Common/DataModel/DataSetAttributes/Constants.js';\nimport { VtkDataTypes } from '../../Common/Core/DataArray/Constants.js';\n\nvar vtkErrorMacro = macro.vtkErrorMacro;\n\nfunction offsetCellArray(typedArray, offset) {\n  var currentIdx = 0;\n  return typedArray.map(function (value, index) {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return value;\n    }\n\n    return value + offset;\n  });\n}\n\nfunction appendCellData(dest, src, ptOffset, cellOffset) {\n  dest.set(offsetCellArray(src, ptOffset), cellOffset);\n} // ----------------------------------------------------------------------------\n// vtkAppendPolyData methods\n// ----------------------------------------------------------------------------\n\n\nfunction vtkAppendPolyData(publicAPI, model) {\n  // Set our classname\n  model.classHierarchy.push('vtkAppendPolyData');\n\n  publicAPI.requestData = function (inData, outData) {\n    // implement requestData\n    var numberOfInputs = publicAPI.getNumberOfInputPorts();\n\n    if (!numberOfInputs) {\n      vtkErrorMacro('No input specified.');\n      return;\n    }\n\n    if (numberOfInputs === 1) {\n      // pass through filter\n      outData[0] = inData[0];\n      return;\n    } // Allocate output\n\n\n    var output = vtkPolyData.newInstance();\n    var numPts = 0;\n    var pointType = 0;\n    var ttype = 1;\n    var firstType = 1;\n    var numVerts = 0;\n    var numLines = 0;\n    var numStrips = 0;\n    var numPolys = 0; // Field data is propagated to output only if present in all inputs\n\n    var hasPtNormals = true; // assume present by default\n\n    var hasPtTCoords = true;\n    var hasPtScalars = true;\n\n    for (var i = 0; i < numberOfInputs; i++) {\n      var ds = inData[i];\n\n      if (!ds) {\n        // eslint-disable-next-line\n        continue;\n      }\n\n      var dsNumPts = ds.getPoints().getNumberOfPoints();\n      numPts += dsNumPts;\n      numVerts += ds.getVerts().getNumberOfValues();\n      numLines += ds.getLines().getNumberOfValues();\n      numStrips += ds.getStrips().getNumberOfValues();\n      numPolys += ds.getPolys().getNumberOfValues();\n\n      if (dsNumPts) {\n        if (firstType) {\n          firstType = 0;\n          pointType = ds.getPoints().getDataType();\n        }\n\n        ttype = ds.getPoints().getDataType();\n        pointType = pointType > ttype ? pointType : ttype;\n      }\n\n      var ptD = ds.getPointData();\n\n      if (ptD) {\n        hasPtNormals = hasPtNormals && ptD.getNormals() !== null;\n        hasPtTCoords = hasPtTCoords && ptD.getTCoords() !== null;\n        hasPtScalars = hasPtScalars && ptD.getScalars() !== null;\n      } else {\n        hasPtNormals = false;\n        hasPtTCoords = false;\n        hasPtScalars = false;\n      }\n    }\n\n    if (model.outputPointsPrecision === DesiredOutputPrecision.SINGLE) {\n      pointType = VtkDataTypes.FLOAT;\n    } else if (model.outputPointsPrecision === DesiredOutputPrecision.DOUBLE) {\n      pointType = VtkDataTypes.DOUBLE;\n    }\n\n    var points = vtkPoints.newInstance({\n      dataType: pointType\n    });\n    points.setNumberOfPoints(numPts);\n    var pointData = points.getData();\n    var vertData = new Uint32Array(numVerts);\n    var lineData = new Uint32Array(numLines);\n    var stripData = new Uint32Array(numStrips);\n    var polyData = new Uint32Array(numPolys);\n    var newPtNormals = null;\n    var newPtTCoords = null;\n    var newPtScalars = null;\n    var lds = inData[numberOfInputs - 1];\n\n    if (hasPtNormals) {\n      var dsNormals = lds.getPointData().getNormals();\n      newPtNormals = vtkDataArray.newInstance({\n        numberOfComponents: 3,\n        numberOfTuples: numPts,\n        size: 3 * numPts,\n        dataType: dsNormals.getDataType(),\n        name: dsNormals.getName()\n      });\n    }\n\n    if (hasPtTCoords) {\n      var dsTCoords = lds.getPointData().getTCoords();\n      newPtTCoords = vtkDataArray.newInstance({\n        numberOfComponents: 2,\n        numberOfTuples: numPts,\n        size: 2 * numPts,\n        dataType: dsTCoords.getDataType(),\n        name: dsTCoords.getName()\n      });\n    }\n\n    if (hasPtScalars) {\n      var dsScalars = lds.getPointData().getScalars();\n      newPtScalars = vtkDataArray.newInstance({\n        numberOfComponents: dsScalars.getNumberOfComponents(),\n        numberOfTuples: numPts,\n        size: numPts * dsScalars.getNumberOfComponents(),\n        dataType: dsScalars.getDataType(),\n        name: dsScalars.getName()\n      });\n    }\n\n    numPts = 0;\n    numVerts = 0;\n    numLines = 0;\n    numStrips = 0;\n    numPolys = 0;\n\n    for (var _i = 0; _i < numberOfInputs; _i++) {\n      var _ds = inData[_i];\n      pointData.set(_ds.getPoints().getData(), numPts * 3);\n      appendCellData(vertData, _ds.getVerts().getData(), numPts, numVerts);\n      numVerts += _ds.getVerts().getNumberOfValues();\n      appendCellData(lineData, _ds.getLines().getData(), numPts, numLines);\n      numLines += _ds.getLines().getNumberOfValues();\n      appendCellData(stripData, _ds.getStrips().getData(), numPts, numStrips);\n      numStrips += _ds.getStrips().getNumberOfValues();\n      appendCellData(polyData, _ds.getPolys().getData(), numPts, numPolys);\n      numPolys += _ds.getPolys().getNumberOfValues();\n\n      var dsPD = _ds.getPointData();\n\n      if (hasPtNormals) {\n        var ptNorms = dsPD.getNormals();\n        newPtNormals.getData().set(ptNorms.getData(), numPts * 3);\n      }\n\n      if (hasPtTCoords) {\n        var ptTCoords = dsPD.getTCoords();\n        newPtTCoords.getData().set(ptTCoords.getData(), numPts * 2);\n      }\n\n      if (hasPtScalars) {\n        var ptScalars = dsPD.getScalars();\n        newPtScalars.getData().set(ptScalars.getData(), numPts * newPtScalars.getNumberOfComponents());\n      }\n\n      numPts += _ds.getPoints().getNumberOfPoints();\n    }\n\n    output.setPoints(points);\n    output.getVerts().setData(vertData);\n    output.getLines().setData(lineData);\n    output.getStrips().setData(stripData);\n    output.getPolys().setData(polyData);\n\n    if (newPtNormals) {\n      output.getPointData().setNormals(newPtNormals);\n    }\n\n    if (newPtTCoords) {\n      output.getPointData().setTCoords(newPtTCoords);\n    }\n\n    if (newPtScalars) {\n      output.getPointData().setScalars(newPtScalars);\n    }\n\n    outData[0] = output;\n  };\n} // ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n\nvar DEFAULT_VALUES = {\n  outputPointsPrecision: DesiredOutputPrecision.DEFAULT\n}; // ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues); // Build VTK API\n\n  macro.setGet(publicAPI, model, ['outputPointsPrecision']); // Make this a VTK object\n\n  macro.obj(publicAPI, model); // Also make it an algorithm with one input and one output\n\n  macro.algo(publicAPI, model, 1, 1); // Object specific methods\n\n  vtkAppendPolyData(publicAPI, model);\n} // ----------------------------------------------------------------------------\n\nvar newInstance = macro.newInstance(extend, 'vtkAppendPolyData'); // ----------------------------------------------------------------------------\n\nvar vtkAppendPolyData$1 = {\n  newInstance: newInstance,\n  extend: extend\n};\n\nexport { vtkAppendPolyData$1 as default, extend, newInstance };\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n"],"names":[],"sourceRoot":""}