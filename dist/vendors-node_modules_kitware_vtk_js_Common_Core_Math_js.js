"use strict";
(globalThis["webpackChunk"] = globalThis["webpackChunk"] || []).push([["vendors-node_modules_kitware_vtk_js_Common_Core_Math_js"],{

/***/ "../../../node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ClassHierarchy)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "../../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/get */ "../../../node_modules/@babel/runtime/helpers/esm/get.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "../../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ "../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js");








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/* eslint-disable prefer-rest-params */
var ClassHierarchy = /*#__PURE__*/function (_Array) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(ClassHierarchy, _Array);

  var _super = _createSuper(ClassHierarchy);

  function ClassHierarchy() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ClassHierarchy);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ClassHierarchy, [{
    key: "push",
    value: function push() {
      for (var i = 0; i < arguments.length; i++) {
        if (!this.includes(arguments[i])) {
          (0,_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(ClassHierarchy.prototype), "push", this).call(this, arguments[i]);
        }
      }

      return this.length;
    }
  }]);

  return ClassHierarchy;
}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_6__["default"])(Array));




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Common/Core/Math.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Common/Core/Math.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LUFactor3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aj),
/* harmony export */   LUSolve3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ak),
/* harmony export */   Pi: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.U),
/* harmony export */   add: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.k),
/* harmony export */   angleBetweenVectors: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.R),
/* harmony export */   areBoundsInitialized: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.P),
/* harmony export */   areEquals: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.B),
/* harmony export */   areMatricesEqual: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a),
/* harmony export */   arrayMax: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.Z),
/* harmony export */   arrayMin: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.Y),
/* harmony export */   arrayRange: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.D),
/* harmony export */   beginCombination: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a1),
/* harmony export */   binomial: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a0),
/* harmony export */   boundsIsWithinOtherBounds: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aR),
/* harmony export */   ceil: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.V),
/* harmony export */   ceilLog2: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__._),
/* harmony export */   clampAndNormalizeValue: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aN),
/* harmony export */   clampValue: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.C),
/* harmony export */   clampVector: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.c),
/* harmony export */   columnsToMat3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ai),
/* harmony export */   columnsToMat4: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ah),
/* harmony export */   computeBoundsFromPoints: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aM),
/* harmony export */   createArray: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.T),
/* harmony export */   createUninitializedBounds: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.N),
/* harmony export */   cross: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.j),
/* harmony export */   "default": () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.f),
/* harmony export */   degreesFromRadians: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.A),
/* harmony export */   determinant2x2: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.o),
/* harmony export */   determinant3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.y),
/* harmony export */   diagonalize3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.az),
/* harmony export */   distance2BetweenPoints: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.e),
/* harmony export */   dot: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.d),
/* harmony export */   dot2D: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aa),
/* harmony export */   estimateMatrixCondition: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aE),
/* harmony export */   extentIsWithinOtherExtent: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aQ),
/* harmony export */   factorial: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.$),
/* harmony export */   float2CssRGBA: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a_),
/* harmony export */   floatRGB2HexCode: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aZ),
/* harmony export */   floatToHex2: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aY),
/* harmony export */   floor: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.J),
/* harmony export */   gaussian: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a5),
/* harmony export */   gaussianAmplitude: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ac),
/* harmony export */   gaussianWeight: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ad),
/* harmony export */   getAdjustedScalarRange: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aP),
/* harmony export */   getMajorAxisIndex: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.E),
/* harmony export */   getScalarTypeFittingRange: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aO),
/* harmony export */   getSeed: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a4),
/* harmony export */   hex2float: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aH),
/* harmony export */   hsv2rgb: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.h),
/* harmony export */   identity: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ar),
/* harmony export */   identity3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aq),
/* harmony export */   inf: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aU),
/* harmony export */   invert3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ap),
/* harmony export */   invertMatrix: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aD),
/* harmony export */   isFinite: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aW),
/* harmony export */   isIdentity: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.as),
/* harmony export */   isIdentity3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.at),
/* harmony export */   isInf: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.F),
/* harmony export */   isNaN: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aX),
/* harmony export */   isNan: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.i),
/* harmony export */   isPowerOfTwo: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.Q),
/* harmony export */   jacobi: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.t),
/* harmony export */   jacobiN: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.p),
/* harmony export */   lab2rgb: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.I),
/* harmony export */   lab2xyz: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aI),
/* harmony export */   linearSolve3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.al),
/* harmony export */   luFactorLinearSystem: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aB),
/* harmony export */   luSolveLinearSystem: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aC),
/* harmony export */   matrix3x3ToQuaternion: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aw),
/* harmony export */   max: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.X),
/* harmony export */   min: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.W),
/* harmony export */   multiply3x3_mat3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.am),
/* harmony export */   multiply3x3_vect3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.O),
/* harmony export */   multiplyAccumulate: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.m),
/* harmony export */   multiplyAccumulate2D: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a7),
/* harmony export */   multiplyMatrix: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.an),
/* harmony export */   multiplyQuaternion: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ax),
/* harmony export */   multiplyScalar: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.w),
/* harmony export */   multiplyScalar2D: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a6),
/* harmony export */   nearestPowerOfTwo: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.M),
/* harmony export */   negInf: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aV),
/* harmony export */   nextCombination: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a2),
/* harmony export */   norm: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.n),
/* harmony export */   norm2D: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.af),
/* harmony export */   normalize: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.l),
/* harmony export */   normalize2D: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.L),
/* harmony export */   orthogonalize3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ay),
/* harmony export */   outer: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a8),
/* harmony export */   outer2D: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ae),
/* harmony export */   perpendiculars: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.q),
/* harmony export */   pointIsWithinBounds: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aS),
/* harmony export */   projectVector: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a9),
/* harmony export */   projectVector2D: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ab),
/* harmony export */   quaternionToMatrix3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.au),
/* harmony export */   radiansFromDegrees: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.r),
/* harmony export */   random: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.x),
/* harmony export */   randomSeed: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.a3),
/* harmony export */   rgb2hsv: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.G),
/* harmony export */   rgb2lab: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.H),
/* harmony export */   rgb2xyz: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aL),
/* harmony export */   round: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.K),
/* harmony export */   roundNumber: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.av),
/* harmony export */   roundVector: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.b),
/* harmony export */   rowsToMat3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.z),
/* harmony export */   rowsToMat4: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ag),
/* harmony export */   signedAngleBetweenVectors: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.S),
/* harmony export */   singularValueDecomposition3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aA),
/* harmony export */   solve3PointCircle: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aT),
/* harmony export */   solveHomogeneousLeastSquares: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aF),
/* harmony export */   solveLeastSquares: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aG),
/* harmony export */   solveLinearSystem: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.g),
/* harmony export */   subtract: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.s),
/* harmony export */   transpose3x3: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.ao),
/* harmony export */   uninitializeBounds: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.u),
/* harmony export */   xyz2lab: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aJ),
/* harmony export */   xyz2rgb: () => (/* reexport safe */ _Math_index_js__WEBPACK_IMPORTED_MODULE_5__.aK)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! seedrandom */ "../../../node_modules/seedrandom/index.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _macros_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../macros.js */ "../../../node_modules/@kitware/vtk.js/macros.js");
/* harmony import */ var _Math_Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Math/Constants.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js");
/* harmony import */ var _Math_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Math/index.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js");








/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EPSILON: () => (/* binding */ EPSILON),
/* harmony export */   IDENTITY: () => (/* binding */ IDENTITY),
/* harmony export */   IDENTITY_3X3: () => (/* binding */ IDENTITY_3X3),
/* harmony export */   VTK_SMALL_NUMBER: () => (/* binding */ VTK_SMALL_NUMBER),
/* harmony export */   "default": () => (/* binding */ Constants)
/* harmony export */ });
var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var IDENTITY_3X3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
var EPSILON = 1e-6;
var VTK_SMALL_NUMBER = 1.0e-12;
var Constants = {
  IDENTITY: IDENTITY,
  IDENTITY_3X3: IDENTITY_3X3,
  EPSILON: EPSILON,
  VTK_SMALL_NUMBER: VTK_SMALL_NUMBER
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/Common/Core/Math/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ factorial),
/* harmony export */   A: () => (/* binding */ degreesFromRadians),
/* harmony export */   B: () => (/* binding */ areEquals),
/* harmony export */   C: () => (/* binding */ clampValue),
/* harmony export */   D: () => (/* binding */ arrayRange),
/* harmony export */   E: () => (/* binding */ getMajorAxisIndex),
/* harmony export */   F: () => (/* binding */ isInf),
/* harmony export */   G: () => (/* binding */ rgb2hsv),
/* harmony export */   H: () => (/* binding */ rgb2lab),
/* harmony export */   I: () => (/* binding */ lab2rgb),
/* harmony export */   J: () => (/* binding */ floor),
/* harmony export */   K: () => (/* binding */ round),
/* harmony export */   L: () => (/* binding */ normalize2D),
/* harmony export */   M: () => (/* binding */ nearestPowerOfTwo),
/* harmony export */   N: () => (/* binding */ createUninitializedBounds),
/* harmony export */   O: () => (/* binding */ multiply3x3_vect3),
/* harmony export */   P: () => (/* binding */ areBoundsInitialized),
/* harmony export */   Q: () => (/* binding */ isPowerOfTwo),
/* harmony export */   R: () => (/* binding */ angleBetweenVectors),
/* harmony export */   S: () => (/* binding */ signedAngleBetweenVectors),
/* harmony export */   T: () => (/* binding */ createArray),
/* harmony export */   U: () => (/* binding */ Pi),
/* harmony export */   V: () => (/* binding */ ceil),
/* harmony export */   W: () => (/* binding */ min),
/* harmony export */   X: () => (/* binding */ max),
/* harmony export */   Y: () => (/* binding */ arrayMin),
/* harmony export */   Z: () => (/* binding */ arrayMax),
/* harmony export */   _: () => (/* binding */ ceilLog2),
/* harmony export */   a: () => (/* binding */ areMatricesEqual),
/* harmony export */   a0: () => (/* binding */ binomial),
/* harmony export */   a1: () => (/* binding */ beginCombination),
/* harmony export */   a2: () => (/* binding */ nextCombination),
/* harmony export */   a3: () => (/* binding */ randomSeed),
/* harmony export */   a4: () => (/* binding */ getSeed),
/* harmony export */   a5: () => (/* binding */ gaussian),
/* harmony export */   a6: () => (/* binding */ multiplyScalar2D),
/* harmony export */   a7: () => (/* binding */ multiplyAccumulate2D),
/* harmony export */   a8: () => (/* binding */ outer),
/* harmony export */   a9: () => (/* binding */ projectVector),
/* harmony export */   aA: () => (/* binding */ singularValueDecomposition3x3),
/* harmony export */   aB: () => (/* binding */ luFactorLinearSystem),
/* harmony export */   aC: () => (/* binding */ luSolveLinearSystem),
/* harmony export */   aD: () => (/* binding */ invertMatrix),
/* harmony export */   aE: () => (/* binding */ estimateMatrixCondition),
/* harmony export */   aF: () => (/* binding */ solveHomogeneousLeastSquares),
/* harmony export */   aG: () => (/* binding */ solveLeastSquares),
/* harmony export */   aH: () => (/* binding */ hex2float),
/* harmony export */   aI: () => (/* binding */ lab2xyz),
/* harmony export */   aJ: () => (/* binding */ xyz2lab),
/* harmony export */   aK: () => (/* binding */ xyz2rgb),
/* harmony export */   aL: () => (/* binding */ rgb2xyz),
/* harmony export */   aM: () => (/* binding */ computeBoundsFromPoints),
/* harmony export */   aN: () => (/* binding */ clampAndNormalizeValue),
/* harmony export */   aO: () => (/* binding */ getScalarTypeFittingRange),
/* harmony export */   aP: () => (/* binding */ getAdjustedScalarRange),
/* harmony export */   aQ: () => (/* binding */ extentIsWithinOtherExtent),
/* harmony export */   aR: () => (/* binding */ boundsIsWithinOtherBounds),
/* harmony export */   aS: () => (/* binding */ pointIsWithinBounds),
/* harmony export */   aT: () => (/* binding */ solve3PointCircle),
/* harmony export */   aU: () => (/* binding */ inf),
/* harmony export */   aV: () => (/* binding */ negInf),
/* harmony export */   aW: () => (/* binding */ isFinite),
/* harmony export */   aX: () => (/* binding */ isNaN),
/* harmony export */   aY: () => (/* binding */ floatToHex2),
/* harmony export */   aZ: () => (/* binding */ floatRGB2HexCode),
/* harmony export */   a_: () => (/* binding */ float2CssRGBA),
/* harmony export */   aa: () => (/* binding */ dot2D),
/* harmony export */   ab: () => (/* binding */ projectVector2D),
/* harmony export */   ac: () => (/* binding */ gaussianAmplitude),
/* harmony export */   ad: () => (/* binding */ gaussianWeight),
/* harmony export */   ae: () => (/* binding */ outer2D),
/* harmony export */   af: () => (/* binding */ norm2D),
/* harmony export */   ag: () => (/* binding */ rowsToMat4),
/* harmony export */   ah: () => (/* binding */ columnsToMat4),
/* harmony export */   ai: () => (/* binding */ columnsToMat3),
/* harmony export */   aj: () => (/* binding */ LUFactor3x3),
/* harmony export */   ak: () => (/* binding */ LUSolve3x3),
/* harmony export */   al: () => (/* binding */ linearSolve3x3),
/* harmony export */   am: () => (/* binding */ multiply3x3_mat3),
/* harmony export */   an: () => (/* binding */ multiplyMatrix),
/* harmony export */   ao: () => (/* binding */ transpose3x3),
/* harmony export */   ap: () => (/* binding */ invert3x3),
/* harmony export */   aq: () => (/* binding */ identity3x3),
/* harmony export */   ar: () => (/* binding */ identity),
/* harmony export */   as: () => (/* binding */ isIdentity),
/* harmony export */   at: () => (/* binding */ isIdentity3x3),
/* harmony export */   au: () => (/* binding */ quaternionToMatrix3x3),
/* harmony export */   av: () => (/* binding */ roundNumber),
/* harmony export */   aw: () => (/* binding */ matrix3x3ToQuaternion),
/* harmony export */   ax: () => (/* binding */ multiplyQuaternion),
/* harmony export */   ay: () => (/* binding */ orthogonalize3x3),
/* harmony export */   az: () => (/* binding */ diagonalize3x3),
/* harmony export */   b: () => (/* binding */ roundVector),
/* harmony export */   c: () => (/* binding */ clampVector),
/* harmony export */   d: () => (/* binding */ dot),
/* harmony export */   e: () => (/* binding */ distance2BetweenPoints),
/* harmony export */   f: () => (/* binding */ vtkMath),
/* harmony export */   g: () => (/* binding */ solveLinearSystem),
/* harmony export */   h: () => (/* binding */ hsv2rgb),
/* harmony export */   i: () => (/* binding */ isNan),
/* harmony export */   j: () => (/* binding */ cross),
/* harmony export */   k: () => (/* binding */ add),
/* harmony export */   l: () => (/* binding */ normalize),
/* harmony export */   m: () => (/* binding */ multiplyAccumulate),
/* harmony export */   n: () => (/* binding */ norm),
/* harmony export */   o: () => (/* binding */ determinant2x2),
/* harmony export */   p: () => (/* binding */ jacobiN),
/* harmony export */   q: () => (/* binding */ perpendiculars),
/* harmony export */   r: () => (/* binding */ radiansFromDegrees),
/* harmony export */   s: () => (/* binding */ subtract),
/* harmony export */   t: () => (/* binding */ jacobi),
/* harmony export */   u: () => (/* binding */ uninitializeBounds),
/* harmony export */   v: () => (/* binding */ vtkMath$1),
/* harmony export */   w: () => (/* binding */ multiplyScalar),
/* harmony export */   x: () => (/* binding */ random),
/* harmony export */   y: () => (/* binding */ determinant3x3),
/* harmony export */   z: () => (/* binding */ rowsToMat3)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! seedrandom */ "../../../node_modules/seedrandom/index.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _macros_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../macros.js */ "../../../node_modules/@kitware/vtk.js/macros.js");
/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Constants.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/Math/Constants.js");






var vtkErrorMacro = _macros_js__WEBPACK_IMPORTED_MODULE_3__["default"].vtkErrorMacro,
    vtkWarningMacro = _macros_js__WEBPACK_IMPORTED_MODULE_3__["default"].vtkWarningMacro; // ----------------------------------------------------------------------------

/* eslint-disable camelcase                                                  */

/* eslint-disable no-cond-assign                                             */

/* eslint-disable no-bitwise                                                 */

/* eslint-disable no-multi-assign                                            */
// ----------------------------------------------------------------------------

var randomSeedValue = 0;
var VTK_MAX_ROTATIONS = 20;

function notImplemented(method) {
  return function () {
    return vtkErrorMacro("vtkMath::".concat(method, " - NOT IMPLEMENTED"));
  };
} // Swap rows for n by n matrix


function swapRowsMatrix_nxn(matrix, n, row1, row2) {
  var tmp;

  for (var i = 0; i < n; i++) {
    tmp = matrix[row1 * n + i];
    matrix[row1 * n + i] = matrix[row2 * n + i];
    matrix[row2 * n + i] = tmp;
  }
} // Swap columns for n by n matrix


function swapColumnsMatrix_nxn(matrix, n, column1, column2) {
  var tmp;

  for (var i = 0; i < n; i++) {
    tmp = matrix[i * n + column1];
    matrix[i * n + column1] = matrix[i * n + column2];
    matrix[i * n + column2] = tmp;
  }
} // ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------


function createArray() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
  // faster than Array.from and/or while loop
  var res = Array(size);

  for (var i = 0; i < size; ++i) {
    res[i] = 0;
  }

  return res;
}
var Pi = function Pi() {
  return Math.PI;
};
function radiansFromDegrees(deg) {
  return deg / 180 * Math.PI;
}
function degreesFromRadians(rad) {
  return rad * 180 / Math.PI;
}
var round = Math.round,
    floor = Math.floor,
    ceil = Math.ceil,
    min = Math.min,
    max = Math.max;
function arrayMin(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var minValue = Infinity;

  for (var i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
  }

  return minValue;
}
function arrayMax(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var maxValue = -Infinity;

  for (var i = offset, len = arr.length; i < len; i += stride) {
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }

  return maxValue;
}
function arrayRange(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var minValue = Infinity;
  var maxValue = -Infinity;

  for (var i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }

    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }

  return [minValue, maxValue];
}
var ceilLog2 = notImplemented('ceilLog2');
var factorial = notImplemented('factorial');
function nearestPowerOfTwo(xi) {
  var v = 1;

  while (v < xi) {
    v *= 2;
  }

  return v;
}
function isPowerOfTwo(x) {
  return x === nearestPowerOfTwo(x);
}
function binomial(m, n) {
  var r = 1;

  for (var i = 1; i <= n; ++i) {
    r *= (m - i + 1) / i;
  }

  return Math.floor(r);
}
function beginCombination(m, n) {
  if (m < n) {
    return 0;
  }

  var r = createArray(n);

  for (var i = 0; i < n; ++i) {
    r[i] = i;
  }

  return r;
}
function nextCombination(m, n, r) {
  var status = 0;

  for (var i = n - 1; i >= 0; --i) {
    if (r[i] < m - n + i) {
      var j = r[i] + 1;

      while (i < n) {
        r[i++] = j++;
      }

      status = 1;
      break;
    }
  }

  return status;
}
function randomSeed(seed) {
  seedrandom__WEBPACK_IMPORTED_MODULE_2___default()("".concat(seed), {
    global: true
  });
  randomSeedValue = seed;
}
function getSeed() {
  return randomSeedValue;
}
function random() {
  var minValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var maxValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var delta = maxValue - minValue;
  return minValue + delta * Math.random();
}
var gaussian = notImplemented('gaussian'); // Vect3 operations

function add(a, b, out) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(a, b, out) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiplyScalar(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}
function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}
function multiplyAccumulate(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  out[2] = a[2] + b[2] * scalar;
  return out;
}
function multiplyAccumulate2D(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  return out;
}
function dot(x, y) {
  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
}
function outer(x, y, out_3x3) {
  out_3x3[0] = x[0] * y[0];
  out_3x3[1] = x[0] * y[1];
  out_3x3[2] = x[0] * y[2];
  out_3x3[3] = x[1] * y[0];
  out_3x3[4] = x[1] * y[1];
  out_3x3[5] = x[1] * y[2];
  out_3x3[6] = x[2] * y[0];
  out_3x3[7] = x[2] * y[1];
  out_3x3[8] = x[2] * y[2];
}
function cross(x, y, out) {
  var Zx = x[1] * y[2] - x[2] * y[1];
  var Zy = x[2] * y[0] - x[0] * y[2];
  var Zz = x[0] * y[1] - x[1] * y[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}
function norm(x) {
  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;

  switch (n) {
    case 1:
      return Math.abs(x);

    case 2:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);

    case 3:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);

    default:
      {
        var sum = 0;

        for (var i = 0; i < n; i++) {
          sum += x[i] * x[i];
        }

        return Math.sqrt(sum);
      }
  }
}
function normalize(x) {
  var den = norm(x);

  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
    x[2] /= den;
  }

  return den;
}
function perpendiculars(x, y, z, theta) {
  var x2 = x[0] * x[0];
  var y2 = x[1] * x[1];
  var z2 = x[2] * x[2];
  var r = Math.sqrt(x2 + y2 + z2);
  var dx;
  var dy;
  var dz; // transpose the vector to avoid divide-by-zero error

  if (x2 > y2 && x2 > z2) {
    dx = 0;
    dy = 1;
    dz = 2;
  } else if (y2 > z2) {
    dx = 1;
    dy = 2;
    dz = 0;
  } else {
    dx = 2;
    dy = 0;
    dz = 1;
  }

  var a = x[dx] / r;
  var b = x[dy] / r;
  var c = x[dz] / r;
  var tmp = Math.sqrt(a * a + c * c);

  if (theta !== 0) {
    var sintheta = Math.sin(theta);
    var costheta = Math.cos(theta);

    if (y) {
      y[dx] = (c * costheta - a * b * sintheta) / tmp;
      y[dy] = sintheta * tmp;
      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
    }

    if (z) {
      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
      z[dy] = costheta * tmp;
      z[dz] = (a * sintheta - b * c * costheta) / tmp;
    }
  } else {
    if (y) {
      y[dx] = c / tmp;
      y[dy] = 0;
      y[dz] = -a / tmp;
    }

    if (z) {
      z[dx] = -a * b / tmp;
      z[dy] = tmp;
      z[dz] = -b * c / tmp;
    }
  }
}
function projectVector(a, b, projection) {
  var bSquared = dot(b, b);

  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    projection[2] = 0;
    return false;
  }

  var scale = dot(a, b) / bSquared;

  for (var i = 0; i < 3; i++) {
    projection[i] = b[i];
  }

  multiplyScalar(projection, scale);
  return true;
}
function dot2D(x, y) {
  return x[0] * y[0] + x[1] * y[1];
}
function projectVector2D(a, b, projection) {
  var bSquared = dot2D(b, b);

  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    return false;
  }

  var scale = dot2D(a, b) / bSquared;

  for (var i = 0; i < 2; i++) {
    projection[i] = b[i];
  }

  multiplyScalar2D(projection, scale);
  return true;
}
function distance2BetweenPoints(x, y) {
  return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
}
function angleBetweenVectors(v1, v2) {
  var crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot(v1, v2));
}
function signedAngleBetweenVectors(v1, v2, vN) {
  var crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  var angle = Math.atan2(norm(crossVect), dot(v1, v2));
  return dot(crossVect, vN) >= 0 ? angle : -angle;
}
function gaussianAmplitude(mean, variance, position) {
  var distanceFromMean = Math.abs(mean - position);
  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-Math.pow(distanceFromMean, 2) / (2 * variance));
}
function gaussianWeight(mean, variance, position) {
  var distanceFromMean = Math.abs(mean - position);
  return Math.exp(-Math.pow(distanceFromMean, 2) / (2 * variance));
}
function outer2D(x, y, out_2x2) {
  out_2x2[0] = x[0] * y[0];
  out_2x2[1] = x[0] * y[1];
  out_2x2[2] = x[1] * y[0];
  out_2x2[3] = x[1] * y[1];
}
function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}
function normalize2D(x) {
  var den = norm2D(x);

  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
  }

  return den;
}
function rowsToMat4(row0, row1, row2, row3, mat) {
  for (var i = 0; i < 4; i++) {
    mat[i] = row0[i];
    mat[4 + i] = row1[i];
    mat[8 + i] = row2[i];
    mat[12 + i] = row3[i];
  }

  return mat;
}
function columnsToMat4(column0, column1, column2, column3, mat) {
  for (var i = 0; i < 4; i++) {
    mat[4 * i] = column0[i];
    mat[4 * i + 1] = column1[i];
    mat[4 * i + 2] = column2[i];
    mat[4 * i + 3] = column3[i];
  }

  return mat;
}
function rowsToMat3(row0, row1, row2, mat) {
  for (var i = 0; i < 3; i++) {
    mat[i] = row0[i];
    mat[3 + i] = row1[i];
    mat[6 + i] = row2[i];
  }

  return mat;
}
function columnsToMat3(column0, column1, column2, mat) {
  for (var i = 0; i < 3; i++) {
    mat[3 * i] = column0[i];
    mat[3 * i + 1] = column1[i];
    mat[3 * i + 2] = column2[i];
  }

  return mat;
}
function determinant2x2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }

  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }

  return Number.NaN;
}
function LUFactor3x3(mat_3x3, index_3) {
  var maxI;
  var tmp;
  var largest;
  var scale = [0, 0, 0]; // Loop over rows to get implicit scaling information

  for (var i = 0; i < 3; i++) {
    largest = Math.abs(mat_3x3[i * 3]);

    if ((tmp = Math.abs(mat_3x3[i * 3 + 1])) > largest) {
      largest = tmp;
    }

    if ((tmp = Math.abs(mat_3x3[i * 3 + 2])) > largest) {
      largest = tmp;
    }

    scale[i] = 1 / largest;
  } // Loop over all columns using Crout's method
  // first column


  largest = scale[0] * Math.abs(mat_3x3[0]);
  maxI = 0;

  if ((tmp = scale[1] * Math.abs(mat_3x3[3])) >= largest) {
    largest = tmp;
    maxI = 1;
  }

  if ((tmp = scale[2] * Math.abs(mat_3x3[6])) >= largest) {
    maxI = 2;
  }

  if (maxI !== 0) {
    swapRowsMatrix_nxn(mat_3x3, 3, maxI, 0);
    scale[maxI] = scale[0];
  }

  index_3[0] = maxI;
  mat_3x3[3] /= mat_3x3[0];
  mat_3x3[6] /= mat_3x3[0]; // second column

  mat_3x3[4] -= mat_3x3[3] * mat_3x3[1];
  mat_3x3[7] -= mat_3x3[6] * mat_3x3[1];
  largest = scale[1] * Math.abs(mat_3x3[4]);
  maxI = 1;

  if ((tmp = scale[2] * Math.abs(mat_3x3[7])) >= largest) {
    maxI = 2;
    swapRowsMatrix_nxn(mat_3x3, 3, 1, 2);
    scale[2] = scale[1];
  }

  index_3[1] = maxI;
  mat_3x3[7] /= mat_3x3[4]; // third column

  mat_3x3[5] -= mat_3x3[3] * mat_3x3[2];
  mat_3x3[8] -= mat_3x3[6] * mat_3x3[2] + mat_3x3[7] * mat_3x3[5];
  index_3[2] = 2;
}
function LUSolve3x3(mat_3x3, index_3, x_3) {
  // forward substitution
  var sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;
  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[3] * x_3[0];
  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[6] * x_3[0] - mat_3x3[7] * x_3[1]; // back substitution

  x_3[2] /= mat_3x3[8];
  x_3[1] = (x_3[1] - mat_3x3[5] * x_3[2]) / mat_3x3[4];
  x_3[0] = (x_3[0] - mat_3x3[1] * x_3[1] - mat_3x3[2] * x_3[2]) / mat_3x3[0];
}
function linearSolve3x3(mat_3x3, x_3, y_3) {
  var a1 = mat_3x3[0];
  var b1 = mat_3x3[1];
  var c1 = mat_3x3[2];
  var a2 = mat_3x3[3];
  var b2 = mat_3x3[4];
  var c2 = mat_3x3[5];
  var a3 = mat_3x3[6];
  var b3 = mat_3x3[7];
  var c3 = mat_3x3[8]; // Compute the adjoint

  var d1 = +determinant2x2(b2, b3, c2, c3);
  var d2 = -determinant2x2(a2, a3, c2, c3);
  var d3 = +determinant2x2(a2, a3, b2, b3);
  var e1 = -determinant2x2(b1, b3, c1, c3);
  var e2 = +determinant2x2(a1, a3, c1, c3);
  var e3 = -determinant2x2(a1, a3, b1, b3);
  var f1 = +determinant2x2(b1, b2, c1, c2);
  var f2 = -determinant2x2(a1, a2, c1, c2);
  var f3 = +determinant2x2(a1, a2, b1, b2); // Compute the determinant

  var det = a1 * d1 + b1 * d2 + c1 * d3; // Multiply by the adjoint

  var v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  var v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];
  var v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2]; // Divide by the determinant

  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v3 / det;
}
function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  var x = mat_3x3[0] * in_3[0] + mat_3x3[1] * in_3[1] + mat_3x3[2] * in_3[2];
  var y = mat_3x3[3] * in_3[0] + mat_3x3[4] * in_3[1] + mat_3x3[5] * in_3[2];
  var z = mat_3x3[6] * in_3[0] + mat_3x3[7] * in_3[1] + mat_3x3[8] * in_3[2];
  out_3[0] = x;
  out_3[1] = y;
  out_3[2] = z;
}
function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  var copyA = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(a_3x3);

  var copyB = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(b_3x3);

  for (var i = 0; i < 3; i++) {
    out_3x3[i] = copyA[0] * copyB[i] + copyA[1] * copyB[i + 3] + copyA[2] * copyB[i + 6];
    out_3x3[i + 3] = copyA[3] * copyB[i] + copyA[4] * copyB[i + 3] + copyA[5] * copyB[i + 6];
    out_3x3[i + 6] = copyA[6] * copyB[i] + copyA[7] * copyB[i + 3] + copyA[8] * copyB[i + 6];
  }
}
function multiplyMatrix(a, b, rowA, colA, rowB, colB, out_rowXcol) {
  // we need colA == rowB
  if (colA !== rowB) {
    vtkErrorMacro('Number of columns of A must match number of rows of B.');
  } // If a or b is used to store the result, copying them is required


  var copyA = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(a);

  var copyB = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(b); // output matrix is rowA*colB
  // output row


  for (var i = 0; i < rowA; i++) {
    // output col
    for (var j = 0; j < colB; j++) {
      out_rowXcol[i * colB + j] = 0; // sum for this point

      for (var k = 0; k < colA; k++) {
        out_rowXcol[i * colB + j] += copyA[i * colA + k] * copyB[j + colB * k];
      }
    }
  }
}
function transpose3x3(in_3x3, outT_3x3) {
  var tmp; // off-diagonal elements

  tmp = in_3x3[3];
  outT_3x3[3] = in_3x3[1];
  outT_3x3[1] = tmp;
  tmp = in_3x3[6];
  outT_3x3[6] = in_3x3[2];
  outT_3x3[2] = tmp;
  tmp = in_3x3[7];
  outT_3x3[7] = in_3x3[5];
  outT_3x3[5] = tmp; // on-diagonal elements

  outT_3x3[0] = in_3x3[0];
  outT_3x3[4] = in_3x3[4];
  outT_3x3[8] = in_3x3[8];
}
function invert3x3(in_3x3, outI_3x3) {
  var a1 = in_3x3[0];
  var b1 = in_3x3[1];
  var c1 = in_3x3[2];
  var a2 = in_3x3[3];
  var b2 = in_3x3[4];
  var c2 = in_3x3[5];
  var a3 = in_3x3[6];
  var b3 = in_3x3[7];
  var c3 = in_3x3[8]; // Compute the adjoint

  var d1 = +determinant2x2(b2, b3, c2, c3);
  var d2 = -determinant2x2(a2, a3, c2, c3);
  var d3 = +determinant2x2(a2, a3, b2, b3);
  var e1 = -determinant2x2(b1, b3, c1, c3);
  var e2 = +determinant2x2(a1, a3, c1, c3);
  var e3 = -determinant2x2(a1, a3, b1, b3);
  var f1 = +determinant2x2(b1, b2, c1, c2);
  var f2 = -determinant2x2(a1, a2, c1, c2);
  var f3 = +determinant2x2(a1, a2, b1, b2); // Divide by the determinant

  var det = a1 * d1 + b1 * d2 + c1 * d3;

  if (det === 0) {
    vtkWarningMacro('Matrix has 0 determinant');
  }

  outI_3x3[0] = d1 / det;
  outI_3x3[3] = d2 / det;
  outI_3x3[6] = d3 / det;
  outI_3x3[1] = e1 / det;
  outI_3x3[4] = e2 / det;
  outI_3x3[7] = e3 / det;
  outI_3x3[2] = f1 / det;
  outI_3x3[5] = f2 / det;
  outI_3x3[8] = f3 / det;
}
function determinant3x3(mat_3x3) {
  return mat_3x3[0] * mat_3x3[4] * mat_3x3[8] + mat_3x3[3] * mat_3x3[7] * mat_3x3[2] + mat_3x3[6] * mat_3x3[1] * mat_3x3[5] - mat_3x3[0] * mat_3x3[7] * mat_3x3[5] - mat_3x3[3] * mat_3x3[1] * mat_3x3[8] - mat_3x3[6] * mat_3x3[4] * mat_3x3[2];
}
/**
 * Returns true if elements of both arrays are equals.
 * @param {Array} a an array of numbers (vector, point, matrix...)
 * @param {Array} b an array of numbers (vector, point, matrix...)
 * @param {Number} eps tolerance
 */

function areEquals(a, b) {
  var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Constants_js__WEBPACK_IMPORTED_MODULE_4__.EPSILON;

  if (a.length !== b.length) {
    return false;
  }

  function isEqual(element, index) {
    return Math.abs(element - b[index]) <= eps;
  }

  return a.every(isEqual);
}
var areMatricesEqual = areEquals;
function identity3x3(mat_3x3) {
  for (var i = 0; i < 3; i++) {
    /* eslint-disable-next-line no-multi-assign */
    mat_3x3[i * 3] = mat_3x3[i * 3 + 1] = mat_3x3[i * 3 + 2] = 0;
    mat_3x3[i * 3 + i] = 1;
  }
}
function identity(n, mat) {
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      mat[i * n + j] = 0;
    }

    mat[i * n + i] = 1;
  }

  return mat;
}
function isIdentity(mat) {
  var eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Constants_js__WEBPACK_IMPORTED_MODULE_4__.EPSILON;
  return areMatricesEqual(mat, _Constants_js__WEBPACK_IMPORTED_MODULE_4__.IDENTITY, eps);
}
function isIdentity3x3(mat) {
  var eps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Constants_js__WEBPACK_IMPORTED_MODULE_4__.EPSILON;
  return areMatricesEqual(mat, _Constants_js__WEBPACK_IMPORTED_MODULE_4__.IDENTITY_3X3, eps);
}
function quaternionToMatrix3x3(quat_4, mat_3x3) {
  var ww = quat_4[0] * quat_4[0];
  var wx = quat_4[0] * quat_4[1];
  var wy = quat_4[0] * quat_4[2];
  var wz = quat_4[0] * quat_4[3];
  var xx = quat_4[1] * quat_4[1];
  var yy = quat_4[2] * quat_4[2];
  var zz = quat_4[3] * quat_4[3];
  var xy = quat_4[1] * quat_4[2];
  var xz = quat_4[1] * quat_4[3];
  var yz = quat_4[2] * quat_4[3];
  var rr = xx + yy + zz; // normalization factor, just in case quaternion was not normalized

  var f = 1 / (ww + rr);
  var s = (ww - rr) * f;
  f *= 2;
  mat_3x3[0] = xx * f + s;
  mat_3x3[3] = (xy + wz) * f;
  mat_3x3[6] = (xz - wy) * f;
  mat_3x3[1] = (xy - wz) * f;
  mat_3x3[4] = yy * f + s;
  mat_3x3[7] = (yz + wx) * f;
  mat_3x3[2] = (xz + wy) * f;
  mat_3x3[5] = (yz - wx) * f;
  mat_3x3[8] = zz * f + s;
}
function roundNumber(num) {
  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (!"".concat(num).includes('e')) {
    return +"".concat(Math.round("".concat(num, "e+").concat(digits)), "e-").concat(digits);
  }

  var arr = "".concat(num).split('e');
  var sig = '';

  if (+arr[1] + digits > 0) {
    sig = '+';
  }

  return +"".concat(Math.round("".concat(+arr[0], "e").concat(sig).concat(+arr[1] + digits)), "e-").concat(digits);
}
function roundVector(vector) {
  var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  out[0] = roundNumber(vector[0], digits);
  out[1] = roundNumber(vector[1], digits);
  out[2] = roundNumber(vector[2], digits);
  return out;
}
function jacobiN(a, n, w, v) {
  var i;
  var j;
  var k;
  var iq;
  var ip;
  var numPos;
  var tresh;
  var theta;
  var t;
  var tau;
  var sm;
  var s;
  var h;
  var g;
  var c;
  var tmp;
  var b = createArray(n);
  var z = createArray(n);

  var vtkROTATE = function vtkROTATE(aa, ii, jj) {
    g = aa[ii];
    h = aa[jj];
    aa[ii] = g - s * (h + g * tau);
    aa[jj] = h + s * (g - h * tau);
  }; // initialize


  identity(n, v);

  for (ip = 0; ip < n; ip++) {
    b[ip] = w[ip] = a[ip + ip * n];
    z[ip] = 0.0;
  } // begin rotation sequence


  for (i = 0; i < VTK_MAX_ROTATIONS; i++) {
    sm = 0.0;

    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        sm += Math.abs(a[ip * n + iq]);
      }
    }

    if (sm === 0.0) {
      break;
    } // first 3 sweeps


    if (i < 3) {
      tresh = 0.2 * sm / (n * n);
    } else {
      tresh = 0.0;
    }

    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        g = 100.0 * Math.abs(a[ip * n + iq]); // after 4 sweeps

        if (i > 3 && Math.abs(w[ip]) + g === Math.abs(w[ip]) && Math.abs(w[iq]) + g === Math.abs(w[iq])) {
          a[ip * n + iq] = 0.0;
        } else if (Math.abs(a[ip * n + iq]) > tresh) {
          h = w[iq] - w[ip];

          if (Math.abs(h) + g === Math.abs(h)) {
            t = a[ip * n + iq] / h;
          } else {
            theta = 0.5 * h / a[ip * n + iq];
            t = 1.0 / (Math.abs(theta) + Math.sqrt(1.0 + theta * theta));

            if (theta < 0.0) {
              t = -t;
            }
          }

          c = 1.0 / Math.sqrt(1 + t * t);
          s = t * c;
          tau = s / (1.0 + c);
          h = t * a[ip * n + iq];
          z[ip] -= h;
          z[iq] += h;
          w[ip] -= h;
          w[iq] += h;
          a[ip * n + iq] = 0.0; // ip already shifted left by 1 unit

          for (j = 0; j <= ip - 1; j++) {
            vtkROTATE(a, j * n + ip, j * n + iq);
          } // ip and iq already shifted left by 1 unit


          for (j = ip + 1; j <= iq - 1; j++) {
            vtkROTATE(a, ip * n + j, j * n + iq);
          } // iq already shifted left by 1 unit


          for (j = iq + 1; j < n; j++) {
            vtkROTATE(a, ip * n + j, iq * n + j);
          }

          for (j = 0; j < n; j++) {
            vtkROTATE(v, j * n + ip, j * n + iq);
          }
        }
      }
    }

    for (ip = 0; ip < n; ip++) {
      b[ip] += z[ip];
      w[ip] = b[ip];
      z[ip] = 0.0;
    }
  } // this is NEVER called


  if (i >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro('vtkMath::Jacobi: Error extracting eigenfunctions');
    return 0;
  } // sort eigenfunctions: these changes do not affect accuracy


  for (j = 0; j < n - 1; j++) {
    // boundary incorrect
    k = j;
    tmp = w[k];

    for (i = j + 1; i < n; i++) {
      // boundary incorrect, shifted already
      if (w[i] >= tmp || Math.abs(w[i] - tmp) < _Constants_js__WEBPACK_IMPORTED_MODULE_4__.VTK_SMALL_NUMBER) {
        // why exchange if same?
        k = i;
        tmp = w[k];
      }
    }

    if (k !== j) {
      w[k] = w[j];
      w[j] = tmp;
      swapColumnsMatrix_nxn(v, n, j, k);
    }
  } // ensure eigenvector consistency (i.e., Jacobi can compute vectors that
  // are negative of one another (.707,.707,0) and (-.707,-.707,0). This can
  // reek havoc in hyperstreamline/other stuff. We will select the most
  // positive eigenvector.


  var ceil_half_n = (n >> 1) + (n & 1);

  for (numPos = 0, i = 0; i < n * n; i++) {
    if (v[i] >= 0.0) {
      numPos++;
    }
  } //    if ( numPos < ceil(double(n)/double(2.0)) )


  if (numPos < ceil_half_n) {
    for (i = 0; i < n; i++) {
      v[i * n + j] *= -1.0;
    }
  }

  return 1;
}
function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  var tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // on-diagonal elements

  tmp[0] = mat_3x3[0] + mat_3x3[4] + mat_3x3[8];
  tmp[5] = mat_3x3[0] - mat_3x3[4] - mat_3x3[8];
  tmp[10] = -mat_3x3[0] + mat_3x3[4] - mat_3x3[8];
  tmp[15] = -mat_3x3[0] - mat_3x3[4] + mat_3x3[8]; // off-diagonal elements

  tmp[1] = tmp[4] = mat_3x3[7] - mat_3x3[5];
  tmp[2] = tmp[8] = mat_3x3[2] - mat_3x3[6];
  tmp[3] = tmp[12] = mat_3x3[3] - mat_3x3[1];
  tmp[6] = tmp[9] = mat_3x3[3] + mat_3x3[1];
  tmp[7] = tmp[13] = mat_3x3[2] + mat_3x3[6];
  tmp[11] = tmp[14] = mat_3x3[7] + mat_3x3[5];
  var eigenvectors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  var eigenvalues = [0, 0, 0, 0]; // convert into format that JacobiN can use,
  // then use Jacobi to find eigenvalues and eigenvectors
  // tmp is copied because jacobiN may modify it

  var NTemp = [].concat(tmp);
  jacobiN(NTemp, 4, eigenvalues, eigenvectors); // the first eigenvector is the one we want

  quat_4[0] = eigenvectors[0];
  quat_4[1] = eigenvectors[4];
  quat_4[2] = eigenvectors[8];
  quat_4[3] = eigenvectors[12];
}
function multiplyQuaternion(quat_1, quat_2, quat_out) {
  var ww = quat_1[0] * quat_2[0];
  var wx = quat_1[0] * quat_2[1];
  var wy = quat_1[0] * quat_2[2];
  var wz = quat_1[0] * quat_2[3];
  var xw = quat_1[1] * quat_2[0];
  var xx = quat_1[1] * quat_2[1];
  var xy = quat_1[1] * quat_2[2];
  var xz = quat_1[1] * quat_2[3];
  var yw = quat_1[2] * quat_2[0];
  var yx = quat_1[2] * quat_2[1];
  var yy = quat_1[2] * quat_2[2];
  var yz = quat_1[2] * quat_2[3];
  var zw = quat_1[3] * quat_2[0];
  var zx = quat_1[3] * quat_2[1];
  var zy = quat_1[3] * quat_2[2];
  var zz = quat_1[3] * quat_2[3];
  quat_out[0] = ww - xx - yy - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy - yx + zw;
}
function orthogonalize3x3(a_3x3, out_3x3) {
  // copy the matrix
  for (var i = 0; i < 9; i++) {
    out_3x3[i] = a_3x3[i];
  } // Pivot the matrix to improve accuracy


  var scale = createArray(3);
  var index = createArray(3);
  var largest; // Loop over rows to get implicit scaling information

  for (var _i = 0; _i < 3; _i++) {
    var _x = Math.abs(out_3x3[_i * 3]);

    var _x2 = Math.abs(out_3x3[_i * 3 + 1]);

    var _x3 = Math.abs(out_3x3[_i * 3 + 2]);

    largest = _x2 > _x ? _x2 : _x;
    largest = _x3 > largest ? _x3 : largest;
    scale[_i] = 1;

    if (largest !== 0) {
      scale[_i] /= largest;
    }
  } // first column


  var x1 = Math.abs(out_3x3[0]) * scale[0];
  var x2 = Math.abs(out_3x3[3]) * scale[1];
  var x3 = Math.abs(out_3x3[6]) * scale[2];
  index[0] = 0;
  largest = x1;

  if (x2 >= largest) {
    largest = x2;
    index[0] = 1;
  }

  if (x3 >= largest) {
    index[0] = 2;
  }

  if (index[0] !== 0) {
    // swap vectors
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
    scale[index[0]] = scale[0];
  } // second column


  var y2 = Math.abs(out_3x3[4]) * scale[1];
  var y3 = Math.abs(out_3x3[7]) * scale[2];
  index[1] = 1;
  largest = y2;

  if (y3 >= largest) {
    index[1] = 2; // swap vectors

    swapColumnsMatrix_nxn(out_3x3, 3, 1, 2);
  } // third column


  index[2] = 2; // A quaternion can only describe a pure rotation, not
  // a rotation with a flip, therefore the flip must be
  // removed before the matrix is converted to a quaternion.

  var flip = 0;

  if (determinant3x3(out_3x3) < 0) {
    flip = 1;

    for (var _i2 = 0; _i2 < 9; _i2++) {
      out_3x3[_i2] = -out_3x3[_i2];
    }
  } // Do orthogonalization using a quaternion intermediate
  // (this, essentially, does the orthogonalization via
  // diagonalization of an appropriately constructed symmetric
  // 4x4 matrix rather than by doing SVD of the 3x3 matrix)


  var quat = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat);
  quaternionToMatrix3x3(quat, out_3x3); // Put the flip back into the orthogonalized matrix.

  if (flip) {
    for (var _i3 = 0; _i3 < 9; _i3++) {
      out_3x3[_i3] = -out_3x3[_i3];
    }
  } // Undo the pivoting


  if (index[1] !== 1) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[1], 1);
  }

  if (index[0] !== 0) {
    swapColumnsMatrix_nxn(out_3x3, 3, index[0], 0);
  }
}
function diagonalize3x3(a_3x3, w_3, v_3x3) {
  var i;
  var j;
  var k;
  var maxI;
  var tmp;
  var maxVal; // a is copied because jacobiN may modify it

  var copyA = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(a_3x3); // diagonalize using Jacobi


  jacobiN(copyA, 3, w_3, v_3x3); // if all the eigenvalues are the same, return identity matrix

  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  } // transpose temporarily, it makes it easier to sort the eigenvectors


  transpose3x3(v_3x3, v_3x3); // if two eigenvalues are the same, re-orthogonalize to optimally line
  // up the eigenvectors with the x, y, and z axes

  for (i = 0; i < 3; i++) {
    // two eigenvalues are the same
    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
      // find maximum element of the independent eigenvector
      maxVal = Math.abs(v_3x3[i * 3]);
      maxI = 0;

      for (j = 1; j < 3; j++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i * 3 + j]))) {
          maxVal = tmp;
          maxI = j;
        }
      } // swap the eigenvector into its proper position


      if (maxI !== i) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i];
        w_3[i] = tmp;
        swapRowsMatrix_nxn(v_3x3, 3, i, maxI);
      } // maximum element of eigenvector should be positive


      if (v_3x3[maxI * 3 + maxI] < 0) {
        v_3x3[maxI * 3] = -v_3x3[maxI * 3];
        v_3x3[maxI * 3 + 1] = -v_3x3[maxI * 3 + 1];
        v_3x3[maxI * 3 + 2] = -v_3x3[maxI * 3 + 2];
      } // re-orthogonalize the other two eigenvectors


      j = (maxI + 1) % 3;
      k = (maxI + 2) % 3;
      v_3x3[j * 3] = 0.0;
      v_3x3[j * 3 + 1] = 0.0;
      v_3x3[j * 3 + 2] = 0.0;
      v_3x3[j * 3 + j] = 1.0;
      var vectTmp1 = cross([v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], [v_3x3[j * 3], v_3x3[j * 3 + 1], v_3x3[j * 3 + 2]], []);
      normalize(vectTmp1);
      var vectTmp2 = cross(vectTmp1, [v_3x3[maxI * 3], v_3x3[maxI * 3 + 1], v_3x3[maxI * 3 + 2]], []);

      for (var t = 0; t < 3; t++) {
        v_3x3[k * 3 + t] = vectTmp1[t];
        v_3x3[j * 3 + t] = vectTmp2[t];
      } // transpose vectors back to columns


      transpose3x3(v_3x3, v_3x3);
      return;
    }
  } // the three eigenvalues are different, just sort the eigenvectors
  // to align them with the x, y, and z axes
  // find the vector with the largest x element, make that vector
  // the first vector


  maxVal = Math.abs(v_3x3[0]);
  maxI = 0;

  for (i = 1; i < 3; i++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i * 3]))) {
      maxVal = tmp;
      maxI = i;
    }
  } // swap eigenvalue and eigenvector


  if (maxI !== 0) {
    var eigenValTmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, maxI, 0);
  } // do the same for the y element


  if (Math.abs(v_3x3[4]) < Math.abs(v_3x3[7])) {
    var _eigenValTmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = _eigenValTmp;
    swapRowsMatrix_nxn(v_3x3, 3, 1, 2);
  } // ensure that the sign of the eigenvectors is correct


  for (i = 0; i < 2; i++) {
    if (v_3x3[i * 3 + i] < 0) {
      v_3x3[i * 3] = -v_3x3[i * 3];
      v_3x3[i * 3 + 1] = -v_3x3[i * 3 + 1];
      v_3x3[i * 3 + 2] = -v_3x3[i * 3 + 2];
    }
  } // set sign of final eigenvector to ensure that determinant is positive


  if (determinant3x3(v_3x3) < 0) {
    v_3x3[6] = -v_3x3[6];
    v_3x3[7] = -v_3x3[7];
    v_3x3[8] = -v_3x3[8];
  } // transpose the eigenvectors back again


  transpose3x3(v_3x3, v_3x3);
}
function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  var i; // copy so that A can be used for U or VT without risk

  var B = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(a_3x3); // temporarily flip if determinant is negative


  var d = determinant3x3(B);

  if (d < 0) {
    for (i = 0; i < 9; i++) {
      B[i] = -B[i];
    }
  } // orthogonalize, diagonalize, etc.


  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3); // re-create the flip

  if (d < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}
/**
 * Factor linear equations Ax = b using LU decomposition A = LU. Output factorization LU is in matrix A.
 * @param {Matrix} A square matrix
 * @param {Number} index integer array of pivot indices index[0->n-1]
 * @param {Number} size matrix size
 */

function luFactorLinearSystem(A, index, size) {
  var i;
  var j;
  var k;
  var largest;
  var maxI = 0;
  var sum;
  var temp1;
  var temp2;
  var scale = createArray(size); //
  // Loop over rows to get implicit scaling information
  //

  for (i = 0; i < size; i++) {
    for (largest = 0.0, j = 0; j < size; j++) {
      if ((temp2 = Math.abs(A[i * size + j])) > largest) {
        largest = temp2;
      }
    }

    if (largest === 0.0) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }

    scale[i] = 1.0 / largest;
  } //
  // Loop over all columns using Crout's method
  //


  for (j = 0; j < size; j++) {
    for (i = 0; i < j; i++) {
      sum = A[i * size + j];

      for (k = 0; k < i; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }

      A[i * size + j] = sum;
    } //
    // Begin search for largest pivot element
    //


    for (largest = 0.0, i = j; i < size; i++) {
      sum = A[i * size + j];

      for (k = 0; k < j; k++) {
        sum -= A[i * size + k] * A[k * size + j];
      }

      A[i * size + j] = sum;

      if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i;
      }
    } //
    // Check for row interchange
    //


    if (j !== maxI) {
      for (k = 0; k < size; k++) {
        temp1 = A[maxI * size + k];
        A[maxI * size + k] = A[j * size + k];
        A[j * size + k] = temp1;
      }

      scale[maxI] = scale[j];
    } //
    // Divide by pivot element and perform elimination
    //


    index[j] = maxI;

    if (Math.abs(A[j * size + j]) <= _Constants_js__WEBPACK_IMPORTED_MODULE_4__.VTK_SMALL_NUMBER) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }

    if (j !== size - 1) {
      temp1 = 1.0 / A[j * size + j];

      for (i = j + 1; i < size; i++) {
        A[i * size + j] *= temp1;
      }
    }
  }

  return 1;
}
function luSolveLinearSystem(A, index, x, size) {
  var i;
  var j;
  var ii;
  var idx;
  var sum; //
  // Proceed with forward and backsubstitution for L and U
  // matrices.  First, forward substitution.
  //

  for (ii = -1, i = 0; i < size; i++) {
    idx = index[i];
    sum = x[idx];
    x[idx] = x[i];

    if (ii >= 0) {
      for (j = ii; j <= i - 1; j++) {
        sum -= A[i * size + j] * x[j];
      }
    } else if (sum !== 0.0) {
      ii = i;
    }

    x[i] = sum;
  } //
  // Now, back substitution
  //


  for (i = size - 1; i >= 0; i--) {
    sum = x[i];

    for (j = i + 1; j < size; j++) {
      sum -= A[i * size + j] * x[j];
    }

    x[i] = sum / A[i * size + i];
  }
}
function solveLinearSystem(A, x, size) {
  // if we solving something simple, just solve it
  if (size === 2) {
    var y = createArray(2);
    var det = determinant2x2(A[0], A[1], A[2], A[3]);

    if (det === 0.0) {
      // Unable to solve linear system
      return 0;
    }

    y[0] = (A[3] * x[0] - A[1] * x[1]) / det;
    y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;
    x[0] = y[0];
    x[1] = y[1];
    return 1;
  }

  if (size === 1) {
    if (A[0] === 0.0) {
      // Unable to solve linear system
      return 0;
    }

    x[0] /= A[0];
    return 1;
  } //
  // System of equations is not trivial, use Crout's method
  //
  // Check on allocation of working vectors


  var index = createArray(size); // Factor and solve matrix

  if (luFactorLinearSystem(A, index, size) === 0) {
    return 0;
  }

  luSolveLinearSystem(A, index, x, size);
  return 1;
} // Note that A is modified during the inversion !

function invertMatrix(A, AI, size) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var column = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var tmp1Size = index || createArray(size);
  var tmp2Size = column || createArray(size); // Factor matrix; then begin solving for inverse one column at a time.
  // Note: tmp1Size returned value is used later, tmp2Size is just working
  // memory whose values are not used in LUSolveLinearSystem

  if (luFactorLinearSystem(A, tmp1Size, size) === 0) {
    return null;
  }

  for (var j = 0; j < size; j++) {
    for (var i = 0; i < size; i++) {
      tmp2Size[i] = 0.0;
    }

    tmp2Size[j] = 1.0;
    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);

    for (var _i4 = 0; _i4 < size; _i4++) {
      AI[_i4 * size + j] = tmp2Size[_i4];
    }
  }

  return AI;
}
function estimateMatrixCondition(A, size) {
  var minValue = +Number.MAX_VALUE;
  var maxValue = -Number.MAX_VALUE; // find the maximum value

  for (var i = 0; i < size; i++) {
    for (var j = i; j < size; j++) {
      if (Math.abs(A[i * size + j]) > maxValue) {
        maxValue = Math.abs(A[i * size + j]);
      }
    }
  } // find the minimum diagonal value


  for (var _i5 = 0; _i5 < size; _i5++) {
    if (Math.abs(A[_i5 * size + _i5]) < minValue) {
      minValue = Math.abs(A[_i5 * size + _i5]);
    }
  }

  if (minValue === 0.0) {
    return Number.MAX_VALUE;
  }

  return maxValue / minValue;
}
function jacobi(a_3x3, w, v) {
  return jacobiN(a_3x3, 3, w, v);
}
function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  // check dimensional consistency
  if (numberOfSamples < xOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }

  var i;
  var j;
  var k; // set up intermediate variables
  // Allocate matrix to hold X times transpose of X

  var XXt = createArray(xOrder * xOrder); // size x by x
  // Allocate the array of eigenvalues and eigenvectors

  var eigenvals = createArray(xOrder);
  var eigenvecs = createArray(xOrder * xOrder); // Calculate XXt upper half only, due to symmetry

  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      }
    }
  } // now fill in the lower half of the XXt matrix


  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  } // Compute the eigenvectors and eigenvalues


  jacobiN(XXt, xOrder, eigenvals, eigenvecs); // Smallest eigenval is at the end of the list (xOrder-1), and solution is
  // corresponding eigenvec.

  for (i = 0; i < xOrder; i++) {
    mt[i] = eigenvecs[i * xOrder + xOrder - 1];
  }

  return 1;
}
function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
  var checkHomogeneous = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;

  // check dimensional consistency
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }

  var homogenFlags = createArray(yOrder);
  var allHomogeneous = 1;
  var hmt;
  var homogRC = 0;
  var i;
  var j;
  var k;
  var someHomogeneous = 0; // Ok, first init some flags check and see if all the systems are homogeneous

  if (checkHomogeneous) {
    // If Y' is zero, it's a homogeneous system and can't be solved via
    // the pseudoinverse method. Detect this case, warn the user, and
    // invoke SolveHomogeneousLeastSquares instead. Note that it doesn't
    // really make much sense for yOrder to be greater than one in this case,
    // since that's just yOrder occurrences of a 0 vector on the RHS, but
    // we allow it anyway. N
    // Initialize homogeneous flags on a per-right-hand-side basis
    for (j = 0; j < yOrder; j++) {
      homogenFlags[j] = 1;
    }

    for (i = 0; i < numberOfSamples; i++) {
      for (j = 0; j < yOrder; j++) {
        if (Math.abs(yt[i * yOrder + j]) > _Constants_js__WEBPACK_IMPORTED_MODULE_4__.VTK_SMALL_NUMBER) {
          allHomogeneous = 0;
          homogenFlags[j] = 0;
        }
      }
    } // If we've got one system, and it's homogeneous, do it and bail out quickly.


    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro('Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()');
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    } // Ok, we've got more than one system of equations.
    // Figure out if we need to calculate the homogeneous equation solution for
    // any of them.


    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j = 0; j < yOrder; j++) {
        if (homogenFlags[j]) {
          someHomogeneous = 1;
        }
      }
    }
  } // If necessary, solve the homogeneous problem


  if (someHomogeneous) {
    // hmt is the homogeneous equation version of mt, the general solution.
    // hmt should be xOrder x yOrder, but since we are solving only the homogeneous part, here it is xOrder x 1
    hmt = createArray(xOrder); // Ok, solve the homogeneous problem

    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  } // set up intermediate variables


  var XXt = createArray(xOrder * xOrder); // size x by x

  var XXtI = createArray(xOrder * xOrder); // size x by x

  var XYt = createArray(xOrder * yOrder); // size x by y
  // first find the pseudoinverse matrix

  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      // first calculate the XXt matrix, only do the upper half (symmetrical)
      for (j = i; j < xOrder; j++) {
        XXt[i * xOrder + j] += xt[k * xOrder + i] * xt[k * xOrder + j];
      } // now calculate the XYt matrix


      for (j = 0; j < yOrder; j++) {
        XYt[i * yOrder + j] += xt[k * xOrder + i] * yt[k * yOrder + j];
      }
    }
  } // now fill in the lower half of the XXt matrix


  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i * xOrder + j] = XXt[j * xOrder + i];
    }
  }

  var successFlag = invertMatrix(XXt, XXtI, xOrder); // next get the inverse of XXt

  if (successFlag) {
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < yOrder; j++) {
        mt[i * yOrder + j] = 0.0;

        for (k = 0; k < xOrder; k++) {
          mt[i * yOrder + j] += XXtI[i * xOrder + k] * XYt[k * yOrder + j];
        }
      }
    }
  } // Fix up any of the solutions that correspond to the homogeneous equation
  // problem.


  if (someHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      if (homogenFlags[j]) {
        // Fix this one
        for (i = 0; i < xOrder; i++) {
          mt[i * yOrder + j] = hmt[i * yOrder];
        }
      }
    }
  }

  if (someHomogeneous) {
    return homogRC && successFlag;
  }

  return successFlag;
}
function hex2float(hexStr) {
  var outFloatArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0.5, 1];

  switch (hexStr.length) {
    case 3:
      // abc => #aabbcc
      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
      return outFloatArray;

    case 4:
      // #abc => #aabbcc
      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
      return outFloatArray;

    case 6:
      // ab01df => #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;

    case 7:
      // #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;

    case 9:
      // #ab01df00
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;

    default:
      return outFloatArray;
  }
}
function rgb2hsv(rgb, hsv) {
  var h;
  var s;

  var _rgb = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(rgb, 3),
      r = _rgb[0],
      g = _rgb[1],
      b = _rgb[2];

  var onethird = 1.0 / 3.0;
  var onesixth = 1.0 / 6.0;
  var twothird = 2.0 / 3.0;
  var cmax = r;
  var cmin = r;

  if (g > cmax) {
    cmax = g;
  } else if (g < cmin) {
    cmin = g;
  }

  if (b > cmax) {
    cmax = b;
  } else if (b < cmin) {
    cmin = b;
  }

  var v = cmax;

  if (v > 0.0) {
    s = (cmax - cmin) / cmax;
  } else {
    s = 0.0;
  }

  if (s > 0) {
    if (r === cmax) {
      h = onesixth * (g - b) / (cmax - cmin);
    } else if (g === cmax) {
      h = onethird + onesixth * (b - r) / (cmax - cmin);
    } else {
      h = twothird + onesixth * (r - g) / (cmax - cmin);
    }

    if (h < 0.0) {
      h += 1.0;
    }
  } else {
    h = 0.0;
  } // Set the values back to the array


  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
}
function hsv2rgb(hsv, rgb) {
  var _hsv = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(hsv, 3),
      h = _hsv[0],
      s = _hsv[1],
      v = _hsv[2];

  var onethird = 1.0 / 3.0;
  var onesixth = 1.0 / 6.0;
  var twothird = 2.0 / 3.0;
  var fivesixth = 5.0 / 6.0;
  var r;
  var g;
  var b; // compute RGB from HSV

  if (h > onesixth && h <= onethird) {
    // green/red
    g = 1.0;
    r = (onethird - h) / onesixth;
    b = 0.0;
  } else if (h > onethird && h <= 0.5) {
    // green/blue
    g = 1.0;
    b = (h - onethird) / onesixth;
    r = 0.0;
  } else if (h > 0.5 && h <= twothird) {
    // blue/green
    b = 1.0;
    g = (twothird - h) / onesixth;
    r = 0.0;
  } else if (h > twothird && h <= fivesixth) {
    // blue/red
    b = 1.0;
    r = (h - twothird) / onesixth;
    g = 0.0;
  } else if (h > fivesixth && h <= 1.0) {
    // red/blue
    r = 1.0;
    b = (1.0 - h) / onesixth;
    g = 0.0;
  } else {
    // red/green
    r = 1.0;
    g = h / onesixth;
    b = 0.0;
  } // add Saturation to the equation.


  r = s * r + (1.0 - s);
  g = s * g + (1.0 - s);
  b = s * b + (1.0 - s);
  r *= v;
  g *= v;
  b *= v; // Assign back to the array

  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function lab2xyz(lab, xyz) {
  // LAB to XYZ
  var _lab = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(lab, 3),
      L = _lab[0],
      a = _lab[1],
      b = _lab[2];

  var var_Y = (L + 16) / 116;
  var var_X = a / 500 + var_Y;
  var var_Z = var_Y - b / 200;

  if (Math.pow(var_Y, 3) > 0.008856) {
    var_Y = Math.pow(var_Y, 3);
  } else {
    var_Y = (var_Y - 16.0 / 116.0) / 7.787;
  }

  if (Math.pow(var_X, 3) > 0.008856) {
    var_X = Math.pow(var_X, 3);
  } else {
    var_X = (var_X - 16.0 / 116.0) / 7.787;
  }

  if (Math.pow(var_Z, 3) > 0.008856) {
    var_Z = Math.pow(var_Z, 3);
  } else {
    var_Z = (var_Z - 16.0 / 116.0) / 7.787;
  }

  var ref_X = 0.9505;
  var ref_Y = 1.0;
  var ref_Z = 1.089;
  xyz[0] = ref_X * var_X; // ref_X = 0.9505  Observer= 2 deg Illuminant= D65

  xyz[1] = ref_Y * var_Y; // ref_Y = 1.000

  xyz[2] = ref_Z * var_Z; // ref_Z = 1.089
}
function xyz2lab(xyz, lab) {
  var _xyz = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      z = _xyz[2];

  var ref_X = 0.9505;
  var ref_Y = 1.0;
  var ref_Z = 1.089;
  var var_X = x / ref_X; // ref_X = 0.9505  Observer= 2 deg, Illuminant= D65

  var var_Y = y / ref_Y; // ref_Y = 1.000

  var var_Z = z / ref_Z; // ref_Z = 1.089

  if (var_X > 0.008856) var_X = Math.pow(var_X, 1.0 / 3.0);else var_X = 7.787 * var_X + 16.0 / 116.0;
  if (var_Y > 0.008856) var_Y = Math.pow(var_Y, 1.0 / 3.0);else var_Y = 7.787 * var_Y + 16.0 / 116.0;
  if (var_Z > 0.008856) var_Z = Math.pow(var_Z, 1.0 / 3.0);else var_Z = 7.787 * var_Z + 16.0 / 116.0;
  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}
function xyz2rgb(xyz, rgb) {
  var _xyz2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(xyz, 3),
      x = _xyz2[0],
      y = _xyz2[1],
      z = _xyz2[2];

  var r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  var g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  var b = x * 0.0557 + y * -0.204 + z * 1.057; // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.

  if (r > 0.0031308) r = 1.055 * Math.pow(r, 1 / 2.4) - 0.055;else r *= 12.92;
  if (g > 0.0031308) g = 1.055 * Math.pow(g, 1 / 2.4) - 0.055;else g *= 12.92;
  if (b > 0.0031308) b = 1.055 * Math.pow(b, 1 / 2.4) - 0.055;else b *= 12.92; // Clip colors. ideally we would do something that is perceptually closest
  // (since we can see colors outside of the display gamut), but this seems to
  // work well enough.

  var maxVal = r;
  if (maxVal < g) maxVal = g;
  if (maxVal < b) maxVal = b;

  if (maxVal > 1.0) {
    r /= maxVal;
    g /= maxVal;
    b /= maxVal;
  }

  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0; // Push values back to array

  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function rgb2xyz(rgb, xyz) {
  var _rgb2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(rgb, 3),
      r = _rgb2[0],
      g = _rgb2[1],
      b = _rgb2[2]; // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.


  if (r > 0.04045) r = Math.pow((r + 0.055) / 1.055, 2.4);else r /= 12.92;
  if (g > 0.04045) g = Math.pow((g + 0.055) / 1.055, 2.4);else g /= 12.92;
  if (b > 0.04045) b = Math.pow((b + 0.055) / 1.055, 2.4);else b /= 12.92; // Observer. = 2 deg, Illuminant = D65

  xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;
  xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;
  xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;
}
function rgb2lab(rgb, lab) {
  var xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}
function lab2rgb(lab, rgb) {
  var xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}
function uninitializeBounds(bounds) {
  bounds[0] = 1.0;
  bounds[1] = -1.0;
  bounds[2] = 1.0;
  bounds[3] = -1.0;
  bounds[4] = 1.0;
  bounds[5] = -1.0;
  return bounds;
}
function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0.0);
}
/**
 * @deprecated please use vtkBoundingBox.addPoints(vtkBoundingBox.reset([]), points)
 */

function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }

  if (value > maxValue) {
    return maxValue;
  }

  return value;
}
function clampVector(vector, minVector, maxVector) {
  var out = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0, 0];
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
  return out;
}
function clampAndNormalizeValue(value, range) {
  var result = 0;

  if (range[0] !== range[1]) {
    // clamp
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    } // normalize


    result = (result - range[0]) / (range[1] - range[0]);
  }

  return result;
}
var getScalarTypeFittingRange = notImplemented('GetScalarTypeFittingRange');
var getAdjustedScalarRange = notImplemented('GetAdjustedScalarRange');
function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }

  for (var i = 0; i < 6; i += 2) {
    if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {
      return 0;
    }
  }

  return 1;
}
function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }

  for (var i = 0; i < 6; i += 2) {
    if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {
      return 0;
    }
  }

  return 1;
}
function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }

  for (var i = 0; i < 3; i++) {
    if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {
      return 0;
    }
  }

  return 1;
}
function solve3PointCircle(p1, p2, p3, center) {
  var v21 = createArray(3);
  var v32 = createArray(3);
  var v13 = createArray(3);
  var v12 = createArray(3);
  var v23 = createArray(3);
  var v31 = createArray(3);

  for (var i = 0; i < 3; ++i) {
    v21[i] = p1[i] - p2[i];
    v32[i] = p2[i] - p3[i];
    v13[i] = p3[i] - p1[i];
    v12[i] = -v21[i];
    v23[i] = -v32[i];
    v31[i] = -v13[i];
  }

  var norm12 = norm(v12);
  var norm23 = norm(v23);
  var norm13 = norm(v13);
  var crossv21v32 = createArray(3);
  cross(v21, v32, crossv21v32);
  var normCross = norm(crossv21v32);
  var radius = norm12 * norm23 * norm13 / (2 * normCross);
  var normCross22 = 2 * normCross * normCross;
  var alpha = norm23 * norm23 * dot(v21, v31) / normCross22;
  var beta = norm13 * norm13 * dot(v12, v32) / normCross22;
  var gamma = norm12 * norm12 * dot(v13, v23) / normCross22;

  for (var _i6 = 0; _i6 < 3; ++_i6) {
    center[_i6] = alpha * p1[_i6] + beta * p2[_i6] + gamma * p3[_i6];
  }

  return radius;
}
var inf = Infinity;
var negInf = -Infinity;
var isInf = function isInf(value) {
  return !Number.isFinite(value);
};
var isFinite = Number.isFinite,
    isNaN = Number.isNaN;
var isNan = isNaN; // JavaScript - add-on ----------------------

function createUninitializedBounds() {
  return [].concat([Number.MAX_VALUE, -Number.MAX_VALUE, // X
  Number.MAX_VALUE, -Number.MAX_VALUE, // Y
  Number.MAX_VALUE, -Number.MAX_VALUE // Z
  ]);
}
function getMajorAxisIndex(vector) {
  var maxValue = -1;
  var axisIndex = -1;

  for (var i = 0; i < vector.length; i++) {
    var value = Math.abs(vector[i]);

    if (value > maxValue) {
      axisIndex = i;
      maxValue = value;
    }
  }

  return axisIndex;
}
function floatToHex2(value) {
  var integer = Math.floor(value * 255);

  if (integer > 15) {
    return integer.toString(16);
  }

  return "0".concat(integer.toString(16));
}
function floatRGB2HexCode(rgbArray) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#';
  return "".concat(prefix).concat(rgbArray.map(floatToHex2).join(''));
}

function floatToChar(f) {
  return Math.round(f * 255);
}

function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return "rgb(".concat(rgbArray.map(floatToChar).join(', '), ")");
  }

  return "rgba(".concat(floatToChar(rgbArray[0] || 0), ", ").concat(floatToChar(rgbArray[1] || 0), ", ").concat(floatToChar(rgbArray[2] || 0), ", ").concat(rgbArray[3] || 0, ")");
} // ----------------------------------------------------------------------------
// Only Static API
// ----------------------------------------------------------------------------

var vtkMath = {
  Pi: Pi,
  radiansFromDegrees: radiansFromDegrees,
  degreesFromRadians: degreesFromRadians,
  round: round,
  floor: floor,
  ceil: ceil,
  ceilLog2: ceilLog2,
  min: min,
  max: max,
  arrayMin: arrayMin,
  arrayMax: arrayMax,
  arrayRange: arrayRange,
  isPowerOfTwo: isPowerOfTwo,
  nearestPowerOfTwo: nearestPowerOfTwo,
  factorial: factorial,
  binomial: binomial,
  beginCombination: beginCombination,
  nextCombination: nextCombination,
  randomSeed: randomSeed,
  getSeed: getSeed,
  random: random,
  gaussian: gaussian,
  add: add,
  subtract: subtract,
  multiplyScalar: multiplyScalar,
  multiplyScalar2D: multiplyScalar2D,
  multiplyAccumulate: multiplyAccumulate,
  multiplyAccumulate2D: multiplyAccumulate2D,
  dot: dot,
  outer: outer,
  cross: cross,
  norm: norm,
  normalize: normalize,
  perpendiculars: perpendiculars,
  projectVector: projectVector,
  projectVector2D: projectVector2D,
  distance2BetweenPoints: distance2BetweenPoints,
  angleBetweenVectors: angleBetweenVectors,
  gaussianAmplitude: gaussianAmplitude,
  gaussianWeight: gaussianWeight,
  dot2D: dot2D,
  outer2D: outer2D,
  norm2D: norm2D,
  normalize2D: normalize2D,
  determinant2x2: determinant2x2,
  LUFactor3x3: LUFactor3x3,
  LUSolve3x3: LUSolve3x3,
  linearSolve3x3: linearSolve3x3,
  multiply3x3_vect3: multiply3x3_vect3,
  multiply3x3_mat3: multiply3x3_mat3,
  multiplyMatrix: multiplyMatrix,
  transpose3x3: transpose3x3,
  invert3x3: invert3x3,
  identity3x3: identity3x3,
  identity: identity,
  isIdentity: isIdentity,
  isIdentity3x3: isIdentity3x3,
  determinant3x3: determinant3x3,
  quaternionToMatrix3x3: quaternionToMatrix3x3,
  areEquals: areEquals,
  areMatricesEqual: areMatricesEqual,
  roundNumber: roundNumber,
  roundVector: roundVector,
  matrix3x3ToQuaternion: matrix3x3ToQuaternion,
  multiplyQuaternion: multiplyQuaternion,
  orthogonalize3x3: orthogonalize3x3,
  diagonalize3x3: diagonalize3x3,
  singularValueDecomposition3x3: singularValueDecomposition3x3,
  solveLinearSystem: solveLinearSystem,
  invertMatrix: invertMatrix,
  luFactorLinearSystem: luFactorLinearSystem,
  luSolveLinearSystem: luSolveLinearSystem,
  estimateMatrixCondition: estimateMatrixCondition,
  jacobi: jacobi,
  jacobiN: jacobiN,
  solveHomogeneousLeastSquares: solveHomogeneousLeastSquares,
  solveLeastSquares: solveLeastSquares,
  hex2float: hex2float,
  rgb2hsv: rgb2hsv,
  hsv2rgb: hsv2rgb,
  lab2xyz: lab2xyz,
  xyz2lab: xyz2lab,
  xyz2rgb: xyz2rgb,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  lab2rgb: lab2rgb,
  uninitializeBounds: uninitializeBounds,
  areBoundsInitialized: areBoundsInitialized,
  computeBoundsFromPoints: computeBoundsFromPoints,
  clampValue: clampValue,
  clampVector: clampVector,
  clampAndNormalizeValue: clampAndNormalizeValue,
  getScalarTypeFittingRange: getScalarTypeFittingRange,
  getAdjustedScalarRange: getAdjustedScalarRange,
  extentIsWithinOtherExtent: extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds: boundsIsWithinOtherBounds,
  pointIsWithinBounds: pointIsWithinBounds,
  solve3PointCircle: solve3PointCircle,
  inf: inf,
  negInf: negInf,
  isInf: isInf,
  isNan: isNaN,
  isNaN: isNaN,
  isFinite: isFinite,
  // JS add-on
  createUninitializedBounds: createUninitializedBounds,
  getMajorAxisIndex: getMajorAxisIndex,
  floatToHex2: floatToHex2,
  floatRGB2HexCode: floatRGB2HexCode,
  float2CssRGBA: float2CssRGBA
};

var vtkMath$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createArray: createArray,
  Pi: Pi,
  radiansFromDegrees: radiansFromDegrees,
  degreesFromRadians: degreesFromRadians,
  round: round,
  floor: floor,
  ceil: ceil,
  min: min,
  max: max,
  arrayMin: arrayMin,
  arrayMax: arrayMax,
  arrayRange: arrayRange,
  ceilLog2: ceilLog2,
  factorial: factorial,
  nearestPowerOfTwo: nearestPowerOfTwo,
  isPowerOfTwo: isPowerOfTwo,
  binomial: binomial,
  beginCombination: beginCombination,
  nextCombination: nextCombination,
  randomSeed: randomSeed,
  getSeed: getSeed,
  random: random,
  gaussian: gaussian,
  add: add,
  subtract: subtract,
  multiplyScalar: multiplyScalar,
  multiplyScalar2D: multiplyScalar2D,
  multiplyAccumulate: multiplyAccumulate,
  multiplyAccumulate2D: multiplyAccumulate2D,
  dot: dot,
  outer: outer,
  cross: cross,
  norm: norm,
  normalize: normalize,
  perpendiculars: perpendiculars,
  projectVector: projectVector,
  dot2D: dot2D,
  projectVector2D: projectVector2D,
  distance2BetweenPoints: distance2BetweenPoints,
  angleBetweenVectors: angleBetweenVectors,
  signedAngleBetweenVectors: signedAngleBetweenVectors,
  gaussianAmplitude: gaussianAmplitude,
  gaussianWeight: gaussianWeight,
  outer2D: outer2D,
  norm2D: norm2D,
  normalize2D: normalize2D,
  rowsToMat4: rowsToMat4,
  columnsToMat4: columnsToMat4,
  rowsToMat3: rowsToMat3,
  columnsToMat3: columnsToMat3,
  determinant2x2: determinant2x2,
  LUFactor3x3: LUFactor3x3,
  LUSolve3x3: LUSolve3x3,
  linearSolve3x3: linearSolve3x3,
  multiply3x3_vect3: multiply3x3_vect3,
  multiply3x3_mat3: multiply3x3_mat3,
  multiplyMatrix: multiplyMatrix,
  transpose3x3: transpose3x3,
  invert3x3: invert3x3,
  determinant3x3: determinant3x3,
  areEquals: areEquals,
  areMatricesEqual: areMatricesEqual,
  identity3x3: identity3x3,
  identity: identity,
  isIdentity: isIdentity,
  isIdentity3x3: isIdentity3x3,
  quaternionToMatrix3x3: quaternionToMatrix3x3,
  roundNumber: roundNumber,
  roundVector: roundVector,
  jacobiN: jacobiN,
  matrix3x3ToQuaternion: matrix3x3ToQuaternion,
  multiplyQuaternion: multiplyQuaternion,
  orthogonalize3x3: orthogonalize3x3,
  diagonalize3x3: diagonalize3x3,
  singularValueDecomposition3x3: singularValueDecomposition3x3,
  luFactorLinearSystem: luFactorLinearSystem,
  luSolveLinearSystem: luSolveLinearSystem,
  solveLinearSystem: solveLinearSystem,
  invertMatrix: invertMatrix,
  estimateMatrixCondition: estimateMatrixCondition,
  jacobi: jacobi,
  solveHomogeneousLeastSquares: solveHomogeneousLeastSquares,
  solveLeastSquares: solveLeastSquares,
  hex2float: hex2float,
  rgb2hsv: rgb2hsv,
  hsv2rgb: hsv2rgb,
  lab2xyz: lab2xyz,
  xyz2lab: xyz2lab,
  xyz2rgb: xyz2rgb,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  lab2rgb: lab2rgb,
  uninitializeBounds: uninitializeBounds,
  areBoundsInitialized: areBoundsInitialized,
  computeBoundsFromPoints: computeBoundsFromPoints,
  clampValue: clampValue,
  clampVector: clampVector,
  clampAndNormalizeValue: clampAndNormalizeValue,
  getScalarTypeFittingRange: getScalarTypeFittingRange,
  getAdjustedScalarRange: getAdjustedScalarRange,
  extentIsWithinOtherExtent: extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds: boundsIsWithinOtherBounds,
  pointIsWithinBounds: pointIsWithinBounds,
  solve3PointCircle: solve3PointCircle,
  inf: inf,
  negInf: negInf,
  isInf: isInf,
  isFinite: isFinite,
  isNaN: isNaN,
  isNan: isNan,
  createUninitializedBounds: createUninitializedBounds,
  getMajorAxisIndex: getMajorAxisIndex,
  floatToHex2: floatToHex2,
  floatRGB2HexCode: floatRGB2HexCode,
  float2CssRGBA: float2CssRGBA,
  'default': vtkMath
});




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/macros.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/macros.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EVENT_ABORT: () => (/* binding */ EVENT_ABORT),
/* harmony export */   TYPED_ARRAYS: () => (/* binding */ TYPED_ARRAYS),
/* harmony export */   VOID: () => (/* binding */ VOID),
/* harmony export */   _capitalize: () => (/* binding */ _capitalize),
/* harmony export */   algo: () => (/* binding */ algo),
/* harmony export */   capitalize: () => (/* binding */ capitalize),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   debounce: () => (/* binding */ debounce),
/* harmony export */   "default": () => (/* binding */ macro),
/* harmony export */   event: () => (/* binding */ event),
/* harmony export */   formatBytesToProperUnit: () => (/* binding */ formatBytesToProperUnit),
/* harmony export */   formatNumbersWithThousandSeparator: () => (/* binding */ formatNumbersWithThousandSeparator),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   getArray: () => (/* binding */ getArray),
/* harmony export */   isVtkObject: () => (/* binding */ isVtkObject),
/* harmony export */   keystore: () => (/* binding */ keystore),
/* harmony export */   measurePromiseExecution: () => (/* binding */ measurePromiseExecution),
/* harmony export */   moveToProtected: () => (/* binding */ moveToProtected),
/* harmony export */   newInstance: () => (/* binding */ newInstance),
/* harmony export */   newTypedArray: () => (/* binding */ newTypedArray),
/* harmony export */   newTypedArrayFrom: () => (/* binding */ newTypedArrayFrom),
/* harmony export */   normalizeWheel: () => (/* binding */ normalizeWheel),
/* harmony export */   obj: () => (/* binding */ obj),
/* harmony export */   proxy: () => (/* binding */ proxy),
/* harmony export */   proxyPropertyMapping: () => (/* binding */ proxyPropertyMapping),
/* harmony export */   proxyPropertyState: () => (/* binding */ proxyPropertyState),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setArray: () => (/* binding */ setArray),
/* harmony export */   setGet: () => (/* binding */ setGet),
/* harmony export */   setGetArray: () => (/* binding */ setGetArray),
/* harmony export */   setImmediateVTK: () => (/* binding */ setImmediateVTK),
/* harmony export */   setLoggerFunction: () => (/* binding */ setLoggerFunction),
/* harmony export */   throttle: () => (/* binding */ throttle),
/* harmony export */   traverseInstanceTree: () => (/* binding */ traverseInstanceTree),
/* harmony export */   uncapitalize: () => (/* binding */ uncapitalize),
/* harmony export */   vtkDebugMacro: () => (/* binding */ vtkDebugMacro),
/* harmony export */   vtkErrorMacro: () => (/* binding */ vtkErrorMacro),
/* harmony export */   vtkInfoMacro: () => (/* binding */ vtkInfoMacro),
/* harmony export */   vtkLogMacro: () => (/* binding */ vtkLogMacro),
/* harmony export */   vtkOnceErrorMacro: () => (/* binding */ vtkOnceErrorMacro),
/* harmony export */   vtkWarningMacro: () => (/* binding */ vtkWarningMacro)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/construct */ "../../../node_modules/@babel/runtime/helpers/esm/construct.js");
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fast-deep-equal */ "../../../node_modules/fast-deep-equal/index.js");
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _vtk_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./vtk.js */ "../../../node_modules/@kitware/vtk.js/vtk.js");
/* harmony import */ var _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Common/Core/ClassHierarchy.js */ "../../../node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js");









function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var globalMTime = 0;
var VOID = Symbol('void');

function getCurrentGlobalMTime() {
  return globalMTime;
} // ----------------------------------------------------------------------------
// Logging function calls
// ----------------------------------------------------------------------------

/* eslint-disable no-prototype-builtins                                      */


var fakeConsole = {};

function noOp() {}

var consoleMethods = ['log', 'debug', 'info', 'warn', 'error', 'time', 'timeEnd', 'group', 'groupEnd'];
consoleMethods.forEach(function (methodName) {
  fakeConsole[methodName] = noOp;
});
_vtk_js__WEBPACK_IMPORTED_MODULE_6__.vtkGlobal.console = console.hasOwnProperty('log') ? console : fakeConsole;
var loggerFunctions = {
  debug: noOp,
  // Don't print debug by default
  error: _vtk_js__WEBPACK_IMPORTED_MODULE_6__.vtkGlobal.console.error || noOp,
  info: _vtk_js__WEBPACK_IMPORTED_MODULE_6__.vtkGlobal.console.info || noOp,
  log: _vtk_js__WEBPACK_IMPORTED_MODULE_6__.vtkGlobal.console.log || noOp,
  warn: _vtk_js__WEBPACK_IMPORTED_MODULE_6__.vtkGlobal.console.warn || noOp
};
function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}
function vtkLogMacro() {
  loggerFunctions.log.apply(loggerFunctions, arguments);
}
function vtkInfoMacro() {
  loggerFunctions.info.apply(loggerFunctions, arguments);
}
function vtkDebugMacro() {
  loggerFunctions.debug.apply(loggerFunctions, arguments);
}
function vtkErrorMacro() {
  loggerFunctions.error.apply(loggerFunctions, arguments);
}
function vtkWarningMacro() {
  loggerFunctions.warn.apply(loggerFunctions, arguments);
}
var ERROR_ONCE_MAP = {};
function vtkOnceErrorMacro(str) {
  if (!ERROR_ONCE_MAP[str]) {
    loggerFunctions.error(str);
    ERROR_ONCE_MAP[str] = true;
  }
} // ----------------------------------------------------------------------------
// TypedArray
// ----------------------------------------------------------------------------

var TYPED_ARRAYS = Object.create(null);
TYPED_ARRAYS.Float32Array = Float32Array;
TYPED_ARRAYS.Float64Array = Float64Array;
TYPED_ARRAYS.Uint8Array = Uint8Array;
TYPED_ARRAYS.Int8Array = Int8Array;
TYPED_ARRAYS.Uint16Array = Uint16Array;
TYPED_ARRAYS.Int16Array = Int16Array;
TYPED_ARRAYS.Uint32Array = Uint32Array;
TYPED_ARRAYS.Int32Array = Int32Array;
TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;

try {
  TYPED_ARRAYS.BigInt64Array = BigInt64Array;
  TYPED_ARRAYS.BigUint64Array = BigUint64Array;
} catch (_unused) {// ignore
}

function newTypedArray(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return (0,_babel_runtime_helpers_construct__WEBPACK_IMPORTED_MODULE_4__["default"])(TYPED_ARRAYS[type] || Float64Array, args);
}
function newTypedArrayFrom(type) {
  var _ref;

  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return (_ref = TYPED_ARRAYS[type] || Float64Array).from.apply(_ref, args);
} // ----------------------------------------------------------------------------
// capitilize provided string
// ----------------------------------------------------------------------------

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function _capitalize(str) {
  return capitalize(str[0] === '_' ? str.slice(1) : str);
}
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
} // ----------------------------------------------------------------------------
// Convert byte size into a well formatted string
// ----------------------------------------------------------------------------

function formatBytesToProperUnit(size) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var chunkSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
  var units = ['TB', 'GB', 'MB', 'KB'];
  var value = Number(size);
  var currentUnit = 'B';

  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }

  return "".concat(value.toFixed(precision), " ").concat(currentUnit);
} // ----------------------------------------------------------------------------
// Convert thousand number with proper separator
// ----------------------------------------------------------------------------

function formatNumbersWithThousandSeparator(n) {
  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
  var sections = [];
  var size = n;

  while (size > 1000) {
    sections.push("000".concat(size % 1000).slice(-3));
    size = Math.floor(size / 1000);
  }

  if (size > 0) {
    sections.push(size);
  }

  sections.reverse();
  return sections.join(separator);
} // ----------------------------------------------------------------------------
// Array helper
// ----------------------------------------------------------------------------

function safeArrays(model) {
  Object.keys(model).forEach(function (key) {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
} // ----------------------------------------------------------------------------
// shallow equals
// ----------------------------------------------------------------------------


function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
} // ----------------------------------------------------------------------------


function enumToString(e, value) {
  return Object.keys(e).find(function (key) {
    return e[key] === value;
  });
}

function getStateArrayMapFunc(item) {
  if (item && item.isA) {
    return item.getState();
  }

  return item;
} // ----------------------------------------------------------------------------
// setImmediate
// ----------------------------------------------------------------------------


function setImmediateVTK(fn) {
  setTimeout(fn, 0);
} // ----------------------------------------------------------------------------
// measurePromiseExecution
//
// Measures the time it takes for a promise to finish from
//   the time this function is invoked.
// The callback receives the time it took for the promise to resolve or reject.
// ----------------------------------------------------------------------------

function measurePromiseExecution(promise, callback) {
  var start = performance.now();
  promise.finally(function () {
    var delta = performance.now() - start;
    callback(delta);
  });
} // ----------------------------------------------------------------------------
// vtkObject: modified(), onModified(callback), delete()
// ----------------------------------------------------------------------------

function obj() {
  var publicAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // Ensure each instance as a unique ref of array
  safeArrays(model);
  var callbacks = [];

  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }

  if (!('classHierarchy' in model)) {
    model.classHierarchy = new _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_7__["default"]('vtkObject');
  } else if (!(model.classHierarchy instanceof _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_7__["default"])) {
    var hierarchy = new _Common_Core_ClassHierarchy_js__WEBPACK_IMPORTED_MODULE_7__["default"]();

    for (var i = 0; i < model.classHierarchy.length; i++) {
      hierarchy.push(model.classHierarchy[i]);
    }

    model.classHierarchy = hierarchy;
  }

  function off(index) {
    callbacks[index] = null;
  }

  function on(index) {
    function unsubscribe() {
      off(index);
    }

    return Object.freeze({
      unsubscribe: unsubscribe
    });
  }

  publicAPI.isDeleted = function () {
    return !!model.deleted;
  };

  publicAPI.modified = function (otherMTime) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }

    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }

    model.mtime = ++globalMTime;
    callbacks.forEach(function (callback) {
      return callback && callback(publicAPI);
    });
  };

  publicAPI.onModified = function (callback) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }

    var index = callbacks.length;
    callbacks.push(callback);
    return on(index);
  };

  publicAPI.getMTime = function () {
    return model.mtime;
  };

  publicAPI.isA = function (className) {
    var count = model.classHierarchy.length; // we go backwards as that is more likely for
    // early termination

    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }

    return false;
  };

  publicAPI.getClassName = function () {
    var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.classHierarchy[model.classHierarchy.length - 1 - depth];
  };

  publicAPI.set = function () {
    var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var noWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var noFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var ret = false;
    Object.keys(map).forEach(function (name) {
      var fn = noFunction ? null : publicAPI["set".concat(capitalize(name))];

      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn.apply(void 0, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__["default"])(map[name])) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        // Set data on model directly
        if (['mtime'].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro("Warning: Set value to model directly ".concat(name, ", ").concat(map[name]));
        }

        ret = model[name] !== map[name] || ret;
        model[name] = map[name];
      }
    });
    return ret;
  };

  publicAPI.get = function () {
    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      list[_key3] = arguments[_key3];
    }

    if (!list.length) {
      return model;
    }

    var subset = {};
    list.forEach(function (name) {
      subset[name] = model[name];
    });
    return subset;
  };

  publicAPI.getReferenceByName = function (val) {
    return model[val];
  };

  publicAPI.delete = function () {
    Object.keys(model).forEach(function (field) {
      return delete model[field];
    });
    callbacks.forEach(function (el, index) {
      return off(index);
    }); // Flag the instance being deleted

    model.deleted = true;
  }; // Add serialization support


  publicAPI.getState = function () {
    if (model.deleted) {
      return null;
    }

    var jsonArchive = _objectSpread(_objectSpread({}, model), {}, {
      vtkClass: publicAPI.getClassName()
    }); // Convert every vtkObject to its serializable form


    Object.keys(jsonArchive).forEach(function (keyName) {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === undefined || keyName[0] === '_' // protected members start with _
      ) {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      }
    }); // Sort resulting object by key name

    var sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(function (name) {
      sortedObj[name] = jsonArchive[name];
    }); // Remove mtime

    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }

    return sortedObj;
  }; // Add shallowCopy(otherInstance) support


  publicAPI.shallowCopy = function (other) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error("Cannot ShallowCopy ".concat(other.getClassName(), " into ").concat(publicAPI.getClassName()));
    }

    var otherModel = other.get();
    var keyList = Object.keys(model).sort();
    var otherKeyList = Object.keys(otherModel).sort();
    otherKeyList.forEach(function (key) {
      var keyIdx = keyList.indexOf(key);

      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro("add ".concat(key, " in shallowCopy"));
        }
      } else {
        keyList.splice(keyIdx, 1);
      }

      model[key] = otherModel[key];
    });

    if (keyList.length && debug) {
      vtkDebugMacro("Untouched keys: ".concat(keyList.join(', ')));
    }

    publicAPI.modified();
  }; // This function will get called when one invoke JSON.stringify(vtkObject)
  // JSON.stringify will only stringify the return value of this function


  publicAPI.toJSON = function vtkObjToJSON() {
    return publicAPI.getState();
  }; // Allow usage as decorator


  return publicAPI;
} // ----------------------------------------------------------------------------
// getXXX: add getters
// ----------------------------------------------------------------------------

var objectGetterMap = {
  object: function object(publicAPI, model, field) {
    return function getter() {
      return _objectSpread({}, model[field.name]);
    };
  }
};
function get(publicAPI, model, fieldNames) {
  fieldNames.forEach(function (field) {
    if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__["default"])(field) === 'object') {
      var getter = objectGetterMap[field.type];

      if (getter) {
        publicAPI["get".concat(_capitalize(field.name))] = getter(publicAPI, model, field);
      } else {
        publicAPI["get".concat(_capitalize(field.name))] = function () {
          return model[field.name];
        };
      }
    } else {
      publicAPI["get".concat(_capitalize(field))] = function () {
        return model[field];
      };
    }
  });
} // ----------------------------------------------------------------------------
// setXXX: add setters
// ----------------------------------------------------------------------------

var objectSetterMap = {
  enum: function _enum(publicAPI, model, field) {
    var onChanged = "_on".concat(_capitalize(field.name), "Changed");
    return function (value) {
      if (typeof value === 'string') {
        if (field.enum[value] !== undefined) {
          if (model[field.name] !== field.enum[value]) {
            model[field.name] = field.enum[value];
            publicAPI.modified();
            return true;
          }

          return false;
        }

        vtkErrorMacro("Set Enum with invalid argument ".concat(field, ", ").concat(value));
        throw new RangeError('Set Enum with invalid string argument');
      }

      if (typeof value === 'number') {
        if (model[field.name] !== value) {
          if (Object.keys(field.enum).map(function (key) {
            return field.enum[key];
          }).indexOf(value) !== -1) {
            var _model$onChanged;

            var previousValue = model[field.name];
            model[field.name] = value;
            (_model$onChanged = model[onChanged]) === null || _model$onChanged === void 0 ? void 0 : _model$onChanged.call(model, publicAPI, model, value, previousValue);
            publicAPI.modified();
            return true;
          }

          vtkErrorMacro("Set Enum outside numeric range ".concat(field, ", ").concat(value));
          throw new RangeError('Set Enum outside numeric range');
        }

        return false;
      }

      vtkErrorMacro("Set Enum with invalid argument (String/Number) ".concat(field, ", ").concat(value));
      throw new TypeError('Set Enum with invalid argument (String/Number)');
    };
  },
  object: function object(publicAPI, model, field) {
    var onChanged = "_on".concat(_capitalize(field.name), "Changed");
    return function (value) {
      if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_5___default()(model[field.name], value)) {
        var _model$onChanged2;

        var previousValue = model[field.name];
        model[field.name] = value;
        (_model$onChanged2 = model[onChanged]) === null || _model$onChanged2 === void 0 ? void 0 : _model$onChanged2.call(model, publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }

      return false;
    };
  }
};

function findSetter(field) {
  if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__["default"])(field) === 'object') {
    var fn = objectSetterMap[field.type];

    if (fn) {
      return function (publicAPI, model) {
        return fn(publicAPI, model, field);
      };
    }

    vtkErrorMacro("No setter for field ".concat(field));
    throw new TypeError('No setter for field');
  }

  return function getSetter(publicAPI, model) {
    var onChanged = "_on".concat(_capitalize(field), "Changed");
    return function setter(value) {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }

      if (model[field] !== value) {
        var _model$onChanged3;

        var previousValue = model[field.name];
        model[field] = value;
        (_model$onChanged3 = model[onChanged]) === null || _model$onChanged3 === void 0 ? void 0 : _model$onChanged3.call(model, publicAPI, model, value, previousValue);
        publicAPI.modified();
        return true;
      }

      return false;
    };
  };
}

function set(publicAPI, model, fields) {
  fields.forEach(function (field) {
    if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_1__["default"])(field) === 'object') {
      publicAPI["set".concat(_capitalize(field.name))] = findSetter(field)(publicAPI, model);
    } else {
      publicAPI["set".concat(_capitalize(field))] = findSetter(field)(publicAPI, model);
    }
  });
} // ----------------------------------------------------------------------------
// set/get XXX: add both setters and getters
// ----------------------------------------------------------------------------

function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set(publicAPI, model, fieldNames);
} // ----------------------------------------------------------------------------
// getXXX: add getters for object of type array with copy to be safe
// getXXXByReference: add getters for object of type array without copy
// ----------------------------------------------------------------------------

function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach(function (field) {
    publicAPI["get".concat(_capitalize(field))] = function () {
      return model[field] ? Array.from(model[field]) : model[field];
    };

    publicAPI["get".concat(_capitalize(field), "ByReference")] = function () {
      return model[field];
    };
  });
} // ----------------------------------------------------------------------------
// setXXX: add setter for object of type array
// if 'defaultVal' is supplied, shorter arrays will be padded to 'size' with 'defaultVal'
// set...From: fast path to copy the content of an array to the current one without call to modified.
// ----------------------------------------------------------------------------

function setArray(publicAPI, model, fieldNames, size) {
  var defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  fieldNames.forEach(function (field) {
    if (model[field] && size && model[field].length !== size) {
      throw new RangeError("Invalid initial number of values for array (".concat(field, ")"));
    }

    var onChanged = "_on".concat(_capitalize(field), "Changed");

    publicAPI["set".concat(_capitalize(field))] = function () {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var array = args;
      var changeDetected;
      var needCopy = false; // allow null or an array to be passed as a single arg.

      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
        /* eslint-disable prefer-destructuring */
        array = array[0];
        /* eslint-enable prefer-destructuring */

        needCopy = true;
      }

      if (array == null) {
        changeDetected = model[field] !== array;
      } else {
        if (size && array.length !== size) {
          if (array.length < size && defaultVal !== undefined) {
            array = Array.from(array);
            needCopy = false;

            while (array.length < size) {
              array.push(defaultVal);
            }
          } else {
            throw new RangeError("Invalid number of values for array setter (".concat(field, ")"));
          }
        }

        changeDetected = model[field] == null || model[field].length !== array.length;

        for (var i = 0; !changeDetected && i < array.length; ++i) {
          changeDetected = model[field][i] !== array[i];
        }

        if (changeDetected && needCopy) {
          array = Array.from(array);
        }
      }

      if (changeDetected) {
        var _model$onChanged4;

        var previousValue = model[field.name];
        model[field] = array;
        (_model$onChanged4 = model[onChanged]) === null || _model$onChanged4 === void 0 ? void 0 : _model$onChanged4.call(model, publicAPI, model, array, previousValue);
        publicAPI.modified();
      }

      return changeDetected;
    };

    publicAPI["set".concat(_capitalize(field), "From")] = function (otherArray) {
      var target = model[field];
      otherArray.forEach(function (v, i) {
        target[i] = v;
      });
    };
  });
} // ----------------------------------------------------------------------------
// set/get XXX: add setter and getter for object of type array
// ----------------------------------------------------------------------------

function setGetArray(publicAPI, model, fieldNames, size) {
  var defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size, defaultVal);
}
function moveToProtected(publicAPI, model, fieldNames) {
  for (var i = 0; i < fieldNames.length; i++) {
    var fieldName = fieldNames[i];

    if (model[fieldName] !== undefined) {
      model["_".concat(fieldName)] = model[fieldName];
      delete model[fieldName];
    }
  }
} // ----------------------------------------------------------------------------
// vtkAlgorithm: setInputData(), setInputConnection(), getOutputData(), getOutputPort()
// ----------------------------------------------------------------------------

function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(_vtk_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
  } else {
    model.inputData = [];
  }

  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(_vtk_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
  } else {
    model.inputConnection = [];
  }

  if (model.output) {
    model.output = model.output.map(_vtk_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
  } else {
    model.output = [];
  }

  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(_vtk_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
  } else {
    model.inputArrayToProcess = [];
  } // Cache the argument for later manipulation


  model.numberOfInputs = numberOfInputs; // Methods

  function setInputData(dataset) {
    var port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }

    if (port >= model.numberOfInputs) {
      vtkErrorMacro("algorithm ".concat(publicAPI.getClassName(), " only has ").concat(model.numberOfInputs, " input ports. To add more input ports, use addInputData()"));
      return;
    }

    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;

      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }

  function getInputData() {
    var port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }

    return model.inputData[port];
  }

  function setInputConnection(outputPort) {
    var port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }

    if (port >= model.numberOfInputs) {
      var msg = "algorithm ".concat(publicAPI.getClassName(), " only has ");
      msg += "".concat(model.numberOfInputs);
      msg += ' input ports. To add more input ports, use addInputConnection()';
      vtkErrorMacro(msg);
      return;
    }

    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }

  function getInputConnection() {
    var port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return model.inputConnection[port];
  }

  function getPortToFill() {
    var portToFill = model.numberOfInputs;

    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
      portToFill--;
    }

    if (portToFill === model.numberOfInputs) {
      model.numberOfInputs++;
    }

    return portToFill;
  }

  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }

    setInputConnection(outputPort, getPortToFill());
  }

  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }

    setInputData(dataset, getPortToFill());
  }

  function getOutputData() {
    var port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }

    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }

    return model.output[port];
  }

  publicAPI.shouldUpdate = function () {
    var localMTime = publicAPI.getMTime();
    var minOutputMTime = Infinity;
    var count = numberOfOutputs;

    while (count--) {
      if (!model.output[count] || model.output[count].isDeleted()) {
        return true;
      }

      var mt = model.output[count].getMTime();

      if (mt < localMTime) {
        return true;
      }

      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }

    count = model.numberOfInputs;

    while (count--) {
      var _model$inputConnectio, _publicAPI$getInputDa;

      if ((_model$inputConnectio = model.inputConnection[count]) !== null && _model$inputConnectio !== void 0 && _model$inputConnectio.filter.shouldUpdate() || ((_publicAPI$getInputDa = publicAPI.getInputData(count)) === null || _publicAPI$getInputDa === void 0 ? void 0 : _publicAPI$getInputDa.getMTime()) > minOutputMTime) {
        return true;
      }
    }

    return false;
  };

  function getOutputPort() {
    var port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var outputPortAccess = function outputPortAccess() {
      return getOutputData(port);
    }; // Add reference to filter


    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  } // Handle input if needed


  if (model.numberOfInputs) {
    // Reserve inputs
    var count = model.numberOfInputs;

    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    } // Expose public methods


    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }

  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }

  publicAPI.update = function () {
    var ins = [];

    if (model.numberOfInputs) {
      var _count = 0;

      while (_count < model.numberOfInputs) {
        ins[_count] = publicAPI.getInputData(_count);
        _count++;
      }
    }

    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };

  publicAPI.getNumberOfInputPorts = function () {
    return model.numberOfInputs;
  };

  publicAPI.getNumberOfOutputPorts = function () {
    return numberOfOutputs || model.output.length;
  };

  publicAPI.getInputArrayToProcess = function (inputPort) {
    var arrayDesc = model.inputArrayToProcess[inputPort];
    var ds = model.inputData[inputPort];

    if (arrayDesc && ds) {
      return ds["get".concat(arrayDesc.fieldAssociation)]().getArray(arrayDesc.arrayName);
    }

    return null;
  };

  publicAPI.setInputArrayToProcess = function (inputPort, arrayName, fieldAssociation) {
    var attributeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Scalars';

    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }

    model.inputArrayToProcess[inputPort] = {
      arrayName: arrayName,
      fieldAssociation: fieldAssociation,
      attributeType: attributeType
    };
  };
} // ----------------------------------------------------------------------------
// Event handling: onXXX(callback), invokeXXX(args...)
// ----------------------------------------------------------------------------

var EVENT_ABORT = Symbol('Event abort');
function event(publicAPI, model, eventName) {
  var callbacks = [];
  var previousDelete = publicAPI.delete;
  var curCallbackID = 1;

  function off(callbackID) {
    for (var i = 0; i < callbacks.length; ++i) {
      var _callbacks$i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(callbacks[i], 1),
          cbID = _callbacks$i[0];

      if (cbID === callbackID) {
        callbacks.splice(i, 1);
        return;
      }
    }
  }

  function on(callbackID) {
    function unsubscribe() {
      off(callbackID);
    }

    return Object.freeze({
      unsubscribe: unsubscribe
    });
  }

  function invoke() {
    var _arguments = arguments;

    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    /* eslint-disable prefer-rest-params */
    // Go through a copy of the callbacks array in case new callbacks
    // get prepended within previous callbacks


    var currentCallbacks = callbacks.slice();

    var _loop = function _loop(index) {
      var _currentCallbacks$ind = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(currentCallbacks[index], 3),
          cb = _currentCallbacks$ind[1],
          priority = _currentCallbacks$ind[2];

      if (!cb) {
        return "continue"; // eslint-disable-line
      }

      if (priority < 0) {
        setTimeout(function () {
          return cb.apply(publicAPI, _arguments);
        }, 1 - priority);
      } else {
        // Abort only if the callback explicitly returns false
        var continueNext = cb.apply(publicAPI, _arguments);

        if (continueNext === EVENT_ABORT) {
          return "break";
        }
      }
    };

    for (var index = 0; index < currentCallbacks.length; ++index) {
      var _ret = _loop(index);

      if (_ret === "continue") continue;
      if (_ret === "break") break;
    }
    /* eslint-enable prefer-rest-params */

  }

  publicAPI["invoke".concat(_capitalize(eventName))] = invoke;

  publicAPI["on".concat(_capitalize(eventName))] = function (callback) {
    var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;

    if (!callback.apply) {
      console.error("Invalid callback for event ".concat(eventName));
      return null;
    }

    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }

    var callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort(function (cb1, cb2) {
      return cb2[2] - cb1[2];
    });
    return on(callbackID);
  };

  publicAPI.delete = function () {
    previousDelete();
    callbacks.forEach(function (_ref2) {
      var _ref3 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref2, 1),
          cbID = _ref3[0];

      return off(cbID);
    });
  };
} // ----------------------------------------------------------------------------
// newInstance
// ----------------------------------------------------------------------------

function newInstance(extend, className) {
  var constructor = function constructor() {
    var initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var model = {};
    var publicAPI = {};
    extend(publicAPI, model, initialValues);
    return Object.freeze(publicAPI);
  }; // Register constructor to factory


  if (className) {
    _vtk_js__WEBPACK_IMPORTED_MODULE_6__["default"].register(className, constructor);
  }

  return constructor;
} // ----------------------------------------------------------------------------
// Chain function calls
// ----------------------------------------------------------------------------

function chain() {
  for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    fn[_key5] = arguments[_key5];
  }

  return function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return fn.filter(function (i) {
      return !!i;
    }).map(function (i) {
      return i.apply(void 0, args);
    });
  };
} // ----------------------------------------------------------------------------
// Some utility methods for vtk objects
// ----------------------------------------------------------------------------

function isVtkObject(instance) {
  return instance && instance.isA && instance.isA('vtkObject');
}
function traverseInstanceTree(instance, extractFunction) {
  var accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var visitedInstances = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      // avoid cycles
      return accumulator;
    }

    visitedInstances.push(instance);
    var result = extractFunction(instance);

    if (result !== undefined) {
      accumulator.push(result);
    } // Now go through this instance's model


    var model = instance.get();
    Object.keys(model).forEach(function (key) {
      var modelObj = model[key];

      if (Array.isArray(modelObj)) {
        modelObj.forEach(function (subObj) {
          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
        });
      } else {
        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
      }
    });
  }

  return accumulator;
} // ----------------------------------------------------------------------------
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.

function debounce(func, wait, immediate) {
  var _this = this;

  var timeout;

  var debounced = function debounced() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    var context = _this;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };

  debounced.cancel = function () {
    return clearTimeout(timeout);
  };

  return debounced;
} // ----------------------------------------------------------------------------
// Creates a throttled function that only invokes `func` at most once per
// every `wait` milliseconds.

function throttle(callback, delay) {
  var isThrottled = false;
  var argsToUse = null;

  function next() {
    isThrottled = false;

    if (argsToUse !== null) {
      wrapper.apply(void 0, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_3__["default"])(argsToUse)); // eslint-disable-line

      argsToUse = null;
    }
  }

  function wrapper() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    if (isThrottled) {
      argsToUse = args;
      return;
    }

    isThrottled = true;
    callback.apply(void 0, args);
    setTimeout(next, delay);
  }

  return wrapper;
} // ----------------------------------------------------------------------------
// keystore(publicAPI, model, initialKeystore)
//
//    - initialKeystore: Initial keystore. This can be either a Map or an
//      object.
//
// Generated API
//  setKey(key, value) : mixed (returns value)
//  getKey(key) : mixed
//  getAllKeys() : [mixed]
//  deleteKey(key) : Boolean
// ----------------------------------------------------------------------------

function keystore(publicAPI, model) {
  var initialKeystore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);

  publicAPI.setKey = function (key, value) {
    model.keystore[key] = value;
  };

  publicAPI.getKey = function (key) {
    return model.keystore[key];
  };

  publicAPI.getAllKeys = function () {
    return Object.keys(model.keystore);
  };

  publicAPI.deleteKey = function (key) {
    return delete model.keystore[key];
  };

  publicAPI.clearKeystore = function () {
    return publicAPI.getAllKeys().forEach(function (key) {
      return delete model.keystore[key];
    });
  };
} // ----------------------------------------------------------------------------
// proxy(publicAPI, model, sectionName, propertyUI)
//
//    - sectionName: Name of the section for UI
//    - propertyUI: List of props with their UI description
//
// Generated API
//  getProxyId() : String
//  listProxyProperties() : [string]
//  updateProxyProperty(name, prop)
//  getProxySection() => List of properties for UI generation
// ----------------------------------------------------------------------------

var nextProxyId = 1;
var ROOT_GROUP_NAME = '__root__';
function proxy(publicAPI, model) {
  // Proxies are keystores
  keystore(publicAPI, model);
  var parentDelete = publicAPI.delete; // getProxyId

  model.proxyId = "".concat(nextProxyId++); // ui handling

  model.ui = JSON.parse(JSON.stringify(model.ui || [])); // deep copy

  get(publicAPI, model, ['proxyId', 'proxyGroup', 'proxyName']);
  setGet(publicAPI, model, ['proxyManager']); // group properties

  var propertyMap = {};
  var groupChildrenNames = {};

  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }

    var childrenNames = groupChildrenNames[currentGroupName];

    for (var i = 0; i < descriptionList.length; i++) {
      childrenNames.push(descriptionList[i].name);
      propertyMap[descriptionList[i].name] = descriptionList[i];

      if (descriptionList[i].children && descriptionList[i].children.length) {
        registerProperties(descriptionList[i].children, descriptionList[i].name);
      }
    }
  }

  registerProperties(model.ui, ROOT_GROUP_NAME);

  publicAPI.updateUI = function (ui) {
    model.ui = JSON.parse(JSON.stringify(ui || [])); // deep copy

    Object.keys(propertyMap).forEach(function (k) {
      return delete propertyMap[k];
    });
    Object.keys(groupChildrenNames).forEach(function (k) {
      return delete groupChildrenNames[k];
    });
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };

  function listProxyProperties() {
    var gName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    return groupChildrenNames[gName];
  }

  publicAPI.updateProxyProperty = function (propertyName, propUI) {
    var prop = propertyMap[propertyName];

    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = _objectSpread({}, propUI);
    }
  };

  publicAPI.activate = function () {
    if (model.proxyManager) {
      var setActiveMethod = "setActive".concat(_capitalize(publicAPI.getProxyGroup().slice(0, -1)));

      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  }; // property link


  model.propertyLinkSubscribers = {};

  publicAPI.registerPropertyLinkForGC = function (otherLink, type) {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }

    model.propertyLinkSubscribers[type].push(otherLink);
  };

  publicAPI.gcPropertyLinks = function (type) {
    var subscribers = model.propertyLinkSubscribers[type] || [];

    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };

  model.propertyLinkMap = {};

  publicAPI.getPropertyLink = function (id) {
    var persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }

    var value = null;
    var links = [];
    var count = 0;
    var updateInProgress = false;

    function update(source) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (updateInProgress) {
        return null;
      }

      var needUpdate = [];
      var sourceLink = null;
      count = links.length;

      while (count--) {
        var link = links[count];

        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }

      if (!sourceLink) {
        return null;
      }

      var newValue = sourceLink.instance["get".concat(_capitalize(sourceLink.propertyName))]();

      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;

        while (needUpdate.length) {
          var linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set((0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])({}, linkToUpdate.propertyName, value));
        }

        updateInProgress = false;
      }

      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }

      return newValue;
    }

    function unbind(instance, propertyName) {
      var indexToDelete = [];
      count = links.length;

      while (count--) {
        var link = links[count];

        if (link.instance === instance && (link.propertyName === propertyName || propertyName === undefined)) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }

      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }

    function bind(instance, propertyName) {
      var updateMe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var subscription = instance.onModified(update);
      var other = links[0];
      links.push({
        instance: instance,
        propertyName: propertyName,
        subscription: subscription
      });

      if (updateMe) {
        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== undefined) {
          instance.set((0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])({}, propertyName, model.propertyLinkMap[id].value));
        } else if (other) {
          update(other.instance, true);
        }
      }

      return {
        unsubscribe: function unsubscribe() {
          return unbind(instance, propertyName);
        }
      };
    }

    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }

    var linkHandler = {
      bind: bind,
      unbind: unbind,
      unsubscribe: unsubscribe,
      persistent: persistent
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  }; // extract values


  function getProperties() {
    var groupName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
    var values = [];
    var id = model.proxyId;
    var propertyNames = listProxyProperties(groupName) || [];

    for (var i = 0; i < propertyNames.length; i++) {
      var name = propertyNames[i];
      var method = publicAPI["get".concat(_capitalize(name))];
      var value = method ? method() : undefined;
      var prop = {
        id: id,
        name: name,
        value: value
      };
      var children = getProperties(name);

      if (children.length) {
        prop.children = children;
      }

      values.push(prop);
    }

    return values;
  }

  publicAPI.listPropertyNames = function () {
    return getProperties().map(function (p) {
      return p.name;
    });
  };

  publicAPI.getPropertyByName = function (name) {
    return getProperties().find(function (p) {
      return p.name === name;
    });
  };

  publicAPI.getPropertyDomainByName = function (name) {
    return (propertyMap[name] || {}).domain;
  }; // ui section


  publicAPI.getProxySection = function () {
    return {
      id: model.proxyId,
      name: model.proxyGroup,
      ui: model.ui,
      properties: getProperties()
    };
  }; // free resources


  publicAPI.delete = function () {
    var list = Object.keys(model.propertyLinkMap);
    var count = list.length;

    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }

    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
    parentDelete();
  }; // @todo fix infinite recursion due to active source


  publicAPI.getState = function () {
    return null;
  };

  function registerLinks() {
    // Allow dynamic registration of links at the application level
    if (model.links) {
      for (var i = 0; i < model.links.length; i++) {
        var _model$links$i = model.links[i],
            link = _model$links$i.link,
            property = _model$links$i.property,
            persistent = _model$links$i.persistent,
            updateOnBind = _model$links$i.updateOnBind,
            type = _model$links$i.type;

        if (type === 'application') {
          var sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, 'application');
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }

  setImmediateVTK(registerLinks);
} // ----------------------------------------------------------------------------
// proxyPropertyMapping(publicAPI, model, map)
//
//   map = {
//      opacity: { modelKey: 'property', property: 'opacity' },
//   }
//
// Generated API:
//  Elevate set/get methods from internal object stored in the model to current one
// ----------------------------------------------------------------------------

function proxyPropertyMapping(publicAPI, model, map) {
  var parentDelete = publicAPI.delete;
  var subscriptions = [];
  var propertyNames = Object.keys(map);
  var count = propertyNames.length;

  while (count--) {
    var propertyName = propertyNames[count];
    var _map$propertyName = map[propertyName],
        modelKey = _map$propertyName.modelKey,
        property = _map$propertyName.property,
        _map$propertyName$mod = _map$propertyName.modified,
        modified = _map$propertyName$mod === void 0 ? true : _map$propertyName$mod;

    var methodSrc = _capitalize(property);

    var methodDst = _capitalize(propertyName);

    publicAPI["get".concat(methodDst)] = model[modelKey]["get".concat(methodSrc)];
    publicAPI["set".concat(methodDst)] = model[modelKey]["set".concat(methodSrc)];

    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }

  publicAPI.delete = function () {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }

    parentDelete();
  };
} // ----------------------------------------------------------------------------
// proxyPropertyState(publicAPI, model, state, defaults)
//
//   state = {
//     representation: {
//       'Surface with edges': { property: { edgeVisibility: true, representation: 2 } },
//       Surface: { property: { edgeVisibility: false, representation: 2 } },
//       Wireframe: { property: { edgeVisibility: false, representation: 1 } },
//       Points: { property: { edgeVisibility: false, representation: 0 } },
//     },
//   }
//
//   defaults = {
//      representation: 'Surface',
//   }
//
// Generated API
//   get / set Representation ( string ) => push state to various internal objects
// ----------------------------------------------------------------------------

function proxyPropertyState(publicAPI, model) {
  var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var defaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  model.this = publicAPI;

  function applyState(map) {
    var modelKeys = Object.keys(map);
    var count = modelKeys.length;

    while (count--) {
      var modelKey = modelKeys[count];
      model[modelKey].set(map[modelKey]);
    }
  }

  var modelKeys = Object.keys(defaults);
  var count = modelKeys.length;

  var _loop2 = function _loop2() {
    // Add default
    var key = modelKeys[count];
    model[key] = defaults[key]; // Add set method

    var mapping = state[key];

    publicAPI["set".concat(_capitalize(key))] = function (value) {
      if (value !== model[key]) {
        model[key] = value;
        var propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  };

  while (count--) {
    _loop2();
  } // Add getter


  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
} // ----------------------------------------------------------------------------
// From : https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
//
//
// Copyright (c) 2015, Facebook, Inc.
// All rights reserved.
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree. An additional grant
// of patent rights can be found in the PATENTS file in the same directory.
//
//
// Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
// complicated, thus this doc is long and (hopefully) detailed enough to answer
// your questions.
//
// If you need to react to the mouse wheel in a predictable way, this code is
// like your bestest friend.// hugs//
//
// As of today, there are 4 DOM event types you can listen to:
//
//   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
//   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
//   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
//   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
//
// So what to do?  The is the best:
//
//   normalizeWheel.getEventType();
//
// In your event callback, use this code to get sane interpretation of the
// deltas.  This code will return an object with properties:
//
//   spinX   -- normalized spin speed (use for zoom) - x plane
//   spinY   -- " - y plane
//   pixelX  -- normalized distance (to pixels) - x plane
//   pixelY  -- " - y plane
//
// Wheel values are provided by the browser assuming you are using the wheel to
// scroll a web page by a number of lines or pixels (or pages).  Values can vary
// significantly on different platforms and browsers, forgetting that you can
// scroll at different speeds.  Some devices (like trackpads) emit more events
// at smaller increments with fine granularity, and some emit massive jumps with
// linear speed or acceleration.
//
// This code does its best to normalize the deltas for you:
//
//   - spin is trying to normalize how far the wheel was spun (or trackpad
//     dragged).  This is super useful for zoom support where you want to
//     throw away the chunky scroll steps on the PC and make those equal to
//     the slow and smooth tiny steps on the Mac. Key data: This code tries to
//     resolve a single slow step on a wheel to 1.
//
//   - pixel is normalizing the desired scroll delta in pixel units.  You'll
//     get the crazy differences between browsers, but at least it'll be in
//     pixels!
//
//   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
//     should translate to positive value zooming IN, negative zooming OUT.
//     This matches the newer 'wheel' event.
//
// Why are there spinX, spinY (or pixels)?
//
//   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
//     with a mouse.  It results in side-scrolling in the browser by default.
//
//   - spinY is what you expect -- it's the classic axis of a mouse wheel.
//
//   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
//     probably is by browsers in conjunction with fancy 3D controllers .. but
//     you know.
//
// Implementation info:
//
// Examples of 'wheel' event if you scroll slowly (down) by one step with an
// average mouse:
//
//   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
//   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
//   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
//   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
//   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
//
// On the trackpad:
//
//   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
//   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
//
// On other/older browsers.. it's more complicated as there can be multiple and
// also missing delta values.
//
// The 'wheel' event is more standard:
//
// http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
//
// The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
// deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
// backward compatibility with older events.  Those other values help us
// better normalize spin speed.  Example of what the browsers provide:
//
//                          | event.wheelDelta | event.detail
//        ------------------+------------------+--------------
//          Safari v5/OS X  |       -120       |       0
//          Safari v5/Win7  |       -120       |       0
//         Chrome v17/OS X  |       -120       |       0
//         Chrome v17/Win7  |       -120       |       0
//                IE9/Win7  |       -120       |   undefined
//         Firefox v4/OS X  |     undefined    |       1
//         Firefox v4/Win7  |     undefined    |       3
//
// ----------------------------------------------------------------------------
// Reasonable defaults

var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function normalizeWheel(wheelEvent) {
  var sX = 0; // spinX

  var sY = 0; // spinY

  var pX = 0; // pixelX

  var pY = 0; // pixelY
  // Legacy

  if ('detail' in wheelEvent) {
    sY = wheelEvent.detail;
  }

  if ('wheelDelta' in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }

  if ('wheelDeltaY' in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }

  if ('wheelDeltaX' in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  } // side scrolling on FF with DOMMouseScroll


  if ('axis' in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in wheelEvent) {
    pY = wheelEvent.deltaY;
  }

  if ('deltaX' in wheelEvent) {
    pX = wheelEvent.deltaX;
  }

  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  } // Fall-back if spin cannot be determined


  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }

  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }

  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
} // ----------------------------------------------------------------------------
// Default export
// ----------------------------------------------------------------------------

var macro = {
  algo: algo,
  capitalize: capitalize,
  chain: chain,
  debounce: debounce,
  enumToString: enumToString,
  event: event,
  EVENT_ABORT: EVENT_ABORT,
  formatBytesToProperUnit: formatBytesToProperUnit,
  formatNumbersWithThousandSeparator: formatNumbersWithThousandSeparator,
  get: get,
  getArray: getArray,
  getCurrentGlobalMTime: getCurrentGlobalMTime,
  getStateArrayMapFunc: getStateArrayMapFunc,
  isVtkObject: isVtkObject,
  keystore: keystore,
  measurePromiseExecution: measurePromiseExecution,
  moveToProtected: moveToProtected,
  newInstance: newInstance,
  newTypedArray: newTypedArray,
  newTypedArrayFrom: newTypedArrayFrom,
  normalizeWheel: normalizeWheel,
  obj: obj,
  proxy: proxy,
  proxyPropertyMapping: proxyPropertyMapping,
  proxyPropertyState: proxyPropertyState,
  safeArrays: safeArrays,
  set: set,
  setArray: setArray,
  setGet: setGet,
  setGetArray: setGetArray,
  setImmediate: setImmediateVTK,
  setLoggerFunction: setLoggerFunction,
  throttle: throttle,
  traverseInstanceTree: traverseInstanceTree,
  TYPED_ARRAYS: TYPED_ARRAYS,
  // deprecated todo remove on breaking API revision
  uncapitalize: uncapitalize,
  VOID: VOID,
  vtkDebugMacro: vtkDebugMacro,
  vtkErrorMacro: vtkErrorMacro,
  vtkInfoMacro: vtkInfoMacro,
  vtkLogMacro: vtkLogMacro,
  vtkOnceErrorMacro: vtkOnceErrorMacro,
  vtkWarningMacro: vtkWarningMacro
};




/***/ }),

/***/ "../../../node_modules/@kitware/vtk.js/vtk.js":
/*!****************************************************!*\
  !*** ../../../node_modules/@kitware/vtk.js/vtk.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ vtk),
/* harmony export */   vtkGlobal: () => (/* binding */ vtkGlobal)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "../../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var globalthis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! globalthis */ "../../../node_modules/globalthis/index.js");
/* harmony import */ var globalthis__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(globalthis__WEBPACK_IMPORTED_MODULE_2__);




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var vtkGlobal = globalthis__WEBPACK_IMPORTED_MODULE_2___default()(); // returns native globalThis if compliant

var factoryMapping = {
  vtkObject: function vtkObject() {
    return null;
  }
};
function vtk(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }

  if (obj.isA) {
    return obj;
  }

  if (!obj.vtkClass) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error('Invalid VTK object');
    }

    return null;
  }

  var constructor = factoryMapping[obj.vtkClass];

  if (!constructor) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error("No vtk class found for Object of type ".concat(obj.vtkClass));
    }

    return null;
  } // Shallow copy object


  var model = _objectSpread({}, obj); // Convert into vtkObject any nested key


  Object.keys(model).forEach(function (keyName) {
    if (model[keyName] && (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(model[keyName]) === 'object' && model[keyName].vtkClass) {
      model[keyName] = vtk(model[keyName]);
    }
  }); // Return the root

  var newInst = constructor(model);

  if (newInst && newInst.modified) {
    newInst.modified();
  }

  return newInst;
}

function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
} // Nest register method under the vtk function


vtk.register = register;




/***/ }),

/***/ "../../../node_modules/globalthis/implementation.browser.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/globalthis/implementation.browser.js ***!
  \******************************************************************/
/***/ ((module) => {

/* eslint no-negated-condition: 0, no-new-func: 0 */



if (typeof self !== 'undefined') {
	module.exports = self;
} else if (typeof window !== 'undefined') {
	module.exports = window;
} else {
	module.exports = Function('return this')();
}


/***/ }),

/***/ "../../../node_modules/globalthis/index.js":
/*!*************************************************!*\
  !*** ../../../node_modules/globalthis/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var defineProperties = __webpack_require__(/*! define-properties */ "../../../node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "../../../node_modules/globalthis/implementation.browser.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "../../../node_modules/globalthis/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "../../../node_modules/globalthis/shim.js");

var polyfill = getPolyfill();

var getGlobal = function () { return polyfill; };

defineProperties(getGlobal, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = getGlobal;


/***/ }),

/***/ "../../../node_modules/globalthis/polyfill.js":
/*!****************************************************!*\
  !*** ../../../node_modules/globalthis/polyfill.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var implementation = __webpack_require__(/*! ./implementation */ "../../../node_modules/globalthis/implementation.browser.js");

module.exports = function getPolyfill() {
	if (typeof __webpack_require__.g !== 'object' || !__webpack_require__.g || __webpack_require__.g.Math !== Math || __webpack_require__.g.Array !== Array) {
		return implementation;
	}
	return __webpack_require__.g;
};


/***/ }),

/***/ "../../../node_modules/globalthis/shim.js":
/*!************************************************!*\
  !*** ../../../node_modules/globalthis/shim.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var define = __webpack_require__(/*! define-properties */ "../../../node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "../../../node_modules/globalthis/polyfill.js");

module.exports = function shimGlobal() {
	var polyfill = getPolyfill();
	if (define.supportsDescriptors) {
		var descriptor = Object.getOwnPropertyDescriptor(polyfill, 'globalThis');
		if (!descriptor || (descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill))) { // eslint-disable-line max-len
			Object.defineProperty(polyfill, 'globalThis', {
				configurable: true,
				enumerable: false,
				value: polyfill,
				writable: true
			});
		}
	} else if (typeof globalThis !== 'object' || globalThis !== polyfill) {
		polyfill.globalThis = polyfill;
	}
	return polyfill;
};


/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/construct.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/construct.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _construct)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");
/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ "../../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js");


function _construct(Parent, args, Class) {
  if ((0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__["default"])()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}

/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/get.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/get.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _get)
/* harmony export */ });
/* harmony import */ var _superPropBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./superPropBase.js */ "../../../node_modules/@babel/runtime/helpers/esm/superPropBase.js");

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = (0,_superPropBase_js__WEBPACK_IMPORTED_MODULE_0__["default"])(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}

/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _isNativeFunction)
/* harmony export */ });
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js":
/*!************************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _isNativeReflectConstruct)
/* harmony export */ });
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/superPropBase.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/superPropBase.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _superPropBase)
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ "../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
    if (object === null) break;
  }
  return object;
}

/***/ }),

/***/ "../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _wrapNativeSuper)
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ "../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf.js */ "../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");
/* harmony import */ var _isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction.js */ "../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js");
/* harmony import */ var _construct_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct.js */ "../../../node_modules/@babel/runtime/helpers/esm/construct.js");




function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !(0,_isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return (0,_construct_js__WEBPACK_IMPORTED_MODULE_3__["default"])(Class, arguments, (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_kitware_vtk_js_Common_Core_Math_js.js.map