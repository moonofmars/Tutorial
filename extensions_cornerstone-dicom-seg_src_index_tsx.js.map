{"version":3,"file":"extensions_cornerstone-dicom-seg_src_index_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3EA;AAiEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnEA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AAEA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAKA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAIA;AAMA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3SA;AAAA;AAEA;AAEA;AAEA;AA0FA;AA8CA;AAwBA;AAOA;AAyBA;AAmDA;AAgCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AChSA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAHA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAIA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjFA;AAMA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAFA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AAIA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AAIA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAOA;AAOA;AAOA;AAOA;AAOA;AAOA;AAMA;AAKA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlRA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ACHA","sources":["file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/id.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/index.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/panels/PanelSegmentation.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/panels/callInputDialog.tsx","file:///ignored%7C/Users/smartxx/xV/DICOM/Viewers/node_modules/seedrandom%7Ccrypto"],"sourcesContent":["import { Types } from '@ohif/core';\n\nconst segProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/seg',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  hasUpdatedPriorsInformation: false,\n  name: 'Segmentations',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'segDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    segDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SEG',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'Segmentations',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: { allowUnmatchedView: true },\n          displaySets: [\n            {\n              id: 'segDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: segProtocol.id,\n      protocol: segProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { segProtocol };\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\n\nimport { utils } from '@ohif/core';\n\nimport { SOPClassHandlerId } from './id';\nimport dcmjs from 'dcmjs';\n\nconst { DicomMessage, DicomMetaDictionary } = dcmjs.data;\n\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\n\nlet loadPromises = {};\n\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager,\n  extensionManager\n) {\n  const instance = instances[0];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPClassUID,\n    wadoRoot,\n    wadoUri,\n    wadoUriRoot,\n  } = instance;\n\n  const displaySet = {\n    Modality: 'SEG',\n    loading: false,\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    referencedImages: null,\n    referencedSeriesInstanceUID: null,\n    referencedDisplaySetInstanceUID: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    isHydrated: false,\n    segments: {},\n    sopClassUids,\n    instance,\n    instances: [instance],\n    wadoRoot,\n    wadoUriRoot,\n    wadoUri,\n    isOverlayDisplaySet: true,\n  };\n\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\n\n  if (!referencedSeriesSequence) {\n    throw new Error('ReferencedSeriesSequence is missing for the SEG');\n  }\n\n  const referencedSeries = referencedSeriesSequence[0];\n\n  displaySet.referencedImages =\n    instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\n\n  displaySet.getReferenceDisplaySet = () => {\n    const { displaySetService } = servicesManager.services;\n    const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\n      displaySet.referencedSeriesInstanceUID\n    );\n\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\n      throw new Error('Referenced DisplaySet is missing for the SEG');\n    }\n\n    const referencedDisplaySet = referencedDisplaySets[0];\n\n    displaySet.referencedDisplaySetInstanceUID =\n      referencedDisplaySet.displaySetInstanceUID;\n\n    // Todo: this needs to be able to work with other reference volumes (other than streaming) such as nifti, etc.\n    displaySet.referencedVolumeURI = referencedDisplaySet.displaySetInstanceUID;\n    const referencedVolumeId = `cornerstoneStreamingImageVolume:${displaySet.referencedVolumeURI}`;\n    displaySet.referencedVolumeId = referencedVolumeId;\n\n    return referencedDisplaySet;\n  };\n\n  displaySet.load = async ({ headers }) =>\n    await _load(displaySet, servicesManager, extensionManager, headers);\n\n  return [displaySet];\n}\n\nfunction _load(segDisplaySet, servicesManager, extensionManager, headers) {\n  const { SOPInstanceUID } = segDisplaySet;\n  const { segmentationService } = servicesManager.services;\n\n  if (\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\n    loadPromises[SOPInstanceUID] &&\n    _segmentationExists(segDisplaySet, segmentationService)\n  ) {\n    return loadPromises[SOPInstanceUID];\n  }\n\n  segDisplaySet.loading = true;\n\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\n  // and also return the same promise to any other callers.\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\n    if (\n      !segDisplaySet.segments ||\n      Object.keys(segDisplaySet.segments).length === 0\n    ) {\n      const segments = await _loadSegments(\n        extensionManager,\n        segDisplaySet,\n        headers\n      );\n\n      segDisplaySet.segments = segments;\n    }\n\n    const suppressEvents = true;\n    segmentationService\n      .createSegmentationForSEGDisplaySet(segDisplaySet, null, suppressEvents)\n      .then(() => {\n        segDisplaySet.loading = false;\n        resolve();\n      })\n      .catch(error => {\n        segDisplaySet.loading = false;\n        reject(error);\n      });\n  });\n\n  return loadPromises[SOPInstanceUID];\n}\n\nasync function _loadSegments(extensionManager, segDisplaySet, headers) {\n  const utilityModule = extensionManager.getModuleEntry(\n    '@ohif/extension-cornerstone.utilityModule.common'\n  );\n\n  const { dicomLoaderService } = utilityModule.exports;\n  const segArrayBuffer = await dicomLoaderService.findDicomDataPromise(\n    segDisplaySet,\n    null,\n    headers\n  );\n\n  const dicomData = DicomMessage.readFile(segArrayBuffer);\n  const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n  dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n  if (!Array.isArray(dataset.SegmentSequence)) {\n    dataset.SegmentSequence = [dataset.SegmentSequence];\n  }\n\n  const segments = _getSegments(dataset);\n  return segments;\n}\n\nfunction _segmentationExists(segDisplaySet, segmentationService) {\n  // This should be abstracted with the CornerstoneCacheService\n  return segmentationService.getSegmentation(\n    segDisplaySet.displaySetInstanceUID\n  );\n}\n\nfunction _getPixelData(dataset, segments) {\n  let frameSize = Math.ceil((dataset.Rows * dataset.Columns) / 8);\n  let nextOffset = 0;\n\n  Object.keys(segments).forEach(segmentKey => {\n    const segment = segments[segmentKey];\n    segment.numberOfFrames = segment.functionalGroups.length;\n    segment.size = segment.numberOfFrames * frameSize;\n    segment.offset = nextOffset;\n    nextOffset = segment.offset + segment.size;\n    const packedSegment = dataset.PixelData[0].slice(\n      segment.offset,\n      nextOffset\n    );\n\n    segment.pixelData = dcmjs.data.BitArray.unpack(packedSegment);\n    segment.geometry = geometryFromFunctionalGroups(\n      dataset,\n      segment.functionalGroups\n    );\n  });\n\n  return segments;\n}\n\nfunction geometryFromFunctionalGroups(dataset, perFrame) {\n  let pixelMeasures =\n    dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n  let planeOrientation =\n    dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n  let planePosition = perFrame[0].PlanePositionSequence; // TODO: assume sorted frames!\n\n  const geometry = {};\n\n  // NB: DICOM PixelSpacing is defined as Row then Column,\n  // unlike ImageOrientationPatient\n  let spacingBetweenSlices = pixelMeasures.SpacingBetweenSlices;\n  if (!spacingBetweenSlices) {\n    if (pixelMeasures.SliceThickness) {\n      console.log('Using SliceThickness as SpacingBetweenSlices');\n      spacingBetweenSlices = pixelMeasures.SliceThickness;\n    }\n  }\n  geometry.spacing = [\n    pixelMeasures.PixelSpacing[1],\n    pixelMeasures.PixelSpacing[0],\n    spacingBetweenSlices,\n  ].map(Number);\n\n  geometry.dimensions = [dataset.Columns, dataset.Rows, perFrame.length].map(\n    Number\n  );\n\n  let orientation = planeOrientation.ImageOrientationPatient.map(Number);\n  const columnStepToPatient = orientation.slice(0, 3);\n  const rowStepToPatient = orientation.slice(3, 6);\n  geometry.planeNormal = [];\n  vtkMath.cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n\n  let firstPosition = perFrame[0].PlanePositionSequence.ImagePositionPatient.map(\n    Number\n  );\n  let lastPosition = perFrame[\n    perFrame.length - 1\n  ].PlanePositionSequence.ImagePositionPatient.map(Number);\n  geometry.sliceStep = [];\n  vtkMath.subtract(lastPosition, firstPosition, geometry.sliceStep);\n  vtkMath.normalize(geometry.sliceStep);\n  geometry.direction = columnStepToPatient\n    .concat(rowStepToPatient)\n    .concat(geometry.sliceStep);\n  geometry.origin = planePosition.ImagePositionPatient.map(Number);\n\n  return geometry;\n}\n\nfunction _getSegments(dataset) {\n  const segments = {};\n\n  dataset.SegmentSequence.forEach(segment => {\n    const cielab = segment.RecommendedDisplayCIELabValue;\n    const rgba = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x =>\n      Math.round(x * 255)\n    );\n\n    rgba.push(255);\n    const segmentNumber = segment.SegmentNumber;\n\n    segments[segmentNumber] = {\n      color: rgba,\n      functionalGroups: [],\n      offset: null,\n      size: null,\n      pixelData: null,\n      label: segment.SegmentLabel,\n    };\n  });\n\n  // make a list of functional groups per segment\n  dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n    const segmentNumber =\n      functionalGroup.SegmentIdentificationSequence.ReferencedSegmentNumber;\n    segments[segmentNumber].functionalGroups.push(functionalGroup);\n  });\n\n  return _getPixelData(dataset, segments);\n}\n\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(\n      instances,\n      servicesManager,\n      extensionManager\n    );\n  };\n\n  return [\n    {\n      name: 'dicom-seg',\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nexport default getSopClassHandlerModule;\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\nconst SOPClassHandlerName = 'dicom-seg';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\n","import { id } from './id';\nimport React from 'react';\n\nimport { Types } from '@ohif/core';\n\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport PanelSegmentation from './panels/PanelSegmentation';\nimport getHangingProtocolModule from './getHangingProtocolModule';\n\nconst Component = React.lazy(() => {\n  return import(\n    /* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport'\n  );\n});\n\nconst OHIFCornerstoneSEGViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n * You can remove any of the following modules if you don't need them.\n */\nconst extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   * You ID can be anything you want, but it should be unique.\n   */\n  id,\n\n  /**\n   * PanelModule should provide a list of panels that will be available in OHIF\n   * for Modes to consume and render. Each panel is defined by a {name,\n   * iconName, iconLabel, label, component} object. Example of a panel module\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\n   */\n  getPanelModule: ({\n    servicesManager,\n    commandsManager,\n    extensionManager,\n  }): Types.Panel[] => {\n    const wrappedPanelSegmentation = () => {\n      return (\n        <PanelSegmentation\n          commandsManager={commandsManager}\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n        />\n      );\n    };\n\n    return [\n      {\n        name: 'panelSegmentation',\n        iconName: 'tab-segmentation',\n        iconLabel: 'Segmentation',\n        label: 'Segmentation',\n        component: wrappedPanelSegmentation,\n      },\n    ];\n  },\n\n  getViewportModule({ servicesManager, extensionManager }) {\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\n      return (\n        <OHIFCornerstoneSEGViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          {...props}\n        />\n      );\n    };\n\n    return [\n      { name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport },\n    ];\n  },\n  /**\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\n   * Examples include the default sop class handler provided by the default extension\n   */\n  getSopClassHandlerModule,\n  getHangingProtocolModule,\n};\n\nexport default extension;","import React, { useEffect, useState, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { SegmentationGroupTable } from '@ohif/ui';\nimport callInputDialog from './callInputDialog';\n\nimport { useTranslation } from 'react-i18next';\n\nexport default function PanelSegmentation({\n  servicesManager,\n  commandsManager,\n}) {\n  const { segmentationService, uiDialogService } = servicesManager.services;\n\n  const { t } = useTranslation('PanelSegmentation');\n  const [selectedSegmentationId, setSelectedSegmentationId] = useState(null);\n  const [segmentationConfiguration, setSegmentationConfiguration] = useState(\n    segmentationService.getConfiguration()\n  );\n\n  const [segmentations, setSegmentations] = useState(() =>\n    segmentationService.getSegmentations()\n  );\n\n  const [isMinimized, setIsMinimized] = useState({});\n\n  const onToggleMinimizeSegmentation = useCallback(\n    id => {\n      setIsMinimized(prevState => ({\n        ...prevState,\n        [id]: !prevState[id],\n      }));\n    },\n    [setIsMinimized]\n  );\n\n  // Only expand the last segmentation added to the list and collapse the rest\n  useEffect(() => {\n    const lastSegmentationId = segmentations[segmentations.length - 1]?.id;\n    if (lastSegmentationId) {\n      setIsMinimized(prevState => ({\n        ...prevState,\n        [lastSegmentationId]: false,\n      }));\n    }\n  }, [segmentations, setIsMinimized]);\n\n  useEffect(() => {\n    // ~~ Subscription\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\n    const subscriptions = [];\n\n    [added, updated, removed].forEach(evt => {\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\n        const segmentations = segmentationService.getSegmentations();\n        setSegmentations(segmentations);\n        setSegmentationConfiguration(segmentationService.getConfiguration());\n      });\n      subscriptions.push(unsubscribe);\n    });\n\n    return () => {\n      subscriptions.forEach(unsub => {\n        unsub();\n      });\n    };\n  }, []);\n\n  const onSegmentationClick = (segmentationId: string) => {\n    segmentationService.setActiveSegmentationForToolGroup(segmentationId);\n  };\n\n  const onSegmentationDelete = (segmentationId: string) => {\n    segmentationService.remove(segmentationId);\n  };\n\n  const getToolGroupIds = segmentationId => {\n    const toolGroupIds = segmentationService.getToolGroupIdsWithSegmentation(\n      segmentationId\n    );\n\n    return toolGroupIds;\n  };\n\n  const onSegmentClick = (segmentationId, segmentIndex) => {\n    segmentationService.setActiveSegmentForSegmentation(\n      segmentationId,\n      segmentIndex\n    );\n\n    const toolGroupIds = getToolGroupIds(segmentationId);\n\n    toolGroupIds.forEach(toolGroupId => {\n      // const toolGroupId =\n      segmentationService.setActiveSegmentationForToolGroup(\n        segmentationId,\n        toolGroupId\n      );\n      segmentationService.jumpToSegmentCenter(\n        segmentationId,\n        segmentIndex,\n        toolGroupId\n      );\n    });\n  };\n\n  const onSegmentEdit = (segmentationId, segmentIndex) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n\n    const segment = segmentation.segments[segmentIndex];\n    const { label } = segment;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.setSegmentLabelForSegmentation(\n        segmentationId,\n        segmentIndex,\n        label\n      );\n    });\n  };\n\n  const onSegmentationEdit = segmentationId => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const { label } = segmentation;\n\n    callInputDialog(uiDialogService, label, (label, actionId) => {\n      if (label === '') {\n        return;\n      }\n\n      segmentationService.addOrUpdateSegmentation(\n        {\n          id: segmentationId,\n          label,\n        },\n        false, // suppress event\n        true // notYetUpdatedAtSource\n      );\n    });\n  };\n\n  const onSegmentColorClick = (segmentationId, segmentIndex) => {\n    // Todo: Implement color picker later\n    return;\n  };\n\n  const onSegmentDelete = (segmentationId, segmentIndex) => {\n    // segmentationService.removeSegmentFromSegmentation(\n    //   segmentationId,\n    //   segmentIndex\n    // );\n    console.warn('not implemented yet');\n  };\n\n  const onToggleSegmentVisibility = (segmentationId, segmentIndex) => {\n    const segmentation = segmentationService.getSegmentation(segmentationId);\n    const segmentInfo = segmentation.segments[segmentIndex];\n    const isVisible = !segmentInfo.isVisible;\n    const toolGroupIds = getToolGroupIds(segmentationId);\n\n    // Todo: right now we apply the visibility to all tool groups\n    toolGroupIds.forEach(toolGroupId => {\n      segmentationService.setSegmentVisibility(\n        segmentationId,\n        segmentIndex,\n        isVisible,\n        toolGroupId\n      );\n    });\n  };\n\n  const onToggleSegmentationVisibility = segmentationId => {\n    segmentationService.toggleSegmentationVisibility(segmentationId);\n  };\n\n  const _setSegmentationConfiguration = useCallback(\n    (segmentationId, key, value) => {\n      segmentationService.setConfiguration({\n        segmentationId,\n        [key]: value,\n      });\n    },\n    [segmentationService]\n  );\n\n  return (\n    <div className=\"flex flex-col flex-auto min-h-0 justify-between mt-1\">\n      {/* show segmentation table */}\n      {segmentations?.length ? (\n        <SegmentationGroupTable\n          title={t('Segmentations')}\n          showAddSegmentation={false}\n          segmentations={segmentations}\n          isMinimized={isMinimized}\n          activeSegmentationId={selectedSegmentationId || ''}\n          onSegmentationClick={onSegmentationClick}\n          onSegmentationDelete={onSegmentationDelete}\n          onSegmentationEdit={onSegmentationEdit}\n          onSegmentClick={onSegmentClick}\n          onSegmentEdit={onSegmentEdit}\n          onSegmentColorClick={onSegmentColorClick}\n          onSegmentDelete={onSegmentDelete}\n          onToggleSegmentVisibility={onToggleSegmentVisibility}\n          onToggleSegmentationVisibility={onToggleSegmentationVisibility}\n          onToggleMinimizeSegmentation={onToggleMinimizeSegmentation}\n          segmentationConfig={{ initialConfig: segmentationConfiguration }}\n          setRenderOutline={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'renderOutline',\n              value\n            )\n          }\n          setOutlineOpacityActive={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'outlineOpacity',\n              value\n            )\n          }\n          setRenderFill={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'renderFill',\n              value\n            )\n          }\n          setRenderInactiveSegmentations={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'renderInactiveSegmentations',\n              value\n            )\n          }\n          setOutlineWidthActive={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'outlineWidthActive',\n              value\n            )\n          }\n          setFillAlpha={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'fillAlpha',\n              value\n            )\n          }\n          setFillAlphaInactive={value =>\n            _setSegmentationConfiguration(\n              selectedSegmentationId,\n              'fillAlphaInactive',\n              value\n            )\n          }\n        />\n      ) : null}\n    </div>\n  );\n}\n\nPanelSegmentation.propTypes = {\n  commandsManager: PropTypes.shape({\n    runCommand: PropTypes.func.isRequired,\n  }),\n  servicesManager: PropTypes.shape({\n    services: PropTypes.shape({\n      segmentationService: PropTypes.shape({\n        getSegmentation: PropTypes.func.isRequired,\n        getSegmentations: PropTypes.func.isRequired,\n        toggleSegmentationVisibility: PropTypes.func.isRequired,\n        subscribe: PropTypes.func.isRequired,\n        EVENTS: PropTypes.object.isRequired,\n      }).isRequired,\n    }).isRequired,\n  }).isRequired,\n};\n","import React from 'react';\nimport { Input, Dialog } from '@ohif/ui';\n\nfunction callInputDialog(uiDialogService, label, callback) {\n  const dialogId = 'enter-segment-label';\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        callback(value.label, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: 'Segment',\n        value: { label },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\n          { id: 'save', text: 'Confirm', type: 'secondary' },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          return (\n            <Input\n              label=\"Enter the segment label\"\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\n              autoFocus\n              className=\"bg-black border-primary-main\"\n              type=\"text\"\n              value={value.label}\n              onChange={event => {\n                event.persist();\n                setValue(value => ({ ...value, label: event.target.value }));\n              }}\n              onKeyPress={event => {\n                if (event.key === 'Enter') {\n                  onSubmitHandler({ value, action: { id: 'save' } });\n                }\n              }}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callInputDialog;\n","/* (ignored) */"],"names":[],"sourceRoot":""}