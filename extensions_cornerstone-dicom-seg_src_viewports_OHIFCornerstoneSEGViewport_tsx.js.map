{"version":3,"file":"extensions_cornerstone-dicom-seg_src_viewports_OHIFCornerstoneSEGViewport_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAIA;AAHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAEA;AAMA;AAEA;AAAA;AAAA;AAEA;;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;ACAA;AAKA;AAAA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAHA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjEA;AAMA;AAyBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAGA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAMA;AAEA;AACA;AACA;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAGA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAQA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApYA;AACA;AAEA;AA8WA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AC/XA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAIA;AACA;AAAA;AACA;AAAA;AASA;AAGA;AAAA;AAAA;AAOA;AAAA;AA9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA","sources":["file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/utils/_hydrateSEG.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/utils/initSEGToolGroup.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/utils/promptHydrateSEG.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/viewports/OHIFCornerstoneSEGViewport.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone-dicom-seg/src/viewports/_getStatusComponent.tsx"],"sourcesContent":["async function _hydrateSEGDisplaySet({\n  segDisplaySet,\n  viewportIndex,\n  servicesManager,\n}) {\n  const {\n    segmentationService,\n    hangingProtocolService,\n    viewportGridService,\n  } = servicesManager.services;\n\n  const displaySetInstanceUID = segDisplaySet.referencedDisplaySetInstanceUID;\n\n  let segmentationId = null;\n\n  // We need the hydration to notify panels about the new segmentation added\n  const suppressEvents = false;\n\n  segmentationId = await segmentationService.createSegmentationForSEGDisplaySet(\n    segDisplaySet,\n    segmentationId,\n    suppressEvents\n  );\n\n  segmentationService.hydrateSegmentation(segDisplaySet.displaySetInstanceUID);\n\n  const { viewports } = viewportGridService.getState();\n\n  const updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\n    viewportIndex,\n    displaySetInstanceUID\n  );\n\n  // Todo: fix this after we have a better way for stack viewport segmentations\n\n  // check every viewport in the viewports to see if the displaySetInstanceUID\n  // is being displayed, if so we need to update the viewport to use volume viewport\n  // (if already is not using it) since Cornerstone3D currently only supports\n  // volume viewport for segmentation\n  viewports.forEach((viewport, index) => {\n    if (index === viewportIndex) {\n      return;\n    }\n\n    const shouldDisplaySeg = segmentationService.shouldRenderSegmentation(\n      viewport.displaySetInstanceUIDs,\n      segDisplaySet.displaySetInstanceUID\n    );\n\n    if (shouldDisplaySeg) {\n      updatedViewports.push({\n        viewportIndex: index,\n        displaySetInstanceUIDs: viewport.displaySetInstanceUIDs,\n        viewportOptions: {\n          initialImageOptions: {\n            preset: 'middle',\n          },\n        },\n      });\n    }\n  });\n\n  // Do the entire update at once\n  viewportGridService.setDisplaySetsForViewports(updatedViewports);\n\n  return true;\n}\n\nexport default _hydrateSEGDisplaySet;\n","function createSEGToolGroupAndAddTools(\n  ToolGroupService,\n  customizationService,\n  toolGroupId\n) {\n  const { tools } =\n    customizationService.get('cornerstone.overlayViewportTools') ?? {};\n\n  return ToolGroupService.createToolGroupAndAddTools(toolGroupId, tools, {});\n}\n\nexport default createSEGToolGroupAndAddTools;\n","import hydrateSEGDisplaySet from './_hydrateSEG';\n\nconst RESPONSE = {\n  NO_NEVER: -1,\n  CANCEL: 0,\n  HYDRATE_SEG: 5,\n};\n\nfunction promptHydrateSEG({\n  servicesManager,\n  segDisplaySet,\n  viewportIndex,\n}) {\n  const { uiViewportDialogService } = servicesManager.services;\n\n  return new Promise(async function(resolve, reject) {\n    const promptResult = await _askHydrate(\n      uiViewportDialogService,\n      viewportIndex\n    );\n\n    if (promptResult === RESPONSE.HYDRATE_SEG) {\n      const isHydrated = await hydrateSEGDisplaySet({\n        segDisplaySet,\n        viewportIndex,\n        servicesManager,\n      });\n\n      resolve(isHydrated);\n    }\n  });\n}\n\nfunction _askHydrate(uiViewportDialogService, viewportIndex) {\n  return new Promise(function(resolve, reject) {\n    const message = 'Do you want to open this Segmentation?';\n    const actions = [\n      {\n        type: 'secondary',\n        text: 'No',\n        value: RESPONSE.CANCEL,\n      },\n      {\n        type: 'primary',\n        text: 'Yes',\n        value: RESPONSE.HYDRATE_SEG,\n      },\n    ];\n    const onSubmit = result => {\n      uiViewportDialogService.hide();\n      resolve(result);\n    };\n\n    uiViewportDialogService.show({\n      viewportIndex,\n      type: 'info',\n      message,\n      actions,\n      onSubmit,\n      onOutsideClick: () => {\n        uiViewportDialogService.hide();\n        resolve(RESPONSE.CANCEL);\n      },\n    });\n  });\n}\n\nexport default promptHydrateSEG;\n","import PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport OHIF, { utils } from '@ohif/core';\nimport {\n  LoadingIndicatorTotalPercent,\n  useViewportGrid,\n  ViewportActionBar,\n} from '@ohif/ui';\nimport createSEGToolGroupAndAddTools from '../utils/initSEGToolGroup';\nimport promptHydrateSEG from '../utils/promptHydrateSEG';\nimport hydrateSEGDisplaySet from '../utils/_hydrateSEG';\nimport _getStatusComponent from './_getStatusComponent';\n\nconst { formatDate } = utils;\nconst SEG_TOOLGROUP_BASE_NAME = 'SEGToolGroup';\n\nfunction OHIFCornerstoneSEGViewport(props) {\n  const {\n    children,\n    displaySets,\n    viewportOptions,\n    viewportIndex,\n    viewportLabel,\n    servicesManager,\n    extensionManager,\n  } = props;\n\n  const { t } = useTranslation('SEGViewport');\n\n  const {\n    displaySetService,\n    toolGroupService,\n    segmentationService,\n    uiNotificationService,\n    customizationService,\n  } = servicesManager.services;\n\n  const toolGroupId = `${SEG_TOOLGROUP_BASE_NAME}-${viewportIndex}`;\n\n  // SEG viewport will always have a single display set\n  if (displaySets.length > 1) {\n    throw new Error('SEG viewport should only have a single display set');\n  }\n\n  const segDisplaySet = displaySets[0];\n\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n\n  // States\n  const [isToolGroupCreated, setToolGroupCreated] = useState(false);\n  const [selectedSegment, setSelectedSegment] = useState(1);\n\n  // Hydration means that the SEG is opened and segments are loaded into the\n  // segmentation panel, and SEG is also rendered on any viewport that is in the\n  // same frameOfReferenceUID as the referencedSeriesUID of the SEG. However,\n  // loading basically means SEG loading over network and bit unpacking of the\n  // SEG data.\n  const [isHydrated, setIsHydrated] = useState(segDisplaySet.isHydrated);\n  const [segIsLoading, setSegIsLoading] = useState(!segDisplaySet.isLoaded);\n  const [element, setElement] = useState(null);\n  const [processingProgress, setProcessingProgress] = useState({\n    percentComplete: null,\n    totalSegments: null,\n  });\n\n  // refs\n  const referencedDisplaySetRef = useRef(null);\n\n  const { viewports, activeViewportIndex } = viewportGrid;\n\n  const referencedDisplaySet = segDisplaySet.getReferenceDisplaySet();\n  const referencedDisplaySetMetadata = _getReferencedDisplaySetMetadata(\n    referencedDisplaySet\n  );\n\n  referencedDisplaySetRef.current = {\n    displaySet: referencedDisplaySet,\n    metadata: referencedDisplaySetMetadata,\n  };\n  /**\n   * OnElementEnabled callback which is called after the cornerstoneExtension\n   * has enabled the element. Note: we delegate all the image rendering to\n   * cornerstoneExtension, so we don't need to do anything here regarding\n   * the image rendering, element enabling etc.\n   */\n  const onElementEnabled = evt => {\n    setElement(evt.detail.element);\n  };\n\n  const onElementDisabled = () => {\n    setElement(null);\n  };\n\n  const getCornerstoneViewport = useCallback(() => {\n    const { component: Component } = extensionManager.getModuleEntry(\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\n    );\n\n    const {\n      displaySet: referencedDisplaySet,\n    } = referencedDisplaySetRef.current;\n\n    // Todo: jump to the center of the first segment\n    return (\n      <Component\n        {...props}\n        displaySets={[referencedDisplaySet, segDisplaySet]}\n        viewportOptions={{\n          viewportType: 'volume',\n          toolGroupId: toolGroupId,\n          orientation: viewportOptions.orientation,\n          viewportId: viewportOptions.viewportId,\n        }}\n        onElementEnabled={onElementEnabled}\n        onElementDisabled={onElementDisabled}\n        // initialImageIndex={initialImageIndex}\n      ></Component>\n    );\n  }, [viewportIndex, segDisplaySet, toolGroupId]);\n\n  const onSegmentChange = useCallback(\n    direction => {\n      direction = direction === 'left' ? -1 : 1;\n      const segmentationId = segDisplaySet.displaySetInstanceUID;\n      const segmentation = segmentationService.getSegmentation(segmentationId);\n\n      const { segments } = segmentation;\n\n      const numberOfSegments = Object.keys(segments).length;\n\n      let newSelectedSegmentIndex = selectedSegment + direction;\n\n      // Segment 0 is always background\n\n      if (newSelectedSegmentIndex > numberOfSegments - 1) {\n        newSelectedSegmentIndex = 1;\n      } else if (newSelectedSegmentIndex === 0) {\n        newSelectedSegmentIndex = numberOfSegments - 1;\n      }\n\n      segmentationService.jumpToSegmentCenter(\n        segmentationId,\n        newSelectedSegmentIndex,\n        toolGroupId\n      );\n      setSelectedSegment(newSelectedSegmentIndex);\n    },\n    [selectedSegment]\n  );\n\n  useEffect(() => {\n    if (segIsLoading) {\n      return;\n    }\n\n    promptHydrateSEG({\n      servicesManager,\n      viewportIndex,\n      segDisplaySet,\n    }).then(isHydrated => {\n      if (isHydrated) {\n        setIsHydrated(true);\n      }\n    });\n  }, [servicesManager, viewportIndex, segDisplaySet, segIsLoading]);\n\n  useEffect(() => {\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENTATION_LOADING_COMPLETE,\n      evt => {\n        if (\n          evt.segDisplaySet.displaySetInstanceUID ===\n          segDisplaySet.displaySetInstanceUID\n        ) {\n          setSegIsLoading(false);\n        }\n\n        if (evt.overlappingSegments) {\n          uiNotificationService.show({\n            title: 'Overlapping Segments',\n            message:\n              'Overlapping segments detected which is not currently supported',\n            type: 'warning',\n          });\n        }\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [segDisplaySet]);\n\n  useEffect(() => {\n    const { unsubscribe } = segmentationService.subscribe(\n      segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE,\n      ({ percentComplete, numSegments }) => {\n        setProcessingProgress({\n          percentComplete,\n          totalSegments: numSegments,\n        });\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [segDisplaySet]);\n\n  /**\n   Cleanup the SEG viewport when the viewport is destroyed\n   */\n  useEffect(() => {\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\n      ({ displaySetInstanceUIDs }) => {\n        const activeViewport = viewports[activeViewportIndex];\n        if (\n          displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)\n        ) {\n          viewportGridService.setDisplaySetsForViewport({\n            viewportIndex: activeViewportIndex,\n            displaySetInstanceUIDs: [],\n          });\n        }\n      }\n    );\n\n    return () => {\n      onDisplaySetsRemovedSubscription.unsubscribe();\n    };\n  }, []);\n\n  useEffect(() => {\n    let toolGroup = toolGroupService.getToolGroup(toolGroupId);\n\n    if (toolGroup) {\n      return;\n    }\n\n    // This creates a custom tool group which has the lifetime of this view\n    // only, and does NOT interfere with currently displayed segmentations.\n    toolGroup = createSEGToolGroupAndAddTools(\n      toolGroupService,\n      customizationService,\n      toolGroupId\n    );\n\n    setToolGroupCreated(true);\n\n    return () => {\n      // remove the segmentation representations if seg displayset changed\n      segmentationService.removeSegmentationRepresentationFromToolGroup(\n        toolGroupId\n      );\n\n      // Only destroy the viewport specific implementation\n      toolGroupService.destroyToolGroup(toolGroupId);\n    };\n  }, []);\n\n  useEffect(() => {\n    setIsHydrated(segDisplaySet.isHydrated);\n\n    return () => {\n      // remove the segmentation representations if seg displayset changed\n      segmentationService.removeSegmentationRepresentationFromToolGroup(\n        toolGroupId\n      );\n      referencedDisplaySetRef.current = null;\n    };\n  }, [segDisplaySet]);\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  let childrenWithProps = null;\n\n  if (\n    !referencedDisplaySetRef.current ||\n    referencedDisplaySet.displaySetInstanceUID !==\n      referencedDisplaySetRef.current.displaySet.displaySetInstanceUID\n  ) {\n    return null;\n  }\n\n  if (children && children.length) {\n    childrenWithProps = children.map((child, index) => {\n      return (\n        child &&\n        React.cloneElement(child, {\n          viewportIndex,\n          key: index,\n        })\n      );\n    });\n  }\n\n  const {\n    PatientID,\n    PatientName,\n    PatientSex,\n    PatientAge,\n    SliceThickness,\n    ManufacturerModelName,\n    StudyDate,\n    SeriesDescription,\n    SpacingBetweenSlices,\n  } = referencedDisplaySetRef.current.metadata;\n\n  const onStatusClick = async () => {\n    const isHydrated = await hydrateSEGDisplaySet({\n      segDisplaySet,\n      viewportIndex,\n      servicesManager,\n    });\n\n    setIsHydrated(isHydrated);\n  };\n\n  return (\n    <>\n      <ViewportActionBar\n        onDoubleClick={evt => {\n          evt.stopPropagation();\n          evt.preventDefault();\n        }}\n        onArrowsClick={onSegmentChange}\n        getStatusComponent={() => {\n          return _getStatusComponent({\n            isHydrated,\n            onStatusClick,\n          });\n        }}\n        studyData={{\n          label: viewportLabel,\n          useAltStyling: true,\n          studyDate: formatDate(StudyDate),\n          seriesDescription: `SEG Viewport ${SeriesDescription}`,\n          patientInformation: {\n            patientName: PatientName\n              ? OHIF.utils.formatPN(PatientName.Alphabetic)\n              : '',\n            patientSex: PatientSex || '',\n            patientAge: PatientAge || '',\n            MRN: PatientID || '',\n            thickness: SliceThickness ? `${SliceThickness.toFixed(2)}mm` : '',\n            spacing:\n              SpacingBetweenSlices !== undefined\n                ? `${SpacingBetweenSlices.toFixed(2)}mm`\n                : '',\n            scanner: ManufacturerModelName || '',\n          },\n        }}\n      />\n\n      <div className=\"relative flex flex-row w-full h-full overflow-hidden\">\n        {segIsLoading && (\n          <LoadingIndicatorTotalPercent\n            className=\"w-full h-full\"\n            totalNumbers={processingProgress.totalSegments}\n            percentComplete={processingProgress.percentComplete}\n            loadingText=\"Loading SEG...\"\n          />\n        )}\n        {getCornerstoneViewport()}\n        {childrenWithProps}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneSEGViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportIndex: PropTypes.number.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  customProps: PropTypes.object,\n};\n\nOHIFCornerstoneSEGViewport.defaultProps = {\n  customProps: {},\n};\n\nfunction _getReferencedDisplaySetMetadata(referencedDisplaySet) {\n  const image0 = referencedDisplaySet.images[0];\n  const referencedDisplaySetMetadata = {\n    PatientID: image0.PatientID,\n    PatientName: image0.PatientName,\n    PatientSex: image0.PatientSex,\n    PatientAge: image0.PatientAge,\n    SliceThickness: image0.SliceThickness,\n    StudyDate: image0.StudyDate,\n    SeriesDescription: image0.SeriesDescription,\n    SeriesInstanceUID: image0.SeriesInstanceUID,\n    SeriesNumber: image0.SeriesNumber,\n    ManufacturerModelName: image0.ManufacturerModelName,\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\n  };\n\n  return referencedDisplaySetMetadata;\n}\n\nexport default OHIFCornerstoneSEGViewport;\n","import React from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { Icon, Tooltip } from '@ohif/ui';\n\n\nexport default function _getStatusComponent({ isHydrated, onStatusClick }) {\n  let ToolTipMessage = null;\n  let StatusIcon = null;\n\n  const {t} = useTranslation(\"Common\");\n  const loadStr = t(\"LOAD\");\n\n  switch (isHydrated) {\n    case true:\n      StatusIcon = () => <Icon name=\"status-alert\" />;\n\n      ToolTipMessage = () => (\n        <div>This Segmentation is loaded in the segmentation panel</div>\n      );\n      break;\n  case false:\n      StatusIcon = () => <Icon name=\"status-untracked\" />;\n\n      ToolTipMessage = () => <div>Click LOAD to load segmentation.</div>;\n  }\n\n  const StatusArea = () => (\n    <div className=\"flex h-6 leading-6 cursor-default text-sm text-white\">\n      <div className=\"min-w-[45px] flex items-center p-1 rounded-l-xl rounded-r bg-customgray-100\">\n        <StatusIcon />\n        <span className=\"ml-1\">SEG</span>\n      </div>\n      {!isHydrated && (\n        <div\n          className=\"ml-1 px-1.5 rounded cursor-pointer hover:text-black bg-primary-main hover:bg-primary-light\"\n          // Using onMouseUp here because onClick is not working when the viewport is not active and is styled with pointer-events:none\n          onMouseUp={onStatusClick}\n        >\n          {loadStr}\n        </div>\n      )}\n    </div>\n  );\n\n\n  return (\n    <>\n      {ToolTipMessage && (\n        <Tooltip content={<ToolTipMessage />} position=\"bottom-left\">\n          <StatusArea />\n        </Tooltip>\n      )}\n      {!ToolTipMessage && <StatusArea />}\n    </>\n  );\n}\n"],"names":[],"sourceRoot":""}