{"version":3,"file":"extensions_cornerstone_src_index_tsx.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAMA;AAQA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAKA;AAEA;AACA;AAEA;AAIA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAKA;AAJA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5tBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAIA;AAHA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AAAA;AAKA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAKA;AACA;AAAA;AAGA;AAIA;AAAA;AACA;AAAA;AAGA;AAIA;AAEA;AAGA;AAAA;AAEA;AACA;AAAA;AAIA;AAAA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AAOA;AACA;AACA;AAMA;AACA;AAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AAGA;AAFA;AACA;AACA;AACA;AAOA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AAGA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AAOA;AAIA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAGA;AAAA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAQA;AACA;AAAA;AAIA;AAAA;AAGA;AAAA;AAMA;AAIA;AAAA;AAQA;AAEA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAWA;AAAA;AAAA;AAEA;AAIA;AAGA;AAAA;AACA;AAAA;AAQA;AAEA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AASA;AACA;AAAA;AAOA;AAAA;AAEA;AACA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5ZA;AACA;AACA;AAUA;AAIA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AAOA;AACA;AAMA;AAMA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AAGA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAIA;AAAA;AAEA;AAAA;AAIA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AAQA;AAGA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA/FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxCA;AAmBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1TA;AAiKA;AA4IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC/SA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AAAA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA/GA;AAMA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AAEA;AACA;AACA;AAUA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AALA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAKA;AAIA;AAIA;;AAEA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;;AAEA;AACA;AAGA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AAIA;AAEA;AACA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AAKA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhUA;AA6RA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC7UA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AAAA;AAAA;AAEA;AAIA;AAEA;AAKA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AArGA;AAEA;AA2BA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AA6BA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxEA;AA6CA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5EA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAGA;AAFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAIA;AAEA;AACA;AAAA;AAAA;AAEA;AAIA;AAEA;AAKA;AAIA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAtFA;AAEA;AAcA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;AAKA;AACA;AAQA;AAQA;AAQA;AAQA;AAQA;AAQA;AAQA;AAQA;;AAQA;AACA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AAIA;AACA;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzZA;AAEA;AAEA;AACA;AAEA;AAgHA;AAwJA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxRA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApFA;AAEA;AAEA;AAsBA;AAkDA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACpFA;AAOA;AAMA;AAEA;AAeA;AAAA;AAJA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AAEA;AAIA;AAKA;AAEA;AAEA;AACA;AAEA;AAMA;AACA;AAIA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAMA;AACA;AAEA;AAMA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AAIA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AArQA;AAEA;AACA;AACA;AAEA;AADA;AACA;AACA;AACA;AACA;AAAA;AA8PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzQA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AAEA;AACA;AAUA;AAOA;AAEA;AAMA;AAEA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAgBA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AANA;AACA;AACA;AACA;AAYA;AAKA;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAuPA;AAEA;AACA;AACA;AAEA;AACA;AAQA;AAQA;AACA;AACA;AACA;AAAA;AA4mBA;AAAA;AAAA;AAEA;;AAIA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AAOA;AAFA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AAIA;AACA;AACA;;AAIA;AACA;AAMA;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AAEA;AACA;AAOA;AAEA;AACA;AAOA;AAEA;AACA;AAMA;AACA;AACA;AAAA;AAQA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAIA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAKA;AAGA;AACA;AAAA;AAKA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAmLA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAIA;AAEA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAIA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAwIA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAoDA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AAEA;AAKA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;AAMA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAoHA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AAEA;AAKA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;AAMA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAkDA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAgBA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAAA;AA2FA;AACA;AAIA;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAIA;AAAA;AAAA;AAEA;AACA;AAEA;;AAMA;AACA;AAAA;AAAA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAAA;AA4BA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAAA;AAAA;AACA;AA7pEA;AAEA;AAEA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAEA;AACA;AAOA;AAEA;AACA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AAOA;AAEA;AAKA;AACA;AAMA;AAEA;AAKA;AACA;AAEA;AAMA;AACA;AAoCA;AAMA;AACA;AAEA;AAIA;AAEA;AACA;AAKA;AAEA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAFA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAGA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;;AAKA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AASA;AALA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AACA;AAEA;AACA;AASA;AACA;AACA;AAEA;AAQA;AAJA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAKA;AAEA;AASA;AAqOA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AASA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAGA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;AAEA;;AAEA;;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AACA;AA+HA;AAKA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AAIA;;AAIA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AAyBA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AA2DA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AAEA;;AAOA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AA2DA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAIA;AACA;AAsBA;AACA;AACA;AAKA;AAIA;AA8EA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAGA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAgDA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAoBA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAhrEA;AAEA;AACA;AACA;AAEA;AADA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAyqEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAntEA;AACA;AACA;AAEA;AAkBA;AAEA;AAMA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AAMA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAeA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAqBA;AAAA;AAVA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAxIA;AAEA;AACA;AACA;AAEA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvCA;AAsBA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAcA;AAmBA;AAAA;AARA;AAEA;AACA;AACA;AAFA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AAKA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AApTA;AAEA;AACA;AACA;AAEA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA1BA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AAEA;AAcA;AAKA;AACA;AAWA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAwBA;AACA;AAAA;AAbA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAKA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAEA;AAKA;AACA;AAEA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AAIA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;;AAKA;AACA;AACA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAIA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AAEA;AAKA;AAMA;;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAMA;AAIA;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AAEA;AAQA;;AAEA;AACA;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAz2BA;AAGA;AACA;AACA;AAEA;AADA;AACA;AACA;AACA;AACA;AAAA;AAi2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAp3BA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CA;AAMA;AACA;AACA;AA+EA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AAAA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAyBA;AACA;AACA;AACA;AACA;AA1BA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9OA;AACA;AAIA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACxGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AArCA;AAWA;AAkBA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AACA;AAGA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAGA;AACA;AAGA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAxBA;AA0BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;;AAQA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjIA;AAKA;AA0BA;AAMA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEpDA;AACA;AACA;AAOA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAHA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AAEA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAKA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAlQA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AAEA;AAEA;AACA;AACA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAIA;AAAA;AAHA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AASA;AACA;AAAA;AATA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;;AAEA;AACA;AAGA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAOA;AACA;AAEA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvNA;AAsBA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AAHA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAFA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvNA;AAUA;AAcA;AAOA;AAIA;AAIA;AAIA;AAIA;AAMA;AAsBA;AAaA;AA6HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AAGA;AAEA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAdA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AArBA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxBA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3DA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AAMA;;AAGA;AACA;;AAEA;AACA;;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhJA;AACA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AAMA;;AAGA;AACA;;AAEA;AACA;;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAtIA;AACA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7MA;AAkFA;AAsDA;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AC7KA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9IA;AAmFA;AAgCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpHA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAzMA;AA2EA;AAuDA;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9NA;AA2EA;AA2DA;AA2CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA7MA;AAkFA;AAsDA;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7KA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9NA;AA2EA;AA2DA;AA2CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAOA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAnMA;AA+EA;AAmDA;AAiCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACvKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhJA;AAwFA;AA0CA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/IA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAOA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxNA;AAwEA;AAwDA;AA2CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AChLA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;ACXA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAvMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjBA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAjCA;AASA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAIA;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AAMA;;AAGA;AACA;;AAEA;AACA;;AAIA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxFA;AACA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3BA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;;AAKA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5GA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3BA;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjFA","sources":["file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/commandsModule.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/components/DicomUpload/DicomUpload.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/components/DicomUpload/DicomUploadProgress.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/components/DicomUpload/DicomUploadProgressItem.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/getCustomizationModule.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/getHangingProtocolModule.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/id.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/index.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/init.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/initCineService.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/initContextMenu.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/initCornerstoneTools.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/initDoubleClick.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/initMeasurementService.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/initWADOImageLoader.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/CornerstoneCacheService/CornerstoneCacheService.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/CornerstoneCacheService/index.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/SegmentationService/RTSTRUCT/mapROIContoursToRTStructData.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/SegmentationService/SegmentationService.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/SegmentationService/index.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/SyncGroupService/SyncGroupService.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/SyncGroupService/index.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/ToolGroupService/ToolGroupService.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/ToolGroupService/index.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/ViewportService/CornerstoneViewportService.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/ViewportService/Viewport.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/services/ViewportService/constants.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/state.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/tools/CalibrationLineTool.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/types/index.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/CornerstoneViewportDownloadForm.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/DicomFileUploader.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/JumpPresets.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/callInputDialog.tsx","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/dicomLoaderService.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/findNearbyToolData.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/getActiveViewportEnabledElement.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/getCornerstoneBlendMode.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/getCornerstoneOrientation.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/getCornerstoneViewportType.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/getInterleavedFrames.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/getNthFrames.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/interleave.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/interleaveCenterLoader.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/interleaveTopToBottom.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/Angle.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/ArrowAnnotate.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/Bidirectional.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/CircleROI.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/CobbAngle.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/EllipticalROI.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/Length.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/PlanarFreehandROI.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/RectangleROI.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/constants/supportedTools.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/index.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/measurementServiceMappingsFactory.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/utils/getHandlesFromPoints.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/utils/getModalityUnit.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/utils/getSOPInstanceAttributes.js","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/utils/index.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/measurementServiceMappings/utils/selection.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/nthLoader.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/stackSync/calculateViewportRegistrations.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/stackSync/toggleStackImageSync.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/utils/transitions.ts","file:////Users/smartxx/xV/DICOM/Viewers/extensions/cornerstone/src/components/DicomUpload/DicomUpload.css","webpack:///../../../extensions/cornerstone/src/components/DicomUpload/DicomUpload.css?f882","file:///ignored%7C/Users/smartxx/xV/DICOM/Viewers/node_modules/seedrandom%7Ccrypto"],"sourcesContent":["import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport {\n  ToolGroupManager,\n  Enums,\n  utilities as cstUtils,\n  ReferenceLinesTool,\n} from '@cornerstonejs/tools';\nimport { Types as OhifTypes } from '@ohif/core';\n\nimport CornerstoneViewportDownloadForm from './utils/CornerstoneViewportDownloadForm';\nimport callInputDialog from './utils/callInputDialog';\nimport toggleStackImageSync from './utils/stackSync/toggleStackImageSync';\nimport { getFirstAnnotationSelected } from './utils/measurementServiceMappings/utils/selection';\nimport getActiveViewportEnabledElement from './utils/getActiveViewportEnabledElement';\nimport { CornerstoneServices } from './types';\n\nfunction commandsModule({\n  servicesManager,\n  commandsManager,\n}: OhifTypes.Extensions.ExtensionParams): OhifTypes.Extensions.CommandsModule {\n  const {\n    viewportGridService,\n    toolGroupService,\n    cineService,\n    toolbarService,\n    uiDialogService,\n    cornerstoneViewportService,\n    uiNotificationService,\n    measurementService,\n  } = servicesManager.services as CornerstoneServices;\n\n  const { measurementServiceSource } = this;\n\n  function _getActiveViewportEnabledElement() {\n    return getActiveViewportEnabledElement(viewportGridService);\n  }\n  const actions = {\n    /**\n     * Generates the selector props for the context menu, specific to\n     * the cornerstone viewport, and then runs the context menu.\n     */\n    showCornerstoneContextMenu: options => {\n      const element = _getActiveViewportEnabledElement()?.viewport?.element;\n\n      const optionsToUse = { ...options, element };\n      const { useSelectedAnnotation, nearbyToolData, event } = optionsToUse;\n\n      // This code is used to invoke the context menu via keyboard shortcuts\n      if (useSelectedAnnotation && !nearbyToolData) {\n        const firstAnnotationSelected = getFirstAnnotationSelected(element);\n        // filter by allowed selected tools from config property (if there is any)\n        const isToolAllowed =\n          !optionsToUse.allowedSelectedTools ||\n          optionsToUse.allowedSelectedTools.includes(\n            firstAnnotationSelected?.metadata?.toolName\n          );\n        if (isToolAllowed) {\n          optionsToUse.nearbyToolData = firstAnnotationSelected;\n        } else {\n          return;\n        }\n      }\n\n      optionsToUse.defaultPointsPosition = [];\n      // if (optionsToUse.nearbyToolData) {\n      //   optionsToUse.defaultPointsPosition = commandsManager.runCommand(\n      //     'getToolDataActiveCanvasPoints',\n      //     { toolData: optionsToUse.nearbyToolData }\n      //   );\n      // }\n\n      // TODO - make the selectorProps richer by including the study metadata and display set.\n      optionsToUse.selectorProps = {\n        toolName: optionsToUse.nearbyToolData?.metadata?.toolName,\n        value: optionsToUse.nearbyToolData,\n        uid: optionsToUse.nearbyToolData?.annotationUID,\n        nearbyToolData: optionsToUse.nearbyToolData,\n        event,\n        ...optionsToUse.selectorProps,\n      };\n\n      commandsManager.run(options, optionsToUse);\n    },\n\n    getNearbyToolData({ nearbyToolData, element, canvasCoordinates }) {\n      return (\n        nearbyToolData ??\n        cstUtils.getAnnotationNearPoint(element, canvasCoordinates)\n      );\n    },\n    getNearbyAnnotation({ element, canvasCoordinates }) {\n      const nearbyToolData = actions.getNearbyToolData({\n        nearbyToolData: null,\n        element,\n        canvasCoordinates,\n      });\n\n      const isAnnotation = toolName => {\n        const enabledElement = getEnabledElement(element);\n\n        if (!enabledElement) {\n          return;\n        }\n\n        const { renderingEngineId, viewportId } = enabledElement;\n        const toolGroup = ToolGroupManager.getToolGroupForViewport(\n          viewportId,\n          renderingEngineId\n        );\n\n        const toolInstance = toolGroup.getToolInstance(toolName);\n\n        return toolInstance?.constructor?.isAnnotation ?? true;\n      };\n\n      return nearbyToolData?.metadata?.toolName &&\n        isAnnotation(nearbyToolData.metadata.toolName)\n        ? nearbyToolData\n        : null;\n    },\n\n    // Measurement tool commands:\n\n    /** Delete the given measurement */\n    deleteMeasurement: ({ uid }) => {\n      if (uid) {\n        measurementServiceSource.remove(uid);\n      }\n    },\n\n    /**\n     * Show the measurement labelling input dialog and update the label\n     * on the measurement with a response if not cancelled.\n     */\n    setMeasurementLabel: ({ uid }) => {\n      const measurement = measurementService.getMeasurement(uid);\n\n      callInputDialog(\n        uiDialogService,\n        measurement,\n        (label, actionId) => {\n          if (actionId === 'cancel') {\n            return;\n          }\n\n          const updatedMeasurement = Object.assign({}, measurement, {\n            label,\n          });\n\n          measurementService.update(\n            updatedMeasurement.uid,\n            updatedMeasurement,\n            true\n          );\n        },\n        false\n      );\n    },\n\n    /**\n     *\n     * @param props - containing the updates to apply\n     * @param props.measurementKey - chooses the measurement key to apply the\n     *        code to.  This will typically be finding or site to apply a\n     *        finind code or a findingSites code.\n     * @param props.code - A coding scheme value from DICOM, including:\n     *       * CodeValue - the language independent code, for example '1234'\n     *       * CodingSchemeDesignator - the issue of the code value\n     *       * CodeMeaning - the text value shown to the user\n     *       * ref - a string reference in the form `<designator>:<codeValue>`\n     *       * Other fields\n     *     Note it is a valid option to remove the finding or site values by\n     *     supplying null for the code.\n     * @param props.uid - the measurement UID to find it with\n     * @param props.label - the text value for the code.  Has NOTHING to do with\n     *        the measurement label, which can be set with textLabel\n     * @param props.textLabel is the measurement label to apply.  Set to null to\n     *            delete.\n     *\n     * If the measurementKey is `site`, then the code will also be added/replace\n     * the 0 element of findingSites.  This behaviour is expected to be enhanced\n     * in the future with ability to set other site information.\n     */\n    updateMeasurement: props => {\n      const { code, uid, textLabel, label } = props;\n      const measurement = measurementService.getMeasurement(uid);\n      const updatedMeasurement = {\n        ...measurement,\n      };\n      // Call it textLabel as the label value\n      // TODO - remove the label setting when direct rendering of findingSites is enabled\n      if (textLabel !== undefined) {\n        updatedMeasurement.label = textLabel;\n      }\n      if (code !== undefined) {\n        const measurementKey = code.type || 'finding';\n\n        if (code.ref && !code.CodeValue) {\n          const split = code.ref.indexOf(':');\n          code.CodeValue = code.ref.substring(split + 1);\n          code.CodeMeaning = code.text || label;\n          code.CodingSchemeDesignator = code.ref.substring(0, split);\n        }\n        updatedMeasurement[measurementKey] = code;\n        // TODO - remove this line once the measurements table customizations are in\n        if (measurementKey !== 'finding') {\n          if (updatedMeasurement.findingSites) {\n            updatedMeasurement.findingSites = updatedMeasurement.findingSites.filter(\n              it => it.type !== measurementKey\n            );\n            updatedMeasurement.findingSites.push(code);\n          } else {\n            updatedMeasurement.findingSites = [code];\n          }\n        }\n      }\n      measurementService.update(\n        updatedMeasurement.uid,\n        updatedMeasurement,\n        true\n      );\n    },\n\n    // Retrieve value commands\n    getActiveViewportEnabledElement: _getActiveViewportEnabledElement,\n\n    setViewportActive: ({ viewportId }) => {\n      const viewportInfo = cornerstoneViewportService.getViewportInfo(\n        viewportId\n      );\n      if (!viewportInfo) {\n        console.warn('No viewport found for viewportId:', viewportId);\n        return;\n      }\n\n      const viewportIndex = viewportInfo.getViewportIndex();\n      viewportGridService.setActiveViewportIndex(viewportIndex);\n    },\n    arrowTextCallback: ({ callback, data }) => {\n      callInputDialog(uiDialogService, data, callback);\n    },\n    toggleCine: () => {\n      const { viewports } = viewportGridService.getState();\n      const { isCineEnabled } = cineService.getState();\n      cineService.setIsCineEnabled(!isCineEnabled);\n      toolbarService.setButton('Cine', { props: { isActive: !isCineEnabled } });\n      viewports.forEach((_, index) =>\n        cineService.setCine({ id: index, isPlaying: false })\n      );\n    },\n    setWindowLevel({ window, level, toolGroupId }) {\n      // convert to numbers\n      const windowWidthNum = Number(window);\n      const windowCenterNum = Number(level);\n\n      const { viewportId } = _getActiveViewportEnabledElement();\n      const viewportToolGroupId = toolGroupService.getToolGroupForViewport(\n        viewportId\n      );\n\n      if (toolGroupId && toolGroupId !== viewportToolGroupId) {\n        return;\n      }\n\n      // get actor from the viewport\n      const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n      const viewport = renderingEngine.getViewport(viewportId);\n\n      const { lower, upper } = csUtils.windowLevel.toLowHighRange(\n        windowWidthNum,\n        windowCenterNum\n      );\n\n      viewport.setProperties({\n        voiRange: {\n          upper,\n          lower,\n        },\n      });\n      viewport.render();\n    },\n\n    // Just call the toolbar service record interaction - allows\n    // executing a toolbar command as a full toolbar command with side affects\n    // coming from the ToolbarService itself.\n    toolbarServiceRecordInteraction: props => {\n      toolbarService.recordInteraction(props);\n    },\n\n    setToolActive: ({ toolName, toolGroupId = null }) => {\n      if (toolName === 'Crosshairs') {\n        const activeViewportToolGroup = toolGroupService.getToolGroup(null);\n\n        if (!activeViewportToolGroup._toolInstances.Crosshairs) {\n          uiNotificationService.show({\n            title: 'Crosshairs',\n            message:\n              'You need to be in a MPR view to use Crosshairs. Click on MPR button in the toolbar to activate it.',\n            type: 'info',\n            duration: 3000,\n          });\n\n          throw new Error('Crosshairs tool is not available in this viewport');\n        }\n      }\n\n      const { viewports } = viewportGridService.getState() || {\n        viewports: [],\n      };\n\n      const toolGroup = toolGroupService.getToolGroup(toolGroupId);\n      const toolGroupViewportIds = toolGroup?.getViewportIds?.();\n\n      // if toolGroup has been destroyed, or its viewports have been removed\n      if (!toolGroupViewportIds || !toolGroupViewportIds.length) {\n        return;\n      }\n\n      const filteredViewports = viewports.filter(viewport => {\n        if (!viewport.viewportOptions) {\n          return false;\n        }\n\n        return toolGroupViewportIds.includes(\n          viewport.viewportOptions.viewportId\n        );\n      });\n\n      if (!filteredViewports.length) {\n        return;\n      }\n\n      if (!toolGroup.getToolInstance(toolName)) {\n        uiNotificationService.show({\n          title: `${toolName} tool`,\n          message: `The ${toolName} tool is not available in this viewport.`,\n          type: 'info',\n          duration: 3000,\n        });\n\n        throw new Error(`ToolGroup ${toolGroup.id} does not have this tool.`);\n      }\n\n      const activeToolName = toolGroup.getActivePrimaryMouseButtonTool();\n\n      if (activeToolName) {\n        // Todo: this is a hack to prevent the crosshairs to stick around\n        // after another tool is selected. We should find a better way to do this\n        if (activeToolName === 'Crosshairs') {\n          toolGroup.setToolDisabled(activeToolName);\n        } else {\n          toolGroup.setToolPassive(activeToolName);\n        }\n      }\n      // Set the new toolName to be active\n      toolGroup.setToolActive(toolName, {\n        bindings: [\n          {\n            mouseButton: Enums.MouseBindings.Primary,\n          },\n        ],\n      });\n    },\n    showDownloadViewportModal: () => {\n      const { activeViewportIndex } = viewportGridService.getState();\n\n      if (\n        !cornerstoneViewportService.getCornerstoneViewportByIndex(\n          activeViewportIndex\n        )\n      ) {\n        // Cannot download a non-cornerstone viewport (image).\n        uiNotificationService.show({\n          title: 'Download Image',\n          message: 'Image cannot be downloaded',\n          type: 'error',\n        });\n        return;\n      }\n\n      const { uiModalService } = servicesManager.services;\n\n      if (uiModalService) {\n        uiModalService.show({\n          content: CornerstoneViewportDownloadForm,\n          title: 'Download High Quality Image',\n          contentProps: {\n            activeViewportIndex,\n            onClose: uiModalService.hide,\n            cornerstoneViewportService,\n          },\n        });\n      }\n    },\n    rotateViewport: ({ rotation }) => {\n      const enabledElement = _getActiveViewportEnabledElement();\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        const { rotation: currentRotation } = viewport.getProperties();\n        const newRotation = (currentRotation + rotation) % 360;\n        viewport.setProperties({ rotation: newRotation });\n        viewport.render();\n      }\n    },\n    flipViewportHorizontal: () => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        const { flipHorizontal } = viewport.getCamera();\n        viewport.setCamera({ flipHorizontal: !flipHorizontal });\n        viewport.render();\n      }\n    },\n    flipViewportVertical: () => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        const { flipVertical } = viewport.getCamera();\n        viewport.setCamera({ flipVertical: !flipVertical });\n        viewport.render();\n      }\n    },\n    invertViewport: ({ element }) => {\n      let enabledElement;\n\n      if (element === undefined) {\n        enabledElement = _getActiveViewportEnabledElement();\n      } else {\n        enabledElement = element;\n      }\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        const { invert } = viewport.getProperties();\n        viewport.setProperties({ invert: !invert });\n        viewport.render();\n      }\n    },\n    resetViewport: () => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        viewport.resetProperties();\n        viewport.resetCamera();\n      } else {\n        // Todo: add reset properties for volume viewport\n        viewport.resetCamera();\n      }\n\n      viewport.render();\n    },\n    scaleViewport: ({ direction }) => {\n      const enabledElement = _getActiveViewportEnabledElement();\n      const scaleFactor = direction > 0 ? 0.9 : 1.1;\n\n      if (!enabledElement) {\n        return;\n      }\n      const { viewport } = enabledElement;\n\n      if (viewport instanceof StackViewport) {\n        if (direction) {\n          const { parallelScale } = viewport.getCamera();\n          viewport.setCamera({ parallelScale: parallelScale * scaleFactor });\n          viewport.render();\n        } else {\n          viewport.resetCamera();\n          viewport.render();\n        }\n      }\n    },\n\n    /** Jumps the active viewport or the specified one to the given slice index */\n    jumpToImage: ({ imageIndex, viewport: gridViewport }): void => {\n      // Get current active viewport (return if none active)\n      let viewport;\n      if (!gridViewport) {\n        const enabledElement = _getActiveViewportEnabledElement();\n        if (!enabledElement) {\n          return;\n        }\n        viewport = enabledElement.viewport;\n      } else {\n        viewport = cornerstoneViewportService.getCornerstoneViewport(\n          gridViewport.id\n        );\n      }\n\n      // Get number of slices\n      // -> Copied from cornerstone3D jumpToSlice\\_getImageSliceData()\n      let numberOfSlices = 0;\n\n      if (viewport instanceof StackViewport) {\n        numberOfSlices = viewport.getImageIds().length;\n      } else if (viewport instanceof VolumeViewport) {\n        numberOfSlices = csUtils.getImageSliceDataForVolumeViewport(viewport)\n          .numberOfSlices;\n      } else {\n        throw new Error('Unsupported viewport type');\n      }\n\n      const jumpIndex =\n        imageIndex < 0 ? numberOfSlices + imageIndex : imageIndex;\n      if (jumpIndex >= numberOfSlices || jumpIndex < 0) {\n        throw new Error(`Can't jump to ${imageIndex}`);\n      }\n\n      // Set slice to last slice\n      const options = { imageIndex: jumpIndex };\n      cstUtils.jumpToSlice(viewport.element, options);\n    },\n    scroll: ({ direction }) => {\n      const enabledElement = _getActiveViewportEnabledElement();\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      const options = { delta: direction };\n\n      cstUtils.scroll(viewport, options);\n    },\n    setViewportColormap: ({\n      viewportIndex,\n      displaySetInstanceUID,\n      colormap,\n      immediate = false,\n    }) => {\n      const viewport = cornerstoneViewportService.getCornerstoneViewportByIndex(\n        viewportIndex\n      );\n\n      const actorEntries = viewport.getActors();\n\n      const actorEntry = actorEntries.find(actorEntry => {\n        return actorEntry.uid.includes(displaySetInstanceUID);\n      });\n\n      const { actor: volumeActor, uid: volumeId } = actorEntry;\n\n      viewport.setProperties({ colormap, volumeActor }, volumeId);\n\n      if (immediate) {\n        viewport.render();\n      }\n    },\n    incrementActiveViewport: () => {\n      const { activeViewportIndex, viewports } = viewportGridService.getState();\n      const nextViewportIndex = (activeViewportIndex + 1) % viewports.length;\n      viewportGridService.setActiveViewportIndex(nextViewportIndex);\n    },\n    decrementActiveViewport: () => {\n      const { activeViewportIndex, viewports } = viewportGridService.getState();\n      const nextViewportIndex =\n        (activeViewportIndex - 1 + viewports.length) % viewports.length;\n      viewportGridService.setActiveViewportIndex(nextViewportIndex);\n    },\n    toggleStackImageSync: ({ toggledState }) => {\n      toggleStackImageSync({\n        getEnabledElement,\n        servicesManager,\n        toggledState,\n      });\n    },\n    toggleReferenceLines: ({ toggledState }) => {\n      const { activeViewportIndex } = viewportGridService.getState();\n      const viewportInfo = cornerstoneViewportService.getViewportInfoByIndex(\n        activeViewportIndex\n      );\n\n      const viewportId = viewportInfo.getViewportId();\n      const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\n\n      if (!toggledState) {\n        toolGroup.setToolDisabled(ReferenceLinesTool.toolName);\n      }\n\n      toolGroup.setToolConfiguration(\n        ReferenceLinesTool.toolName,\n        {\n          sourceViewportId: viewportId,\n        },\n        true // overwrite\n      );\n      toolGroup.setToolEnabled(ReferenceLinesTool.toolName);\n    },\n  };\n\n  const definitions = {\n    // The command here is to show the viewer context menu, as being the\n    // context menu\n    showCornerstoneContextMenu: {\n      commandFn: actions.showCornerstoneContextMenu,\n      storeContexts: [],\n      options: {\n        menuCustomizationId: 'measurementsContextMenu',\n        commands: [\n          {\n            commandName: 'showContextMenu',\n          },\n        ],\n      },\n    },\n\n    getNearbyToolData: {\n      commandFn: actions.getNearbyToolData,\n    },\n    getNearbyAnnotation: {\n      commandFn: actions.getNearbyAnnotation,\n      storeContexts: [],\n      options: {},\n    },\n\n    deleteMeasurement: {\n      commandFn: actions.deleteMeasurement,\n    },\n    setMeasurementLabel: {\n      commandFn: actions.setMeasurementLabel,\n    },\n    updateMeasurement: {\n      commandFn: actions.updateMeasurement,\n    },\n\n    setWindowLevel: {\n      commandFn: actions.setWindowLevel,\n    },\n    toolbarServiceRecordInteraction: {\n      commandFn: actions.toolbarServiceRecordInteraction,\n    },\n    setToolActive: {\n      commandFn: actions.setToolActive,\n    },\n    rotateViewportCW: {\n      commandFn: actions.rotateViewport,\n      options: { rotation: 90 },\n    },\n    rotateViewportCCW: {\n      commandFn: actions.rotateViewport,\n      options: { rotation: -90 },\n    },\n    incrementActiveViewport: {\n      commandFn: actions.incrementActiveViewport,\n    },\n    decrementActiveViewport: {\n      commandFn: actions.decrementActiveViewport,\n    },\n    flipViewportHorizontal: {\n      commandFn: actions.flipViewportHorizontal,\n    },\n    flipViewportVertical: {\n      commandFn: actions.flipViewportVertical,\n    },\n    invertViewport: {\n      commandFn: actions.invertViewport,\n    },\n    resetViewport: {\n      commandFn: actions.resetViewport,\n    },\n    scaleUpViewport: {\n      commandFn: actions.scaleViewport,\n      options: { direction: 1 },\n    },\n    scaleDownViewport: {\n      commandFn: actions.scaleViewport,\n      options: { direction: -1 },\n    },\n    fitViewportToWindow: {\n      commandFn: actions.scaleViewport,\n      options: { direction: 0 },\n    },\n    nextImage: {\n      commandFn: actions.scroll,\n      options: { direction: 1 },\n    },\n    previousImage: {\n      commandFn: actions.scroll,\n      options: { direction: -1 },\n    },\n    firstImage: {\n      commandFn: actions.jumpToImage,\n      options: { imageIndex: 0 },\n    },\n    lastImage: {\n      commandFn: actions.jumpToImage,\n      options: { imageIndex: -1 },\n    },\n    jumpToImage: {\n      commandFn: actions.jumpToImage,\n    },\n    showDownloadViewportModal: {\n      commandFn: actions.showDownloadViewportModal,\n    },\n    toggleCine: {\n      commandFn: actions.toggleCine,\n    },\n    arrowTextCallback: {\n      commandFn: actions.arrowTextCallback,\n    },\n    setViewportActive: {\n      commandFn: actions.setViewportActive,\n    },\n    setViewportColormap: {\n      commandFn: actions.setViewportColormap,\n    },\n    toggleStackImageSync: {\n      commandFn: actions.toggleStackImageSync,\n    },\n    toggleReferenceLines: {\n      commandFn: actions.toggleReferenceLines,\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'CORNERSTONE',\n  };\n}\n\nexport default commandsModule;\n","import React, { useCallback, useState } from 'react';\nimport { ReactElement } from 'react';\nimport Dropzone from 'react-dropzone';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport DicomFileUploader from '../../utils/DicomFileUploader';\nimport DicomUploadProgress from './DicomUploadProgress';\nimport { Button } from '@ohif/ui';\nimport './DicomUpload.css';\n\ntype DicomUploadProps = {\n  dataSource;\n  onComplete: () => void;\n  onStarted: () => void;\n};\n\nfunction DicomUpload({\n  dataSource,\n  onComplete,\n  onStarted,\n}: DicomUploadProps): ReactElement {\n  const baseClassNames = 'min-h-[480px] flex flex-col bg-black select-none';\n  const [dicomFileUploaderArr, setDicomFileUploaderArr] = useState([]);\n\n  const onDrop = useCallback(async acceptedFiles => {\n    onStarted();\n    setDicomFileUploaderArr(\n      acceptedFiles.map(file => new DicomFileUploader(file, dataSource))\n    );\n  }, []);\n\n  const getDropZoneComponent = (): ReactElement => {\n    return (\n      <Dropzone\n        onDrop={acceptedFiles => {\n          onDrop(acceptedFiles);\n        }}\n        noClick\n      >\n        {({ getRootProps }) => (\n          <div\n            {...getRootProps()}\n            className=\"m-5 dicom-upload-drop-area-border-dash flex flex-col items-center justify-center h-full\"\n          >\n            <div className=\"flex gap-3\">\n              <Dropzone onDrop={onDrop} noDrag>\n                {({ getRootProps, getInputProps }) => (\n                  <div {...getRootProps()}>\n                    <Button\n                      variant=\"contained\"\n                      color=\"primary\"\n                      disabled={false}\n                      onClick={() => {}}\n                    >\n                      {'Add files'}\n                      <input {...getInputProps()} />\n                    </Button>\n                  </div>\n                )}\n              </Dropzone>\n              <Dropzone onDrop={onDrop} noDrag>\n                {({ getRootProps, getInputProps }) => (\n                  <div {...getRootProps()}>\n                    <Button\n                      variant=\"contained\"\n                      color=\"primaryDark\"\n                      border=\"primaryActive\"\n                      disabled={false}\n                      onClick={() => {}}\n                    >\n                      {'Add folder'}\n                      <input\n                        {...getInputProps()}\n                        webkitdirectory=\"true\"\n                        mozdirectory=\"true\"\n                      />\n                    </Button>\n                  </div>\n                )}\n              </Dropzone>\n            </div>\n            <div className=\"pt-5\">or drag images or folders here</div>\n            <div className=\"pt-3 text-aqua-pale text-lg\">\n              (DICOM files supported)\n            </div>\n          </div>\n        )}\n      </Dropzone>\n    );\n  };\n\n  return (\n    <>\n      {dicomFileUploaderArr.length ? (\n        <div className={classNames('h-[calc(100vh-300px)]', baseClassNames)}>\n          <DicomUploadProgress\n            dicomFileUploaderArr={Array.from(dicomFileUploaderArr)}\n            onComplete={onComplete}\n          />\n        </div>\n      ) : (\n        <div className={classNames('h-[480px]', baseClassNames)}>\n          {getDropZoneComponent()}\n        </div>\n      )}\n    </>\n  );\n}\n\nDicomUpload.propTypes = {\n  dataSource: PropTypes.object.isRequired,\n  onComplete: PropTypes.func.isRequired,\n  onStarted: PropTypes.func.isRequired,\n};\n\nexport default DicomUpload;\n","import React, {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  ReactElement,\n} from 'react';\nimport PropTypes from 'prop-types';\nimport { Button, Icon, ProgressLoadingBar } from '@ohif/ui';\nimport DicomFileUploader, {\n  EVENTS,\n  UploadStatus,\n  DicomFileUploaderProgressEvent,\n  UploadRejection,\n} from '../../utils/DicomFileUploader';\nimport DicomUploadProgressItem from './DicomUploadProgressItem';\nimport classNames from 'classnames';\n\ntype DicomUploadProgressProps = {\n  dicomFileUploaderArr: DicomFileUploader[];\n  onComplete: () => void;\n};\n\nconst ONE_SECOND = 1000;\nconst ONE_MINUTE = ONE_SECOND * 60;\nconst ONE_HOUR = ONE_MINUTE * 60;\n\n// The base/initial interval time length used to calculate the\n// rate of the upload and in turn estimate the\n// the amount of time remaining for the upload. This is the length\n// of the very first interval to get a reasonable estimate on screen in\n// a reasonable amount of time. The length of each interval after the first\n// is based on the upload rate calculated. Faster rates use this base interval\n// length. Slower rates below UPLOAD_RATE_THRESHOLD get longer interval times\n// to obtain more accurate upload rates.\nconst BASE_INTERVAL_TIME = 15000;\n\n// The upload rate threshold to determine the length of the interval to\n// calculate the upload rate.\nconst UPLOAD_RATE_THRESHOLD = 75;\n\nconst NO_WRAP_ELLIPSIS_CLASS_NAMES =\n  'text-ellipsis whitespace-nowrap overflow-hidden';\n\nfunction DicomUploadProgress({\n  dicomFileUploaderArr,\n  onComplete,\n}: DicomUploadProgressProps): ReactElement {\n  const [totalUploadSize] = useState(\n    dicomFileUploaderArr.reduce(\n      (acc, fileUploader) => acc + fileUploader.getFileSize(),\n      0\n    )\n  );\n\n  const currentUploadSizeRef = useRef<number>(0);\n\n  const uploadRateRef = useRef(0);\n\n  const [timeRemaining, setTimeRemaining] = useState<number>(null);\n\n  const [percentComplete, setPercentComplete] = useState(0);\n\n  const [numFilesCompleted, setNumFilesCompleted] = useState(0);\n\n  const [numFails, setNumFails] = useState(0);\n\n  const [showFailedOnly, setShowFailedOnly] = useState(false);\n\n  const progressBarContainerRef = useRef<HTMLElement>();\n\n  /**\n   * The effect for measuring and setting the current upload rate. This is\n   * done by measuring the amount of data uploaded in a set interval time.\n   */\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout;\n\n    // The amount of data already uploaded at the start of the interval.\n    let intervalStartUploadSize = 0;\n\n    // The starting time of the interval.\n    let intervalStartTime = Date.now();\n\n    const setUploadRateRef = () => {\n      const uploadSizeFromStartOfInterval =\n        currentUploadSizeRef.current - intervalStartUploadSize;\n\n      const now = Date.now();\n      const timeSinceStartOfInterval = now - intervalStartTime;\n\n      // Calculate and set the upload rate (ref)\n      uploadRateRef.current =\n        uploadSizeFromStartOfInterval / timeSinceStartOfInterval;\n\n      // Reset the interval starting values.\n      intervalStartUploadSize = currentUploadSizeRef.current;\n      intervalStartTime = now;\n\n      // Only start a new interval if there is more to upload.\n      if (totalUploadSize - currentUploadSizeRef.current > 0) {\n        if (uploadRateRef.current >= UPLOAD_RATE_THRESHOLD) {\n          timeoutId = setTimeout(setUploadRateRef, BASE_INTERVAL_TIME);\n        } else {\n          // The current upload rate is relatively slow, so use a larger\n          // time interval to get a better upload rate estimate.\n          timeoutId = setTimeout(setUploadRateRef, BASE_INTERVAL_TIME * 2);\n        }\n      }\n    };\n\n    // The very first interval is just the base time interval length.\n    timeoutId = setTimeout(setUploadRateRef, BASE_INTERVAL_TIME);\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, []);\n\n  /**\n   * The effect for: updating the overall percentage complete; setting the\n   * estimated time remaining; updating the number of files uploaded; and\n   * detecting if any error has occurred.\n   */\n  useEffect(() => {\n    let currentTimeRemaining = null;\n\n    // For each uploader, listen for the progress percentage complete and\n    // add promise catch/finally callbacks to detect errors and count number\n    // of uploads complete.\n    const subscriptions = dicomFileUploaderArr.map(fileUploader => {\n      let currentFileUploadSize = 0;\n\n      const updateProgress = (percentComplete: number) => {\n        const previousFileUploadSize = currentFileUploadSize;\n\n        currentFileUploadSize = Math.round(\n          (percentComplete / 100) * fileUploader.getFileSize()\n        );\n\n        currentUploadSizeRef.current = Math.min(\n          totalUploadSize,\n          currentUploadSizeRef.current -\n            previousFileUploadSize +\n            currentFileUploadSize\n        );\n\n        setPercentComplete(\n          (currentUploadSizeRef.current / totalUploadSize) * 100\n        );\n\n        if (uploadRateRef.current !== 0) {\n          const uploadSizeRemaining =\n            totalUploadSize - currentUploadSizeRef.current;\n\n          const timeRemaining = Math.round(\n            uploadSizeRemaining / uploadRateRef.current\n          );\n\n          if (currentTimeRemaining === null) {\n            currentTimeRemaining = timeRemaining;\n            setTimeRemaining(currentTimeRemaining);\n            return;\n          }\n\n          // Do not show an increase in the time remaining by two seconds or minutes\n          // so as to prevent jumping the time remaining up and down constantly\n          // due to rounding, inaccuracies in the estimate and slight variations\n          // in upload rates over time.\n          if (timeRemaining < ONE_MINUTE) {\n            const currentSecondsRemaining = Math.ceil(\n              currentTimeRemaining / ONE_SECOND\n            );\n            const secondsRemaining = Math.ceil(timeRemaining / ONE_SECOND);\n            const delta = secondsRemaining - currentSecondsRemaining;\n            if (delta < 0 || delta > 2) {\n              currentTimeRemaining = timeRemaining;\n              setTimeRemaining(currentTimeRemaining);\n            }\n            return;\n          }\n\n          if (timeRemaining < ONE_HOUR) {\n            const currentMinutesRemaining = Math.ceil(\n              currentTimeRemaining / ONE_MINUTE\n            );\n            const minutesRemaining = Math.ceil(timeRemaining / ONE_MINUTE);\n            const delta = minutesRemaining - currentMinutesRemaining;\n            if (delta < 0 || delta > 2) {\n              currentTimeRemaining = timeRemaining;\n              setTimeRemaining(currentTimeRemaining);\n            }\n            return;\n          }\n\n          // Hours remaining...\n          currentTimeRemaining = timeRemaining;\n          setTimeRemaining(currentTimeRemaining);\n        }\n      };\n\n      const progressCallback = (\n        progressEvent: DicomFileUploaderProgressEvent\n      ) => {\n        updateProgress(progressEvent.percentComplete);\n      };\n\n      // Use the uploader promise to flag any error and count the number of\n      // uploads completed.\n      fileUploader\n        .load()\n        .catch((rejection: UploadRejection) => {\n          if (rejection.status === UploadStatus.Failed) {\n            setNumFails(numFails => numFails + 1);\n          }\n        })\n        .finally(() => {\n          // If any error occurred, the percent complete progress stops firing\n          // but this call to updateProgress nicely puts all finished uploads at 100%.\n          updateProgress(100);\n          setNumFilesCompleted(numCompleted => numCompleted + 1);\n        });\n\n      return fileUploader.subscribe(EVENTS.PROGRESS, progressCallback);\n    });\n    return () => {\n      subscriptions.forEach(subscription => subscription.unsubscribe());\n    };\n  }, []);\n\n  const cancelAllUploads = useCallback(async () => {\n    for (const dicomFileUploader of dicomFileUploaderArr) {\n      // Important: we need a non-blocking way to cancel every upload,\n      // otherwise the UI will freeze and the user will not be able\n      // to interact with the app and progress will not be updated.\n      const promise = new Promise<void>((resolve, reject) => {\n        setTimeout(() => {\n          dicomFileUploader.cancel();\n          resolve();\n        }, 0);\n      });\n    }\n  }, []);\n\n  const getFormattedTimeRemaining = useCallback((): string => {\n    if (timeRemaining == null) {\n      return '';\n    }\n\n    if (timeRemaining < ONE_MINUTE) {\n      const secondsRemaining = Math.ceil(timeRemaining / ONE_SECOND);\n      return `${secondsRemaining} ${\n        secondsRemaining === 1 ? 'second' : 'seconds'\n      }`;\n    }\n\n    if (timeRemaining < ONE_HOUR) {\n      const minutesRemaining = Math.ceil(timeRemaining / ONE_MINUTE);\n      return `${minutesRemaining} ${\n        minutesRemaining === 1 ? 'minute' : 'minutes'\n      }`;\n    }\n\n    const hoursRemaining = Math.ceil(timeRemaining / ONE_HOUR);\n    return `${hoursRemaining} ${hoursRemaining === 1 ? 'hour' : 'hours'}`;\n  }, [timeRemaining]);\n\n  const getPercentCompleteRounded = useCallback(\n    () => Math.min(100, Math.round(percentComplete)),\n    [percentComplete]\n  );\n\n  /**\n   * Determines if the progress bar should show the infinite animation or not.\n   * Show the infinite animation for progress less than 1% AND if less than\n   * one pixel of the progress bar would be displayed.\n   */\n  const showInfiniteProgressBar = useCallback((): boolean => {\n    return (\n      getPercentCompleteRounded() < 1 &&\n      (progressBarContainerRef?.current?.offsetWidth ?? 0) *\n        (percentComplete / 100) <\n        1\n    );\n  }, [getPercentCompleteRounded, percentComplete]);\n\n  /**\n   * Gets the css style for the 'n of m' (files completed) text. The only css attribute\n   * of the style is width such that the 'n of m' is always a fixed width and thus\n   * as each file completes uploading the text on screen does not constantly shift\n   * left and right.\n   */\n  const getNofMFilesStyle = useCallback(() => {\n    // the number of digits accounts for the digits being on each side of the ' of '\n    const numDigits = 2 * dicomFileUploaderArr.length.toString().length;\n    // the number of digits + 2 spaces and 2 characters for ' of '\n    const numChars = numDigits + 4;\n    return { width: `${numChars}ch` };\n  }, []);\n\n  const getNumCompletedAndTimeRemainingComponent = (): ReactElement => {\n    return (\n      <div className=\"text-lg px-1 pb-4 h-14 flex bg-primary-dark items-center\">\n        {numFilesCompleted === dicomFileUploaderArr.length ? (\n          <>\n            <span className={NO_WRAP_ELLIPSIS_CLASS_NAMES}>{`${\n              dicomFileUploaderArr.length\n            } ${\n              dicomFileUploaderArr.length > 1 ? 'files' : 'file'\n            } completed.`}</span>\n            <Button\n              variant=\"contained\"\n              color=\"primary\"\n              disabled={false}\n              className=\"ml-auto\"\n              onClick={onComplete}\n            >\n              {'Close'}\n            </Button>\n          </>\n        ) : (\n          <>\n            <span\n              style={getNofMFilesStyle()}\n              className={classNames(NO_WRAP_ELLIPSIS_CLASS_NAMES, 'text-end')}\n            >\n              {`${numFilesCompleted} of ${dicomFileUploaderArr.length}`}&nbsp;\n            </span>\n            <span className={NO_WRAP_ELLIPSIS_CLASS_NAMES}>\n              {' files completed.'}&nbsp;\n            </span>\n            <span className={NO_WRAP_ELLIPSIS_CLASS_NAMES}>\n              {timeRemaining\n                ? `Less than ${getFormattedTimeRemaining()} remaining. `\n                : ''}\n            </span>\n            <span\n              className={classNames(\n                NO_WRAP_ELLIPSIS_CLASS_NAMES,\n                'cursor-pointer text-primary-active hover:text-primary-light active:text-aqua-pale ml-auto'\n              )}\n              onClick={cancelAllUploads}\n            >\n              Cancel All Uploads\n            </span>\n          </>\n        )}\n      </div>\n    );\n  };\n\n  const getShowFailedOnlyIconComponent = (): ReactElement => {\n    return (\n      <div className=\"ml-auto flex justify-center w-6\">\n        {numFails > 0 && (\n          <div\n            onClick={() =>\n              setShowFailedOnly(currentShowFailedOnly => !currentShowFailedOnly)\n            }\n          >\n            <Icon className=\"cursor-pointer\" name=\"icon-status-alert\"></Icon>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const getPercentCompleteComponent = (): ReactElement => {\n    return (\n      <div className=\"overflow-y-scroll ohif-scrollbar px-2 border-b border-secondary-light\">\n        <div className=\"flex w-full p-2.5 items-center min-h-14\">\n          {numFilesCompleted === dicomFileUploaderArr.length ? (\n            <>\n              <div className=\"text-xl text-primary-light\">\n                {numFails > 0\n                  ? `Completed with ${numFails} ${\n                      numFails > 1 ? 'errors' : 'error'\n                    }!`\n                  : 'Completed!'}\n              </div>\n              {getShowFailedOnlyIconComponent()}\n            </>\n          ) : (\n            <>\n              <div ref={progressBarContainerRef} className=\"flex-grow\">\n                <ProgressLoadingBar\n                  progress={\n                    showInfiniteProgressBar()\n                      ? undefined\n                      : Math.min(100, percentComplete)\n                  }\n                ></ProgressLoadingBar>\n              </div>\n              <div className=\"w-24 ml-1 flex items-center\">\n                <div className=\"w-10 text-right\">{`${getPercentCompleteRounded()}%`}</div>\n                {getShowFailedOnlyIconComponent()}\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"flex flex-col grow\">\n      {getNumCompletedAndTimeRemainingComponent()}\n      <div className=\"flex flex-col bg-black text-lg overflow-hidden grow\">\n        {getPercentCompleteComponent()}\n        <div className=\"overflow-y-scroll ohif-scrollbar px-2 grow h-1\">\n          {dicomFileUploaderArr\n            .filter(\n              dicomFileUploader =>\n                !showFailedOnly ||\n                dicomFileUploader.getStatus() === UploadStatus.Failed\n            )\n            .map(dicomFileUploader => (\n              <DicomUploadProgressItem\n                key={dicomFileUploader.getFileId()}\n                dicomFileUploader={dicomFileUploader}\n              />\n            ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nDicomUploadProgress.propTypes = {\n  dicomFileUploaderArr: PropTypes.arrayOf(\n    PropTypes.instanceOf(DicomFileUploader)\n  ).isRequired,\n  onComplete: PropTypes.func.isRequired,\n};\n\nexport default DicomUploadProgress;\n","import React, {\n  ReactElement,\n  memo,\n  useCallback,\n  useEffect,\n  useState,\n} from 'react';\nimport PropTypes from 'prop-types';\nimport DicomFileUploader, {\n  DicomFileUploaderProgressEvent,\n  EVENTS,\n  UploadRejection,\n  UploadStatus,\n} from '../../utils/DicomFileUploader';\nimport { Icon } from '@ohif/ui';\n\ntype DicomUploadProgressItemProps = {\n  dicomFileUploader: DicomFileUploader;\n};\n\n// eslint-disable-next-line react/display-name\nconst DicomUploadProgressItem = memo(\n  ({ dicomFileUploader }: DicomUploadProgressItemProps): ReactElement => {\n    const [percentComplete, setPercentComplete] = useState(\n      dicomFileUploader.getPercentComplete()\n    );\n    const [failedReason, setFailedReason] = useState('');\n    const [status, setStatus] = useState(dicomFileUploader.getStatus());\n\n    console.info(`${dicomFileUploader.getFileId()}`);\n    const isComplete = useCallback(() => {\n      return (\n        status === UploadStatus.Failed ||\n        status === UploadStatus.Cancelled ||\n        status === UploadStatus.Success\n      );\n    }, [status]);\n\n    useEffect(() => {\n      const progressSubscription = dicomFileUploader.subscribe(\n        EVENTS.PROGRESS,\n        (dicomFileUploaderProgressEvent: DicomFileUploaderProgressEvent) => {\n          setPercentComplete(dicomFileUploaderProgressEvent.percentComplete);\n        }\n      );\n\n      dicomFileUploader\n        .load()\n        .catch((reason: UploadRejection) => {\n          setStatus(reason.status);\n          setFailedReason(reason.message ?? '');\n        })\n        .finally(() => setStatus(dicomFileUploader.getStatus()));\n\n      return () => progressSubscription.unsubscribe();\n    }, []);\n\n    const cancelUpload = useCallback(() => {\n      dicomFileUploader.cancel();\n    }, []);\n\n    const getStatusIcon = (): ReactElement => {\n      switch (dicomFileUploader.getStatus()) {\n        case UploadStatus.Success:\n          return (\n            <Icon name=\"status-tracked\" className=\"text-primary-light\"></Icon>\n          );\n        case UploadStatus.InProgress:\n          return <Icon name=\"icon-transferring\"></Icon>;\n        case UploadStatus.Failed:\n          return <Icon name=\"icon-alert-small\"></Icon>;\n        case UploadStatus.Cancelled:\n          return <Icon name=\"icon-alert-outline\"></Icon>;\n        default:\n          return <></>;\n      }\n    };\n\n    return (\n      <div className=\"flex w-full p-2.5 text-lg min-h-14 items-center border-b border-secondary-light overflow-hidden\">\n        <div className=\"flex flex-col gap-1 self-top w-0 grow shrink\">\n          <div className=\"flex gap-4\">\n            <div className=\"flex w-6 justify-center items-center shrink-0\">\n              {getStatusIcon()}\n            </div>\n            <div className=\"text-ellipsis whitespace-nowrap overflow-hidden\">\n              {dicomFileUploader.getFileName()}\n            </div>\n          </div>\n          {failedReason && <div className=\"pl-10\">{failedReason}</div>}\n        </div>\n        <div className=\"w-24 flex items-center\">\n          {!isComplete() && (\n            <>\n              {dicomFileUploader.getStatus() === UploadStatus.InProgress && (\n                <div className=\"w-10 text-right\">{percentComplete}%</div>\n              )}\n              <div className=\"flex cursor-pointer ml-auto\">\n                <Icon\n                  className=\"self-center text-primary-active\"\n                  name=\"close\"\n                  onClick={cancelUpload}\n                />\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\n\nDicomUploadProgressItem.propTypes = {\n  dicomFileUploader: PropTypes.instanceOf(DicomFileUploader).isRequired,\n};\n\nexport default DicomUploadProgressItem;\n","import { Enums } from '@cornerstonejs/tools';\nimport { toolNames } from './initCornerstoneTools';\nimport DicomUpload from './components/DicomUpload/DicomUpload';\n\nconst tools = {\n  active: [\n    {\n      toolName: toolNames.WindowLevel,\n      bindings: [{ mouseButton: Enums.MouseBindings.Primary }],\n    },\n    {\n      toolName: toolNames.Pan,\n      bindings: [{ mouseButton: Enums.MouseBindings.Auxiliary }],\n    },\n    {\n      toolName: toolNames.Zoom,\n      bindings: [{ mouseButton: Enums.MouseBindings.Secondary }],\n    },\n    { toolName: toolNames.StackScrollMouseWheel, bindings: [] },\n  ],\n  enabled: [{ toolName: toolNames.SegmentationDisplay }],\n};\n\nfunction getCustomizationModule() {\n  return [\n    {\n      name: 'cornerstoneDicomUploadComponent',\n      value: {\n        id: 'dicomUploadComponent',\n        component: DicomUpload,\n      },\n    },\n    {\n      name: 'default',\n      value: [\n        {\n          id: 'cornerstone.overlayViewportTools',\n          tools,\n        },\n      ],\n    },\n  ];\n}\n\nexport default getCustomizationModule;\n","import { Types } from '@ohif/core';\n\nconst mpr: Types.HangingProtocol.Protocol = {\n  id: 'mpr',\n  name: 'Multi-Planar Reconstruction',\n  locked: true,\n  hasUpdatedPriorsInformation: false,\n  createdDate: '2021-02-23',\n  modifiedDate: '2023-04-03',\n  availableTo: {},\n  editableBy: {},\n  // Unknown number of priors referenced - so just match any study\n  numberOfPriorsReferenced: 0,\n  protocolMatchingRules: [],\n  imageLoadStrategy: 'nth',\n  callbacks: {\n    // Switches out of MPR mode when the layout change button is used\n    onLayoutChange: [\n      {\n        commandName: 'toggleHangingProtocol',\n        commandOptions: { protocolId: 'mpr' },\n        context: 'DEFAULT',\n      },\n    ],\n    // Turns off crosshairs when switching out of MPR mode\n    onProtocolExit: [\n      {\n        commandName: 'toolbarServiceRecordInteraction',\n        commandOptions: {\n          interactionType: 'tool',\n          commands: [\n            {\n              commandOptions: {\n                toolName: 'WindowLevel',\n              },\n              context: 'CORNERSTONE',\n            },\n          ],\n        },\n      },\n    ],\n  },\n  displaySetSelectors: {\n    activeDisplaySet: {\n      seriesMatchingRules: [\n        {\n          weight: 1,\n          attribute: 'isReconstructable',\n          constraint: {\n            equals: {\n              value: true,\n            },\n          },\n          required: true,\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'MPR 1x3',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 3,\n          layoutOptions: [\n            {\n              x: 0,\n              y: 0,\n              width: 1 / 3,\n              height: 1,\n            },\n            {\n              x: 1 / 3,\n              y: 0,\n              width: 1 / 3,\n              height: 1,\n            },\n            {\n              x: 2 / 3,\n              y: 0,\n              width: 1 / 3,\n              height: 1,\n            },\n          ],\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'axial',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'activeDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'sagittal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'activeDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'coronal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'activeDisplaySet',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nconst mprAnd3DVolumeViewport = {\n  id: 'mprAnd3DVolumeViewport',\n  locked: true,\n  hasUpdatedPriorsInformation: false,\n  name: 'mpr',\n  createdDate: '2023-03-15T10:29:44.894Z',\n  modifiedDate: '2023-03-15T10:29:44.894Z',\n  availableTo: {},\n  editableBy: {},\n  protocolMatchingRules: [],\n  imageLoadStrategy: 'interleaveCenter',\n  displaySetSelectors: {\n    mprDisplaySet: {\n      seriesMatchingRules: [\n        {\n          weight: 1,\n          attribute: 'isReconstructable',\n          constraint: {\n            equals: {\n              value: true,\n            },\n          },\n          required: true,\n        },\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: {\n              value: 'CT',\n            },\n          },\n          required: true,\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      id: 'mpr3Stage',\n      name: 'mpr',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 2,\n          columns: 2,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'axial',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'volume3d',\n            viewportType: 'volume3d',\n            orientation: 'coronal',\n            customViewportProps: {\n              hideOverlays: true,\n            },\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n              options: {\n                displayPreset: 'CT-Bone',\n              },\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'coronal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n            },\n          ],\n        },\n        {\n          viewportOptions: {\n            toolGroupId: 'mpr',\n            viewportType: 'volume',\n            orientation: 'sagittal',\n            initialImageOptions: {\n              preset: 'middle',\n            },\n            syncGroups: [\n              {\n                type: 'voi',\n                id: 'mpr',\n                source: true,\n                target: true,\n              },\n            ],\n          },\n          displaySets: [\n            {\n              id: 'mprDisplaySet',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: mpr.id,\n      protocol: mpr,\n    },\n    {\n      name: mprAnd3DVolumeViewport.id,\n      protocol: mprAnd3DVolumeViewport,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\n","import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nexport { id };\n","import React from 'react';\nimport * as cornerstone from '@cornerstonejs/core';\nimport * as cornerstoneTools from '@cornerstonejs/tools';\nimport {\n  Enums as cs3DEnums,\n  imageLoadPoolManager,\n  imageRetrievalPoolManager,\n} from '@cornerstonejs/core';\nimport { Enums as cs3DToolsEnums } from '@cornerstonejs/tools';\nimport { ServicesManager, Types } from '@ohif/core';\n\nimport init from './init';\nimport getCustomizationModule from './getCustomizationModule';\nimport getCommandsModule from './commandsModule';\nimport getHangingProtocolModule from './getHangingProtocolModule';\nimport ToolGroupService from './services/ToolGroupService';\nimport SyncGroupService from './services/SyncGroupService';\nimport SegmentationService from './services/SegmentationService';\nimport CornerstoneCacheService from './services/CornerstoneCacheService';\nimport CornerstoneViewportService from './services/ViewportService/CornerstoneViewportService';\nimport * as CornerstoneExtensionTypes from './types';\n\nimport { toolNames } from './initCornerstoneTools';\nimport { getEnabledElement, reset as enabledElementReset } from './state';\nimport dicomLoaderService from './utils/dicomLoaderService';\nimport getActiveViewportEnabledElement from './utils/getActiveViewportEnabledElement';\nimport { registerColormap } from './utils/colormap/transferFunctionHelpers';\n\nimport { id } from './id';\nimport * as csWADOImageLoader from './initWADOImageLoader.js';\nimport { measurementMappingUtils } from './utils/measurementServiceMappings';\nimport type { PublicViewportOptions } from './services/ViewportService/Viewport';\n\nconst Component = React.lazy(() => {\n  return import(\n    /* webpackPrefetch: true */ './Viewport/OHIFCornerstoneViewport'\n  );\n});\n\nconst OHIFCornerstoneViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n *\n */\nconst cornerstoneExtension: Types.Extensions.Extension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n\n  onModeExit: (): void => {\n    // Empty out the image load and retrieval pools to prevent memory leaks\n    // on the mode exits\n    Object.values(cs3DEnums.RequestType).forEach(type => {\n      imageLoadPoolManager.clearRequestStack(type);\n      imageRetrievalPoolManager.clearRequestStack(type);\n    });\n\n    csWADOImageLoader.destroy();\n    enabledElementReset();\n  },\n\n  /**\n   * Register the Cornerstone 3D services and set them up for use.\n   *\n   * @param configuration.csToolsConfig - Passed directly to `initCornerstoneTools`\n   */\n  preRegistration: function (\n    props: Types.Extensions.ExtensionParams\n  ): Promise<void> {\n    const { servicesManager } = props;\n    servicesManager.registerService(CornerstoneViewportService.REGISTRATION);\n    servicesManager.registerService(ToolGroupService.REGISTRATION);\n    servicesManager.registerService(SyncGroupService.REGISTRATION);\n    servicesManager.registerService(SegmentationService.REGISTRATION);\n    servicesManager.registerService(CornerstoneCacheService.REGISTRATION);\n\n    return init.call(this, props);\n  },\n\n  getHangingProtocolModule,\n  getViewportModule({ servicesManager, commandsManager }) {\n    const ExtendedOHIFCornerstoneViewport = props => {\n      // const onNewImageHandler = jumpData => {\n      //   commandsManager.runCommand('jumpToImage', jumpData);\n      // };\n      const { toolbarService } = (servicesManager as ServicesManager).services;\n\n      return (\n        <OHIFCornerstoneViewport\n          {...props}\n          toolbarService={toolbarService}\n          servicesManager={servicesManager}\n          commandsManager={commandsManager}\n        />\n      );\n    };\n\n    return [\n      {\n        name: 'cornerstone',\n        component: ExtendedOHIFCornerstoneViewport,\n      },\n    ];\n  },\n  getCommandsModule,\n  getCustomizationModule,\n  getUtilityModule({ servicesManager }) {\n    return [\n      {\n        name: 'common',\n        exports: {\n          getCornerstoneLibraries: () => {\n            return { cornerstone, cornerstoneTools };\n          },\n          getEnabledElement,\n          dicomLoaderService,\n        },\n      },\n      {\n        name: 'core',\n        exports: {\n          Enums: cs3DEnums,\n        },\n      },\n      {\n        name: 'tools',\n        exports: {\n          toolNames,\n          Enums: cs3DToolsEnums,\n        },\n      },\n    ];\n  },\n};\n\nexport type { PublicViewportOptions };\nexport { measurementMappingUtils, CornerstoneExtensionTypes, toolNames , getActiveViewportEnabledElement};\nexport default cornerstoneExtension;\n","import OHIF, { Types } from '@ohif/core';\nimport React from 'react';\n\nimport * as cornerstone from '@cornerstonejs/core';\nimport * as cornerstoneTools from '@cornerstonejs/tools';\nimport {\n  init as cs3DInit,\n  eventTarget,\n  EVENTS,\n  metaData,\n  volumeLoader,\n  imageLoadPoolManager,\n  Settings,\n  utilities as csUtilities,\n} from '@cornerstonejs/core';\nimport { Enums, utilities, ReferenceLinesTool } from '@cornerstonejs/tools';\nimport { cornerstoneStreamingImageVolumeLoader } from '@cornerstonejs/streaming-image-volume-loader';\n\nimport initWADOImageLoader from './initWADOImageLoader';\nimport initCornerstoneTools from './initCornerstoneTools';\n\nimport { connectToolsToMeasurementService } from './initMeasurementService';\nimport initCineService from './initCineService';\nimport interleaveCenterLoader from './utils/interleaveCenterLoader';\nimport nthLoader from './utils/nthLoader';\nimport interleaveTopToBottom from './utils/interleaveTopToBottom';\nimport initContextMenu from './initContextMenu';\nimport initDoubleClick from './initDoubleClick';\n\n// TODO: Cypress tests are currently grabbing this from the window?\nwindow.cornerstone = cornerstone;\nwindow.cornerstoneTools = cornerstoneTools;\n/**\n *\n */\nexport default async function init({\n  servicesManager,\n  commandsManager,\n  extensionManager,\n  configuration,\n  appConfig,\n}: Types.Extensions.ExtensionParams): Promise<void> {\n  await cs3DInit();\n\n  // For debugging e2e tests that are failing on CI\n  cornerstone.setUseCPURendering(Boolean(appConfig.useCPURendering));\n  cornerstone.setConfiguration({\n    ...cornerstone.getConfiguration(),\n    rendering: {\n      ...cornerstone.getConfiguration().rendering,\n      strictZSpacingForVolumeViewport:\n        appConfig.strictZSpacingForVolumeViewport,\n    },\n  });\n\n  // For debugging large datasets\n  const MAX_CACHE_SIZE_1GB = 1073741824;\n  const maxCacheSize = appConfig.maxCacheSize;\n  cornerstone.cache.setMaxCacheSize(\n    maxCacheSize ? maxCacheSize : MAX_CACHE_SIZE_1GB\n  );\n\n  initCornerstoneTools();\n\n  Settings.getRuntimeSettings().set(\n    'useCursors',\n    Boolean(appConfig.useCursors)\n  );\n\n  const {\n    userAuthenticationService,\n    measurementService,\n    customizationService,\n    displaySetService,\n    uiDialogService,\n    uiModalService,\n    uiNotificationService,\n    cineService,\n    cornerstoneViewportService,\n    hangingProtocolService,\n    toolGroupService,\n    viewportGridService,\n    stateSyncService,\n  } = servicesManager.services;\n\n  window.services = servicesManager.services;\n  window.extensionManager = extensionManager;\n  window.commandsManager = commandsManager;\n\n  if (\n    appConfig.showWarningMessageForCrossOrigin &&\n    !window.crossOriginIsolated\n  ) {\n    uiNotificationService.show({\n      title: 'Cross Origin Isolation',\n      message:\n        'Cross Origin Isolation is not enabled, volume rendering will not work (e.g., MPR)',\n      type: 'warning',\n    });\n  }\n\n  if (\n    appConfig.showCPUFallbackMessage &&\n    cornerstone.getShouldUseCPURendering()\n  ) {\n    _showCPURenderingModal(uiModalService, hangingProtocolService);\n  }\n\n  // Stores a map from `lutPresentationId` to a Presentation object so that\n  // an OHIFCornerstoneViewport can be redisplayed with the same LUT\n  stateSyncService.register('lutPresentationStore', { clearOnModeExit: true });\n\n  // Stores a map from `positionPresentationId` to a Presentation object so that\n  // an OHIFCornerstoneViewport can be redisplayed with the same position\n  stateSyncService.register('positionPresentationStore', {\n    clearOnModeExit: true,\n  });\n\n  // Stores the entire ViewportGridService getState when toggling to one up\n  // (e.g. via a double click) so that it can be restored when toggling back.\n  stateSyncService.register('toggleOneUpViewportGridStore', {\n    clearOnModeExit: true,\n  });\n\n  const labelmapRepresentation =\n    cornerstoneTools.Enums.SegmentationRepresentations.Labelmap;\n\n  cornerstoneTools.segmentation.config.setGlobalRepresentationConfig(\n    labelmapRepresentation,\n    {\n      fillAlpha: 0.3,\n      fillAlphaInactive: 0.2,\n      outlineOpacity: 1,\n      outlineOpacityInactive: 0.65,\n    }\n  );\n\n  const metadataProvider = OHIF.classes.MetadataProvider;\n\n  volumeLoader.registerVolumeLoader(\n    'cornerstoneStreamingImageVolume',\n    cornerstoneStreamingImageVolumeLoader\n  );\n\n  hangingProtocolService.registerImageLoadStrategy(\n    'interleaveCenter',\n    interleaveCenterLoader\n  );\n  hangingProtocolService.registerImageLoadStrategy(\n    'interleaveTopToBottom',\n    interleaveTopToBottom\n  );\n  hangingProtocolService.registerImageLoadStrategy('nth', nthLoader);\n\n  // add metadata providers\n  metaData.addProvider(\n    csUtilities.calibratedPixelSpacingMetadataProvider.get.bind(\n      csUtilities.calibratedPixelSpacingMetadataProvider\n    )\n  ); // this provider is required for Calibration tool\n  metaData.addProvider(metadataProvider.get.bind(metadataProvider), 9999);\n\n  imageLoadPoolManager.maxNumRequests = {\n    interaction: appConfig?.maxNumRequests?.interaction || 100,\n    thumbnail: appConfig?.maxNumRequests?.thumbnail || 75,\n    prefetch: appConfig?.maxNumRequests?.prefetch || 10,\n  };\n\n  initWADOImageLoader(userAuthenticationService, appConfig);\n\n  /* Measurement Service */\n  this.measurementServiceSource = connectToolsToMeasurementService(\n    servicesManager\n  );\n\n  initCineService(cineService);\n\n  // When a custom image load is performed, update the relevant viewports\n  hangingProtocolService.subscribe(\n    hangingProtocolService.EVENTS.CUSTOM_IMAGE_LOAD_PERFORMED,\n    volumeInputArrayMap => {\n      for (const entry of volumeInputArrayMap.entries()) {\n        const [viewportId, volumeInputArray] = entry;\n        const viewport = cornerstoneViewportService.getCornerstoneViewport(\n          viewportId\n        );\n\n        const ohifViewport = cornerstoneViewportService.getViewportInfo(\n          viewportId\n        );\n\n        const {\n          lutPresentationStore,\n          positionPresentationStore,\n        } = stateSyncService.getState();\n        const { presentationIds } = ohifViewport.getViewportOptions();\n        const presentations = {\n          positionPresentation:\n            positionPresentationStore[presentationIds?.positionPresentationId],\n          lutPresentation:\n            lutPresentationStore[presentationIds?.lutPresentationId],\n        };\n\n        cornerstoneViewportService.setVolumesForViewport(\n          viewport,\n          volumeInputArray,\n          presentations\n        );\n      }\n    }\n  );\n\n  initContextMenu({\n    cornerstoneViewportService,\n    customizationService,\n    commandsManager,\n  });\n\n  initDoubleClick({\n    customizationService,\n    commandsManager,\n  });\n\n  const newStackCallback = evt => {\n    const { element } = evt.detail;\n    utilities.stackPrefetch.enable(element);\n  };\n\n  const resetCrosshairs = evt => {\n    const { element } = evt.detail;\n    const { viewportId, renderingEngineId } = cornerstone.getEnabledElement(\n      element\n    );\n\n    const toolGroup = cornerstoneTools.ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    if (!toolGroup || !toolGroup._toolInstances?.['Crosshairs']) {\n      return;\n    }\n\n    const mode = toolGroup._toolInstances['Crosshairs'].mode;\n\n    if (mode === Enums.ToolModes.Active) {\n      toolGroup.setToolActive('Crosshairs');\n    } else if (mode === Enums.ToolModes.Passive) {\n      toolGroup.setToolPassive('Crosshairs');\n    } else if (mode === Enums.ToolModes.Enabled) {\n      toolGroup.setToolEnabled('Crosshairs');\n    }\n  };\n\n  function elementEnabledHandler(evt) {\n    const { element } = evt.detail;\n    element.addEventListener(EVENTS.CAMERA_RESET, resetCrosshairs);\n\n    eventTarget.addEventListener(\n      EVENTS.STACK_VIEWPORT_NEW_STACK,\n      newStackCallback\n    );\n  }\n\n  function elementDisabledHandler(evt) {\n    const { element } = evt.detail;\n\n    element.removeEventListener(EVENTS.CAMERA_RESET, resetCrosshairs);\n\n    // TODO - consider removing the callback when all elements are gone\n    // eventTarget.removeEventListener(\n    //   EVENTS.STACK_VIEWPORT_NEW_STACK,\n    //   newStackCallback\n    // );\n  }\n\n  eventTarget.addEventListener(\n    EVENTS.ELEMENT_ENABLED,\n    elementEnabledHandler.bind(null)\n  );\n\n  eventTarget.addEventListener(\n    EVENTS.ELEMENT_DISABLED,\n    elementDisabledHandler.bind(null)\n  );\n\n  viewportGridService.subscribe(\n    viewportGridService.EVENTS.ACTIVE_VIEWPORT_INDEX_CHANGED,\n    ({ viewportIndex, viewportId }) => {\n      viewportId = viewportId || `viewport-${viewportIndex}`;\n      const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\n\n      if (!toolGroup || !toolGroup._toolInstances?.['ReferenceLines']) {\n        return;\n      }\n\n      // check if reference lines are active\n      const referenceLinesEnabled =\n        toolGroup._toolInstances['ReferenceLines'].mode ===\n        Enums.ToolModes.Enabled;\n\n      if (!referenceLinesEnabled) {\n        return;\n      }\n\n      toolGroup.setToolConfiguration(\n        ReferenceLinesTool.toolName,\n        {\n          sourceViewportId: viewportId,\n        },\n        true // overwrite\n      );\n\n      // make sure to set it to enabled again since we want to recalculate\n      // the source-target lines\n      toolGroup.setToolEnabled(ReferenceLinesTool.toolName);\n    }\n  );\n}\n\nfunction CPUModal() {\n  return (\n    <div>\n      <p>\n        Your computer does not have enough GPU power to support the default GPU\n        rendering mode. OHIF has switched to CPU rendering mode. Please note\n        that CPU rendering does not support all features such as Volume\n        Rendering, Multiplanar Reconstruction, and Segmentation Overlays.\n      </p>\n    </div>\n  );\n}\n\nfunction _showCPURenderingModal(uiModalService, hangingProtocolService) {\n  const callback = progress => {\n    if (progress === 100) {\n      uiModalService.show({\n        content: CPUModal,\n        title: 'OHIF Fell Back to CPU Rendering',\n      });\n\n      return true;\n    }\n  };\n\n  const { unsubscribe } = hangingProtocolService.subscribe(\n    hangingProtocolService.EVENTS.PROTOCOL_CHANGED,\n    () => {\n      const done = callback(100);\n\n      if (done) {\n        unsubscribe();\n      }\n    }\n  );\n}\n","import { utilities } from '@cornerstonejs/tools';\n\nfunction initCineService(cineService) {\n  const playClip = (element, playClipOptions) => {\n    return utilities.cine.playClip(element, playClipOptions);\n  };\n\n  const stopClip = element => {\n    return utilities.cine.stopClip(element);\n  };\n\n  cineService.setServiceImplementation({ playClip, stopClip });\n}\n\nexport default initCineService;\n","import { eventTarget, EVENTS } from '@cornerstonejs/core';\nimport { Enums } from '@cornerstonejs/tools';\nimport { setEnabledElement } from './state';\nimport { findNearbyToolData } from './utils/findNearbyToolData';\n\nconst cs3DToolsEvents = Enums.Events;\n\nconst DEFAULT_CONTEXT_MENU_CLICKS = {\n  button1: {\n    commands: [\n      {\n        commandName: 'closeContextMenu',\n      },\n    ],\n  },\n  button3: {\n    commands: [\n      {\n        commandName: 'showCornerstoneContextMenu',\n        commandOptions: {\n          menuId: 'measurementsContextMenu',\n        },\n      },\n    ],\n  },\n};\n\n/**\n * Generates a name, consisting of:\n *    * alt when the alt key is down\n *    * ctrl when the cctrl key is down\n *    * shift when the shift key is down\n *    * 'button' followed by the button number (1 left, 3 right etc)\n */\nfunction getEventName(evt) {\n  const button = evt.detail.event.which;\n  const nameArr = [];\n  if (evt.detail.event.altKey) nameArr.push('alt');\n  if (evt.detail.event.ctrlKey) nameArr.push('ctrl');\n  if (evt.detail.event.shiftKey) nameArr.push('shift');\n  nameArr.push('button');\n  nameArr.push(button);\n  return nameArr.join('');\n}\n\nfunction initContextMenu({\n  cornerstoneViewportService,\n  customizationService,\n  commandsManager,\n}): void {\n  /*\n   * Run the commands associated with the given button press,\n   * defaults on button1 and button2\n   */\n  const cornerstoneViewportHandleEvent = (name, evt) => {\n    const customizations =\n      customizationService.get('cornerstoneViewportClickCommands') ||\n      DEFAULT_CONTEXT_MENU_CLICKS;\n    const toRun = customizations[name];\n    console.log('initContextMenu::cornerstoneViewportHandleEvent', name, toRun);\n    const options = {\n      nearbyToolData: findNearbyToolData(commandsManager, evt),\n      event: evt,\n    };\n    commandsManager.run(toRun, options);\n  };\n\n  const cornerstoneViewportHandleClick = evt => {\n    const name = getEventName(evt);\n    cornerstoneViewportHandleEvent(name, evt);\n  };\n\n  function elementEnabledHandler(evt) {\n    const { viewportId, element } = evt.detail;\n    const viewportInfo = cornerstoneViewportService.getViewportInfo(viewportId);\n    if (!viewportInfo) return;\n    const viewportIndex = viewportInfo.getViewportIndex();\n    // TODO check update upstream\n    setEnabledElement(viewportIndex, element);\n\n    element.addEventListener(\n      cs3DToolsEvents.MOUSE_CLICK,\n      cornerstoneViewportHandleClick\n    );\n  }\n\n  function elementDisabledHandler(evt) {\n    const { element } = evt.detail;\n\n    element.removeEventListener(\n      cs3DToolsEvents.MOUSE_CLICK,\n      cornerstoneViewportHandleClick\n    );\n  }\n\n  eventTarget.addEventListener(\n    EVENTS.ELEMENT_ENABLED,\n    elementEnabledHandler.bind(null)\n  );\n\n  eventTarget.addEventListener(\n    EVENTS.ELEMENT_DISABLED,\n    elementDisabledHandler.bind(null)\n  );\n}\n\nexport default initContextMenu;\n","import {\n  PanTool,\n  WindowLevelTool,\n  StackScrollTool,\n  StackScrollMouseWheelTool,\n  ZoomTool,\n  VolumeRotateMouseWheelTool,\n  MIPJumpToClickTool,\n  LengthTool,\n  RectangleROITool,\n  EllipticalROITool,\n  CircleROITool,\n  BidirectionalTool,\n  ArrowAnnotateTool,\n  DragProbeTool,\n  ProbeTool,\n  AngleTool,\n  CobbAngleTool,\n  PlanarFreehandROITool,\n  MagnifyTool,\n  CrosshairsTool,\n  SegmentationDisplayTool,\n  init,\n  addTool,\n  annotation,\n  ReferenceLinesTool,\n  TrackballRotateTool,\n} from '@cornerstonejs/tools';\n\nimport CalibrationLineTool from './tools/CalibrationLineTool';\n\nexport default function initCornerstoneTools(configuration = {}) {\n  CrosshairsTool.isAnnotation = false;\n  ReferenceLinesTool.isAnnotation = false;\n\n  init(configuration);\n  addTool(PanTool);\n  addTool(WindowLevelTool);\n  addTool(StackScrollMouseWheelTool);\n  addTool(StackScrollTool);\n  addTool(ZoomTool);\n  addTool(ProbeTool);\n  addTool(VolumeRotateMouseWheelTool);\n  addTool(MIPJumpToClickTool);\n  addTool(LengthTool);\n  addTool(RectangleROITool);\n  addTool(EllipticalROITool);\n  addTool(CircleROITool);\n  addTool(BidirectionalTool);\n  addTool(ArrowAnnotateTool);\n  addTool(DragProbeTool);\n  addTool(AngleTool);\n  addTool(CobbAngleTool);\n  addTool(PlanarFreehandROITool);\n  addTool(MagnifyTool);\n  addTool(CrosshairsTool);\n  addTool(SegmentationDisplayTool);\n  addTool(ReferenceLinesTool);\n  addTool(CalibrationLineTool);\n  addTool(TrackballRotateTool);\n\n  // Modify annotation tools to use dashed lines on SR\n  const annotationStyle = {\n    textBoxFontSize: '15px',\n    lineWidth: '1.5',\n  };\n\n  const defaultStyles = annotation.config.style.getDefaultToolStyles();\n  annotation.config.style.setDefaultToolStyles({\n    global: {\n      ...defaultStyles.global,\n      ...annotationStyle,\n    },\n  });\n}\n\nconst toolNames = {\n  Pan: PanTool.toolName,\n  ArrowAnnotate: ArrowAnnotateTool.toolName,\n  WindowLevel: WindowLevelTool.toolName,\n  StackScroll: StackScrollTool.toolName,\n  StackScrollMouseWheel: StackScrollMouseWheelTool.toolName,\n  Zoom: ZoomTool.toolName,\n  VolumeRotateMouseWheel: VolumeRotateMouseWheelTool.toolName,\n  MipJumpToClick: MIPJumpToClickTool.toolName,\n  Length: LengthTool.toolName,\n  DragProbe: DragProbeTool.toolName,\n  Probe: ProbeTool.toolName,\n  RectangleROI: RectangleROITool.toolName,\n  EllipticalROI: EllipticalROITool.toolName,\n  CircleROI: CircleROITool.toolName,\n  Bidirectional: BidirectionalTool.toolName,\n  Angle: AngleTool.toolName,\n  CobbAngle: CobbAngleTool.toolName,\n  PlanarFreehandROI: PlanarFreehandROITool.toolName,\n  Magnify: MagnifyTool.toolName,\n  Crosshairs: CrosshairsTool.toolName,\n  SegmentationDisplay: SegmentationDisplayTool.toolName,\n  ReferenceLines: ReferenceLinesTool.toolName,\n  CalibrationLine: CalibrationLineTool.toolName,\n  TrackballRotateTool: TrackballRotateTool.toolName,\n};\n\nexport { toolNames };\n","import { eventTarget, EVENTS } from '@cornerstonejs/core';\nimport { Enums } from '@cornerstonejs/tools';\nimport { CommandsManager, CustomizationService, Types } from '@ohif/core';\nimport { findNearbyToolData } from './utils/findNearbyToolData';\n\nconst cs3DToolsEvents = Enums.Events;\n\nconst DEFAULT_DOUBLE_CLICK = {\n  doubleClick: {\n    commandName: 'toggleOneUp',\n    commandOptions: {},\n  },\n};\n\n/**\n * Generates a double click event name, consisting of:\n *    * alt when the alt key is down\n *    * ctrl when the cctrl key is down\n *    * shift when the shift key is down\n *    * 'doubleClick'\n */\nfunction getDoubleClickEventName(evt: CustomEvent) {\n  const nameArr = [];\n  if (evt.detail.event.altKey) nameArr.push('alt');\n  if (evt.detail.event.ctrlKey) nameArr.push('ctrl');\n  if (evt.detail.event.shiftKey) nameArr.push('shift');\n  nameArr.push('doubleClick');\n  return nameArr.join('');\n}\n\nexport type initDoubleClickArgs = {\n  customizationService: CustomizationService;\n  commandsManager: CommandsManager;\n};\n\nfunction initDoubleClick({\n  customizationService,\n  commandsManager,\n}: initDoubleClickArgs): void {\n  const cornerstoneViewportHandleDoubleClick = (evt: CustomEvent) => {\n    // Do not allow double click on a tool.\n    const nearbyToolData = findNearbyToolData(commandsManager, evt);\n    if (nearbyToolData) {\n      return;\n    }\n\n    const eventName = getDoubleClickEventName(evt);\n\n    // Allows for the customization of the double click on a viewport.\n    const customizations =\n      customizationService.get('cornerstoneViewportClickCommands') ||\n      DEFAULT_DOUBLE_CLICK;\n\n    const toRun = customizations[eventName];\n\n    if (!toRun) {\n      return;\n    }\n\n    commandsManager.run(toRun);\n  };\n\n  function elementEnabledHandler(evt: CustomEvent) {\n    const { element } = evt.detail;\n\n    element.addEventListener(\n      cs3DToolsEvents.MOUSE_DOUBLE_CLICK,\n      cornerstoneViewportHandleDoubleClick\n    );\n  }\n\n  function elementDisabledHandler(evt: CustomEvent) {\n    const { element } = evt.detail;\n\n    element.removeEventListener(\n      cs3DToolsEvents.MOUSE_DOUBLE_CLICK,\n      cornerstoneViewportHandleDoubleClick\n    );\n  }\n\n  eventTarget.addEventListener(\n    EVENTS.ELEMENT_ENABLED,\n    elementEnabledHandler.bind(null)\n  );\n\n  eventTarget.addEventListener(\n    EVENTS.ELEMENT_DISABLED,\n    elementDisabledHandler.bind(null)\n  );\n}\n\nexport default initDoubleClick;\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Enums, annotation } from '@cornerstonejs/tools';\nimport { DicomMetadataStore } from '@ohif/core';\nimport { toolNames } from './initCornerstoneTools';\nimport { onCompletedCalibrationLine } from './tools/CalibrationLineTool';\n\nimport measurementServiceMappingsFactory from './utils/measurementServiceMappings/measurementServiceMappingsFactory';\nimport getSOPInstanceAttributes from './utils/measurementServiceMappings/utils/getSOPInstanceAttributes';\n\nconst { removeAnnotation } = annotation.state;\n\nconst csToolsEvents = Enums.Events;\n\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\n\nconst initMeasurementService = (\n  measurementService,\n  displaySetService,\n  cornerstoneViewportService\n) => {\n  /* Initialization */\n  const {\n    Length,\n    Bidirectional,\n    EllipticalROI,\n    CircleROI,\n    ArrowAnnotate,\n    Angle,\n    CobbAngle,\n    RectangleROI,\n    PlanarFreehandROI,\n  } = measurementServiceMappingsFactory(\n    measurementService,\n    displaySetService,\n    cornerstoneViewportService\n  );\n  const csTools3DVer1MeasurementSource = measurementService.createSource(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  /* Mappings */\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'Length',\n    Length.matchingCriteria,\n    Length.toAnnotation,\n    Length.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'Bidirectional',\n    Bidirectional.matchingCriteria,\n    Bidirectional.toAnnotation,\n    Bidirectional.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'EllipticalROI',\n    EllipticalROI.matchingCriteria,\n    EllipticalROI.toAnnotation,\n    EllipticalROI.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'CircleROI',\n    CircleROI.matchingCriteria,\n    CircleROI.toAnnotation,\n    CircleROI.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'ArrowAnnotate',\n    ArrowAnnotate.matchingCriteria,\n    ArrowAnnotate.toAnnotation,\n    ArrowAnnotate.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'CobbAngle',\n    CobbAngle.matchingCriteria,\n    CobbAngle.toAnnotation,\n    CobbAngle.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'Angle',\n    Angle.matchingCriteria,\n    Angle.toAnnotation,\n    Angle.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'RectangleROI',\n    RectangleROI.matchingCriteria,\n    RectangleROI.toAnnotation,\n    RectangleROI.toMeasurement\n  );\n\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'PlanarFreehandROI',\n    PlanarFreehandROI.matchingCriteria,\n    PlanarFreehandROI.toAnnotation,\n    PlanarFreehandROI.toMeasurement\n  );\n\n  // On the UI side, the Calibration Line tool will work almost the same as the\n  // Length tool\n  measurementService.addMapping(\n    csTools3DVer1MeasurementSource,\n    'CalibrationLine',\n    Length.matchingCriteria,\n    Length.toAnnotation,\n    Length.toMeasurement\n  );\n\n  return csTools3DVer1MeasurementSource;\n};\n\nconst connectToolsToMeasurementService = servicesManager => {\n  const {\n    measurementService,\n    displaySetService,\n    cornerstoneViewportService,\n  } = servicesManager.services;\n  const csTools3DVer1MeasurementSource = initMeasurementService(\n    measurementService,\n    displaySetService,\n    cornerstoneViewportService\n  );\n  connectMeasurementServiceToTools(\n    measurementService,\n    cornerstoneViewportService,\n    csTools3DVer1MeasurementSource\n  );\n  const { annotationToMeasurement, remove } = csTools3DVer1MeasurementSource;\n\n  //\n  function addMeasurement(csToolsEvent) {\n    try {\n      const annotationAddedEventDetail = csToolsEvent.detail;\n      const {\n        annotation: { metadata, annotationUID },\n      } = annotationAddedEventDetail;\n      const { toolName } = metadata;\n\n      if (\n        csToolsEvent.type === completedEvt &&\n        toolName === toolNames.CalibrationLine\n      ) {\n        // show modal to input the measurement (mm)\n        onCompletedCalibrationLine(servicesManager, csToolsEvent)\n          .then(\n            () => {\n              console.log('calibration applied');\n            },\n            () => true\n          )\n          .finally(() => {\n            // we don't need the calibration line lingering around, remove the\n            // annotation from the display\n            removeAnnotation(annotationUID);\n            removeMeasurement(csToolsEvent);\n            // this will ensure redrawing of annotations\n            cornerstoneViewportService.resize();\n          });\n      } else {\n        // To force the measurementUID be the same as the annotationUID\n        // Todo: this should be changed when a measurement can include multiple annotations\n        // in the future\n        annotationAddedEventDetail.uid = annotationUID;\n        annotationToMeasurement(toolName, annotationAddedEventDetail);\n      }\n    } catch (error) {\n      console.warn('Failed to update measurement:', error);\n    }\n  }\n\n  function updateMeasurement(csToolsEvent) {\n    try {\n      const annotationModifiedEventDetail = csToolsEvent.detail;\n\n      const {\n        annotation: { metadata, annotationUID },\n      } = annotationModifiedEventDetail;\n\n      // If the measurement hasn't been added, don't modify it\n      const measurement = measurementService.getMeasurement(annotationUID);\n\n      if (!measurement) {\n        return;\n      }\n      const { toolName } = metadata;\n\n      annotationModifiedEventDetail.uid = annotationUID;\n      // Passing true to indicate this is an update and NOT a annotation (start) completion.\n      annotationToMeasurement(toolName, annotationModifiedEventDetail, true);\n    } catch (error) {\n      console.warn('Failed to update measurement:', error);\n    }\n  }\n  function selectMeasurement(csToolsEvent) {\n    try {\n      const annotationSelectionEventDetail = csToolsEvent.detail;\n\n      const {\n        added: addedSelectedAnnotationUIDs,\n        removed: removedSelectedAnnotationUIDs,\n      } = annotationSelectionEventDetail;\n\n      if (removedSelectedAnnotationUIDs) {\n        removedSelectedAnnotationUIDs.forEach(annotationUID =>\n          measurementService.setMeasurementSelected(annotationUID, false)\n        );\n      }\n\n      if (addedSelectedAnnotationUIDs) {\n        addedSelectedAnnotationUIDs.forEach(annotationUID =>\n          measurementService.setMeasurementSelected(annotationUID, true)\n        );\n      }\n    } catch (error) {\n      console.warn('Failed to select and unselect measurements:', error);\n    }\n  }\n\n  /**\n   * When csTools fires a removed event, remove the same measurement\n   * from the measurement service\n   *\n   * @param {*} csToolsEvent\n   */\n  function removeMeasurement(csToolsEvent) {\n    try {\n      try {\n        const annotationRemovedEventDetail = csToolsEvent.detail;\n        const {\n          annotation: { annotationUID },\n        } = annotationRemovedEventDetail;\n\n        const measurement = measurementService.getMeasurement(annotationUID);\n\n        if (measurement) {\n          console.log('~~ removeEvt', csToolsEvent);\n          remove(annotationUID, annotationRemovedEventDetail);\n        }\n      } catch (error) {\n        console.warn('Failed to update measurement:', error);\n      }\n    } catch (error) {\n      console.warn('Failed to remove measurement:', error);\n    }\n  }\n\n  // on display sets added, check if there are any measurements in measurement service that need to be\n  // put into cornerstone tools\n  const addedEvt = csToolsEvents.ANNOTATION_ADDED;\n  const completedEvt = csToolsEvents.ANNOTATION_COMPLETED;\n  const updatedEvt = csToolsEvents.ANNOTATION_MODIFIED;\n  const removedEvt = csToolsEvents.ANNOTATION_REMOVED;\n  const selectionEvt = csToolsEvents.ANNOTATION_SELECTION_CHANGE;\n\n  eventTarget.addEventListener(addedEvt, addMeasurement);\n  eventTarget.addEventListener(completedEvt, addMeasurement);\n  eventTarget.addEventListener(updatedEvt, updateMeasurement);\n  eventTarget.addEventListener(removedEvt, removeMeasurement);\n  eventTarget.addEventListener(selectionEvt, selectMeasurement);\n\n  return csTools3DVer1MeasurementSource;\n};\n\nconst connectMeasurementServiceToTools = (\n  measurementService,\n  cornerstoneViewportService,\n  measurementSource\n) => {\n  const {\n    MEASUREMENT_REMOVED,\n    MEASUREMENTS_CLEARED,\n    MEASUREMENT_UPDATED,\n    RAW_MEASUREMENT_ADDED,\n  } = measurementService.EVENTS;\n\n  const csTools3DVer1MeasurementSource = measurementService.getSource(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  measurementService.subscribe(MEASUREMENTS_CLEARED, ({ measurements }) => {\n    if (!Object.keys(measurements).length) {\n      return;\n    }\n\n    for (const measurement of Object.values(measurements)) {\n      const { uid, source } = measurement;\n      if (source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        continue;\n      }\n\n      removeAnnotation(uid);\n    }\n  });\n\n  measurementService.subscribe(\n    MEASUREMENT_UPDATED,\n    ({ source, measurement, notYetUpdatedAtSource }) => {\n      if (source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        return;\n      }\n\n      if (notYetUpdatedAtSource === false) {\n        // This event was fired by cornerstone telling the measurement service to sync.\n        // Already in sync.\n        return;\n      }\n\n      const { uid, label } = measurement;\n\n      const sourceAnnotation = annotation.state.getAnnotation(uid);\n      const { data, metadata } = sourceAnnotation;\n\n      if (!data) {\n        return;\n      }\n\n      if (data.label !== label) {\n        data.label = label;\n      }\n\n      if (metadata.toolName === 'ArrowAnnotate') {\n        data.text = label;\n      }\n\n      // Todo: trigger render for annotation\n    }\n  );\n\n  measurementService.subscribe(\n    RAW_MEASUREMENT_ADDED,\n    ({ source, measurement, data, dataSource }) => {\n      if (source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        return;\n      }\n\n      const {\n        referenceSeriesUID,\n        referenceStudyUID,\n        SOPInstanceUID,\n      } = measurement;\n\n      const instance = DicomMetadataStore.getInstance(\n        referenceStudyUID,\n        referenceSeriesUID,\n        SOPInstanceUID\n      );\n\n      let imageId;\n      let frameNumber = 1;\n\n      if (measurement?.metadata?.referencedImageId) {\n        imageId = measurement.metadata.referencedImageId;\n        frameNumber = getSOPInstanceAttributes(\n          measurement.metadata.referencedImageId\n        ).frameNumber;\n      } else {\n        imageId = dataSource.getImageIdsForInstance({ instance });\n      }\n\n      const annotationManager = annotation.state.getAnnotationManager();\n      annotationManager.addAnnotation({\n        annotationUID: measurement.uid,\n        highlighted: false,\n        isLocked: false,\n        invalidated: false,\n        metadata: {\n          toolName: measurement.toolName,\n          FrameOfReferenceUID: measurement.FrameOfReferenceUID,\n          referencedImageId: imageId,\n        },\n        data: {\n          text: data.annotation.data.text,\n          handles: { ...data.annotation.data.handles },\n          cachedStats: { ...data.annotation.data.cachedStats },\n          label: data.annotation.data.label,\n          frameNumber: frameNumber,\n        },\n      });\n    }\n  );\n\n  measurementService.subscribe(\n    MEASUREMENT_REMOVED,\n    ({ source, measurement: removedMeasurementId }) => {\n      if (source?.name && source.name !== CORNERSTONE_3D_TOOLS_SOURCE_NAME) {\n        return;\n      }\n      removeAnnotation(removedMeasurementId);\n      const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n      // Note: We could do a better job by triggering the render on the\n      // viewport itself, but the removeAnnotation does not include that info...\n      renderingEngine.render();\n    }\n  );\n};\n\nexport {\n  initMeasurementService,\n  connectToolsToMeasurementService,\n  connectMeasurementServiceToTools,\n};\n","import * as cornerstone from '@cornerstonejs/core';\nimport { volumeLoader } from '@cornerstonejs/core';\nimport { cornerstoneStreamingImageVolumeLoader } from '@cornerstonejs/streaming-image-volume-loader';\nimport dicomImageLoader, {\n  webWorkerManager,\n} from '@cornerstonejs/dicom-image-loader';\nimport dicomParser from 'dicom-parser';\nimport { errorHandler } from '@ohif/core';\n\nconst { registerVolumeLoader } = volumeLoader;\n\nlet initialized = false;\n\nfunction initWebWorkers(appConfig) {\n  const config = {\n    maxWebWorkers: Math.min(\n      Math.max(navigator.hardwareConcurrency - 1, 1),\n      appConfig.maxNumberOfWebWorkers\n    ),\n    startWebWorkersOnDemand: true,\n    taskConfiguration: {\n      decodeTask: {\n        initializeCodecsOnStartup: false,\n        usePDFJS: false,\n        strict: false,\n      },\n    },\n  };\n\n  if (!initialized) {\n    dicomImageLoader.webWorkerManager.initialize(config);\n    initialized = true;\n  }\n}\n\nexport default function initWADOImageLoader(\n  userAuthenticationService,\n  appConfig\n) {\n  dicomImageLoader.external.cornerstone = cornerstone;\n  dicomImageLoader.external.dicomParser = dicomParser;\n\n  registerVolumeLoader(\n    'cornerstoneStreamingImageVolume',\n    cornerstoneStreamingImageVolumeLoader\n  );\n\n  dicomImageLoader.configure({\n    decodeConfig: {\n      // !! IMPORTANT !!\n      // We should set this flag to false, since, by default @cornerstonejs/dicom-image-loader\n      // will convert everything to integers (to be able to work with cornerstone-2d).\n      // Until the default is set to true (which is the case for cornerstone3D),\n      // we should set this flag to false.\n      convertFloatPixelDataToInt: false,\n    },\n    beforeSend: function(xhr) {\n      const headers = userAuthenticationService.getAuthorizationHeader();\n\n      // Request:\n      // JPEG-LS Lossless (1.2.840.10008.1.2.4.80) if available, otherwise accept\n      // whatever transfer-syntax the origin server provides.\n      // For now we use image/jls and image/x-jls because some servers still use the old type\n      // http://dicom.nema.org/medical/dicom/current/output/html/part18.html\n      const xhrRequestHeaders = {\n        Accept: appConfig.omitQuotationForMultipartRequest\n          ? 'multipart/related; type=application/octet-stream'\n          : 'multipart/related; type=\"application/octet-stream\"',\n        // 'multipart/related; type=\"image/x-jls\", multipart/related; type=\"image/jls\"; transfer-syntax=\"1.2.840.10008.1.2.4.80\", multipart/related; type=\"image/x-jls\", multipart/related; type=\"application/octet-stream\"; transfer-syntax=*',\n      };\n\n      if (headers) {\n        Object.assign(xhrRequestHeaders, headers);\n      }\n\n      return xhrRequestHeaders;\n    },\n    errorInterceptor: error => {\n      errorHandler.getHTTPErrorHandler(error);\n    },\n  });\n\n  initWebWorkers(appConfig);\n}\n\nexport function destroy() {\n  // Note: we don't want to call .terminate on the webWorkerManager since\n  // that resets the config\n  const webWorkers = webWorkerManager.webWorkers;\n  for (let i = 0; i < webWorkers.length; i++) {\n    webWorkers[i].worker.terminate();\n  }\n  webWorkers.length = 0;\n}\n","import { ServicesManager, Types } from '@ohif/core';\nimport {\n  cache as cs3DCache,\n  Enums,\n  volumeLoader,\n  utilities as utils,\n} from '@cornerstonejs/core';\n\nimport getCornerstoneViewportType from '../../utils/getCornerstoneViewportType';\nimport {\n  StackViewportData,\n  VolumeViewportData,\n} from '../../types/CornerstoneCacheService';\n\nconst VOLUME_LOADER_SCHEME = 'cornerstoneStreamingImageVolume';\n\nclass CornerstoneCacheService {\n  static REGISTRATION = {\n    name: 'cornerstoneCacheService',\n    altName: 'CornerstoneCacheService',\n    create: ({\n      servicesManager,\n    }: Types.Extensions.ExtensionParams): CornerstoneCacheService => {\n      return new CornerstoneCacheService(servicesManager);\n    },\n  };\n\n  stackImageIds: Map<string, string[]> = new Map();\n  volumeImageIds: Map<string, string[]> = new Map();\n  readonly servicesManager: ServicesManager;\n\n  constructor(servicesManager: ServicesManager) {\n    this.servicesManager = servicesManager;\n  }\n\n  public getCacheSize() {\n    return cs3DCache.getCacheSize();\n  }\n\n  public getCacheFreeSpace() {\n    return cs3DCache.getBytesAvailable();\n  }\n\n  public async createViewportData(\n    displaySets: unknown[],\n    viewportOptions: Record<string, unknown>,\n    dataSource: unknown,\n    initialImageIndex?: number\n  ): Promise<StackViewportData | VolumeViewportData> {\n    let viewportType = viewportOptions.viewportType as string;\n\n    // Todo: Since Cornerstone 3D currently doesn't support segmentation\n    // on stack viewport, we should check if whether the the displaySets\n    // that are about to be displayed are referenced in a segmentation\n    // as a reference volume, if so, we should hang a volume viewport\n    // instead of a stack viewport\n    if (this._shouldRenderSegmentation(displaySets)) {\n      viewportType = 'volume';\n\n      // update viewportOptions to reflect the new viewport type\n      viewportOptions.viewportType = viewportType;\n    }\n\n    const cs3DViewportType = getCornerstoneViewportType(viewportType);\n    let viewportData: StackViewportData | VolumeViewportData;\n\n    if (cs3DViewportType === Enums.ViewportType.STACK) {\n      viewportData = await this._getStackViewportData(\n        dataSource,\n        displaySets,\n        initialImageIndex,\n        cs3DViewportType\n      );\n    }\n\n    if (\n      cs3DViewportType === Enums.ViewportType.ORTHOGRAPHIC ||\n      cs3DViewportType === Enums.ViewportType.VOLUME_3D\n    ) {\n      viewportData = await this._getVolumeViewportData(\n        dataSource,\n        displaySets,\n        cs3DViewportType\n      );\n    }\n\n    viewportData.viewportType = cs3DViewportType;\n\n    return viewportData;\n  }\n\n  public async invalidateViewportData(\n    viewportData: VolumeViewportData,\n    invalidatedDisplaySetInstanceUID: string,\n    dataSource,\n    displaySetService\n  ) {\n    if (viewportData.viewportType === Enums.ViewportType.STACK) {\n      return this._getCornerstoneStackImageIds(\n        displaySetService.getDisplaySetByUID(invalidatedDisplaySetInstanceUID),\n        dataSource\n      );\n    }\n\n    // Todo: grab the volume and get the id from the viewport itself\n    const volumeId = `${VOLUME_LOADER_SCHEME}:${invalidatedDisplaySetInstanceUID}`;\n\n    const volume = cs3DCache.getVolume(volumeId);\n\n    if (volume) {\n      cs3DCache.removeVolumeLoadObject(volumeId);\n      this.volumeImageIds.delete(volumeId);\n    }\n\n    const displaySets = viewportData.data.map(({ displaySetInstanceUID }) =>\n      displaySetService.getDisplaySetByUID(displaySetInstanceUID)\n    );\n\n    const newViewportData = await this._getVolumeViewportData(\n      dataSource,\n      displaySets,\n      viewportData.viewportType\n    );\n\n    return newViewportData;\n  }\n\n  private _getStackViewportData(\n    dataSource,\n    displaySets,\n    initialImageIndex,\n    viewportType: Enums.ViewportType\n  ): StackViewportData {\n    // For Stack Viewport we don't have fusion currently\n    const displaySet = displaySets[0];\n\n    let stackImageIds = this.stackImageIds.get(\n      displaySet.displaySetInstanceUID\n    );\n\n    if (!stackImageIds) {\n      stackImageIds = this._getCornerstoneStackImageIds(displaySet, dataSource);\n      this.stackImageIds.set(displaySet.displaySetInstanceUID, stackImageIds);\n    }\n\n    const {\n      displaySetInstanceUID,\n      StudyInstanceUID,\n      isCompositeStack,\n    } = displaySet;\n\n    const StackViewportData: StackViewportData = {\n      viewportType,\n      data: {\n        StudyInstanceUID,\n        displaySetInstanceUID,\n        isCompositeStack,\n        imageIds: stackImageIds,\n      },\n    };\n\n    if (typeof initialImageIndex === 'number') {\n      StackViewportData.data.initialImageIndex = initialImageIndex;\n    }\n\n    return StackViewportData;\n  }\n\n  private async _getVolumeViewportData(\n    dataSource,\n    displaySets,\n    viewportType: Enums.ViewportType\n  ): Promise<VolumeViewportData> {\n    // Todo: Check the cache for multiple scenarios to see if we need to\n    // decache the volume data from other viewports or not\n\n    const volumeData = [];\n\n    for (const displaySet of displaySets) {\n      // Don't create volumes for the displaySets that have custom load\n      // function (e.g., SEG, RT, since they rely on the reference volumes\n      // and they take care of their own loading after they are created in their\n      // getSOPClassHandler method\n\n      if (displaySet.load && displaySet.load instanceof Function) {\n        const { userAuthenticationService } = this.servicesManager.services;\n        const headers = userAuthenticationService.getAuthorizationHeader();\n        await displaySet.load({ headers });\n\n        volumeData.push({\n          studyInstanceUID: displaySet.StudyInstanceUID,\n          displaySetInstanceUID: displaySet.displaySetInstanceUID,\n        });\n\n        // Todo: do some cache check and empty the cache if needed\n        continue;\n      }\n\n      const volumeLoaderSchema =\n        displaySet.volumeLoaderSchema ?? VOLUME_LOADER_SCHEME;\n\n      const volumeId = `${volumeLoaderSchema}:${displaySet.displaySetInstanceUID}`;\n\n      let volumeImageIds = this.volumeImageIds.get(\n        displaySet.displaySetInstanceUID\n      );\n\n      let volume = cs3DCache.getVolume(volumeId);\n\n      if (!volumeImageIds || !volume) {\n        volumeImageIds = this._getCornerstoneVolumeImageIds(\n          displaySet,\n          dataSource\n        );\n\n        volume = await volumeLoader.createAndCacheVolume(volumeId, {\n          imageIds: volumeImageIds,\n        });\n\n        this.volumeImageIds.set(\n          displaySet.displaySetInstanceUID,\n          volumeImageIds\n        );\n      }\n\n      volumeData.push({\n        StudyInstanceUID: displaySet.StudyInstanceUID,\n        displaySetInstanceUID: displaySet.displaySetInstanceUID,\n        volume,\n        volumeId,\n        imageIds: volumeImageIds,\n      });\n    }\n\n    return {\n      viewportType,\n      data: volumeData,\n    };\n  }\n\n  private _shouldRenderSegmentation(displaySets) {\n    const { segmentationService } = this.servicesManager.services;\n\n    const viewportDisplaySetInstanceUIDs = displaySets.map(\n      ({ displaySetInstanceUID }) => displaySetInstanceUID\n    );\n\n    // check inside segmentations if any of them are referencing the displaySets\n    // that are about to be displayed\n    const segmentations = segmentationService.getSegmentations();\n\n    for (const segmentation of segmentations) {\n      const segDisplaySetInstanceUID = segmentation.displaySetInstanceUID;\n\n      const shouldDisplaySeg = segmentationService.shouldRenderSegmentation(\n        viewportDisplaySetInstanceUIDs,\n        segDisplaySetInstanceUID\n      );\n\n      if (shouldDisplaySeg) {\n        return true;\n      }\n    }\n  }\n\n  private _getCornerstoneStackImageIds(displaySet, dataSource): string[] {\n    return dataSource.getImageIdsForDisplaySet(displaySet);\n  }\n\n  private _getCornerstoneVolumeImageIds(displaySet, dataSource): string[] {\n    const stackImageIds = this._getCornerstoneStackImageIds(\n      displaySet,\n      dataSource\n    );\n\n    return stackImageIds;\n  }\n}\n\nexport default CornerstoneCacheService;\n","import CornerstoneCacheService from './CornerstoneCacheService';\n\nexport default CornerstoneCacheService;\n","/**\n * Maps a DICOM RT Struct ROI Contour to a RTStruct data that can be used\n * in Segmentation Service\n *\n * @param structureSet - A DICOM RT Struct ROI Contour\n * @param rtDisplaySetUID - A CornerstoneTools DisplaySet UID\n * @returns An array of object that includes data, id, segmentIndex, color\n * and geometry Id\n */\nexport function mapROIContoursToRTStructData(\n  structureSet: unknown,\n  rtDisplaySetUID: unknown\n) {\n  return structureSet.ROIContours.map(\n    ({ contourPoints, ROINumber, ROIName, colorArray }) => {\n      const data = contourPoints.map(({ points, ...rest }) => {\n        const newPoints = points.map(({ x, y, z }) => {\n          return [x, y, z];\n        });\n\n        return {\n          ...rest,\n          points: newPoints,\n        };\n      });\n\n      const id = ROIName || ROINumber;\n\n      return {\n        data,\n        id,\n        segmentIndex: ROINumber,\n        color: colorArray,\n        geometryId: `${rtDisplaySetUID}:${id}:segmentIndex-${ROINumber}`,\n      };\n    }\n  );\n}\n","import cloneDeep from 'lodash.clonedeep';\n\nimport { Types as OhifTypes, ServicesManager, PubSubService } from '@ohif/core';\nimport {\n  cache,\n  Enums as csEnums,\n  geometryLoader,\n  eventTarget,\n  getEnabledElementByIds,\n  metaData,\n  utilities as csUtils,\n  volumeLoader,\n} from '@cornerstonejs/core';\nimport {\n  CONSTANTS as cstConstants,\n  Enums as csToolsEnums,\n  segmentation as cstSegmentation,\n  Types as cstTypes,\n  utilities as cstUtils,\n} from '@cornerstonejs/tools';\nimport isEqual from 'lodash.isequal';\nimport { Types as ohifTypes } from '@ohif/core';\nimport { easeInOutBell, reverseEaseInOutBell } from '../../utils/transitions';\nimport {\n  Segment,\n  Segmentation,\n  SegmentationConfig,\n} from './SegmentationServiceTypes';\nimport { mapROIContoursToRTStructData } from './RTSTRUCT/mapROIContoursToRTStructData';\n\nconst { COLOR_LUT } = cstConstants;\nconst LABELMAP = csToolsEnums.SegmentationRepresentations.Labelmap;\nconst CONTOUR = csToolsEnums.SegmentationRepresentations.Contour;\n\nconst EVENTS = {\n  // fired when the segmentation is updated (e.g. when a segment is added, removed, or modified, locked, visibility changed etc.)\n  SEGMENTATION_UPDATED: 'event::segmentation_updated',\n  // fired when the segmentation data (e.g., labelmap pixels) is modified\n  SEGMENTATION_DATA_MODIFIED: 'event::segmentation_data_modified',\n  // fired when the segmentation is added to the cornerstone\n  SEGMENTATION_ADDED: 'event::segmentation_added',\n  // fired when the segmentation is removed\n  SEGMENTATION_REMOVED: 'event::segmentation_removed',\n  // fired when the configuration for the segmentation is changed (e.g., brush size, render fill, outline thickness, etc.)\n  SEGMENTATION_CONFIGURATION_CHANGED:\n    'event::segmentation_configuration_changed',\n  // fired when the active segment is loaded in SEG or RTSTRUCT\n  SEGMENT_LOADING_COMPLETE: 'event::segment_loading_complete',\n  // for all segments\n  SEGMENTATION_LOADING_COMPLETE: 'event::segmentation_loading_complete',\n};\n\nconst VALUE_TYPES = {};\n\nconst SEGMENT_CONSTANT = {\n  opacity: 255,\n  isVisible: true,\n  isLocked: false,\n};\n\nconst VOLUME_LOADER_SCHEME = 'cornerstoneStreamingImageVolume';\n\nclass SegmentationService extends PubSubService {\n  static REGISTRATION = {\n    name: 'segmentationService',\n    altName: 'SegmentationService',\n    create: ({\n      servicesManager,\n    }: OhifTypes.Extensions.ExtensionParams): SegmentationService => {\n      return new SegmentationService({ servicesManager });\n    },\n  };\n\n  segmentations: Record<string, Segmentation>;\n  readonly servicesManager: ServicesManager;\n  highlightIntervalId = null;\n  readonly EVENTS = EVENTS;\n\n  constructor({ servicesManager }) {\n    super(EVENTS);\n    this.segmentations = {};\n\n    this.servicesManager = servicesManager;\n\n    this._initSegmentationService();\n  }\n\n  public destroy = () => {\n    eventTarget.removeEventListener(\n      csToolsEnums.Events.SEGMENTATION_MODIFIED,\n      this._onSegmentationModifiedFromSource\n    );\n\n    eventTarget.removeEventListener(\n      csToolsEnums.Events.SEGMENTATION_DATA_MODIFIED,\n      this._onSegmentationDataModified\n    );\n\n    // remove the segmentations from the cornerstone\n    Object.keys(this.segmentations).forEach(segmentationId => {\n      this._removeSegmentationFromCornerstone(segmentationId);\n    });\n\n    this.segmentations = {};\n    this.listeners = {};\n  };\n\n  /**\n   * It adds a segment to a segmentation, basically just setting the properties for\n   * the segment.\n   * @param segmentationId - The ID of the segmentation you want to add a\n   * segment to.\n   * @param segmentIndex - The index of the segment to add.\n   * @param properties - The properties of the segment to add including\n   * -- label: the label of the segment\n   * -- color: the color of the segment\n   * -- opacity: the opacity of the segment\n   * -- visibility: the visibility of the segment (boolean)\n   * -- isLocked: whether the segment is locked for editing\n   * -- active: whether the segment is currently the active segment to be edited or not\n   */\n  public addSegment(\n    segmentationId: string,\n    segmentIndex: number,\n    toolGroupId?: string,\n    properties?: {\n      label?: string;\n      color?: ohifTypes.RGB;\n      opacity?: number;\n      visibility?: boolean;\n      isLocked?: boolean;\n      active?: boolean;\n    }\n  ): void {\n    if (segmentIndex === 0) {\n      throw new Error('Segment index 0 is reserved for \"no label\"');\n    }\n\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const {\n      segmentationRepresentationUID,\n      segmentation,\n    } = this._getSegmentationInfo(segmentationId, toolGroupId);\n\n    if (this._getSegmentInfo(segmentation, segmentIndex)) {\n      throw new Error(`Segment ${segmentIndex} already exists`);\n    }\n\n    const rgbaColor = cstSegmentation.config.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    segmentation.segments[segmentIndex] = {\n      label: properties.label,\n      segmentIndex: segmentIndex,\n      color: [rgbaColor[0], rgbaColor[1], rgbaColor[2]],\n      opacity: rgbaColor[3],\n      isVisible: true,\n      isLocked: false,\n    };\n\n    segmentation.segmentCount++;\n\n    const suppressEvents = true;\n    if (properties !== undefined) {\n      const {\n        color: newColor,\n        opacity,\n        isLocked,\n        visibility,\n        active,\n      } = properties;\n\n      if (newColor !== undefined) {\n        this._setSegmentColor(\n          segmentationId,\n          segmentIndex,\n          newColor,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (opacity !== undefined) {\n        this._setSegmentOpacity(\n          segmentationId,\n          segmentIndex,\n          opacity,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (visibility !== undefined) {\n        this._setSegmentVisibility(\n          segmentationId,\n          segmentIndex,\n          visibility,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (active !== undefined) {\n        this._setActiveSegment(segmentationId, segmentIndex, suppressEvents);\n      }\n\n      if (isLocked !== undefined) {\n        this._setSegmentLocked(\n          segmentationId,\n          segmentIndex,\n          isLocked,\n          suppressEvents\n        );\n      }\n    }\n\n    if (segmentation.activeSegmentIndex === null) {\n      this._setActiveSegment(segmentationId, segmentIndex, suppressEvents);\n    }\n\n    // Todo: this includes non-hydrated segmentations which might not be\n    // persisted in the store\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  }\n\n  public removeSegment(segmentationId: string, segmentIndex: number): void {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    if (segmentIndex === 0) {\n      throw new Error('Segment index 0 is reserved for \"no label\"');\n    }\n\n    if (!this._getSegmentInfo(segmentation, segmentIndex)) {\n      return;\n    }\n\n    segmentation.segmentCount--;\n\n    segmentation.segments[segmentIndex] = null;\n\n    // Get volume and delete the labels\n    // Todo: handle other segmentations other than labelmap\n    const labelmapVolume = this.getLabelmapVolume(segmentationId);\n\n    const { dimensions } = labelmapVolume;\n    const scalarData = labelmapVolume.getScalarData();\n\n    // Set all values of this segment to zero and get which frames have been edited.\n    const frameLength = dimensions[0] * dimensions[1];\n    const numFrames = dimensions[2];\n\n    let voxelIndex = 0;\n\n    const modifiedFrames = new Set() as Set<number>;\n\n    for (let frame = 0; frame < numFrames; frame++) {\n      for (let p = 0; p < frameLength; p++) {\n        if (scalarData[voxelIndex] === segmentIndex) {\n          scalarData[voxelIndex] = 0;\n          modifiedFrames.add(frame);\n        }\n\n        voxelIndex++;\n      }\n    }\n\n    const modifiedFramesArray: number[] = Array.from(modifiedFrames);\n\n    // Trigger texture update of modified segmentation frames.\n    cstSegmentation.triggerSegmentationEvents.triggerSegmentationDataModified(\n      segmentationId,\n      modifiedFramesArray\n    );\n\n    if (segmentation.activeSegmentIndex === segmentIndex) {\n      const segmentIndices = Object.keys(segmentation.segments);\n\n      const newActiveSegmentIndex = segmentIndices.length\n        ? Number(segmentIndices[0])\n        : 1;\n\n      this._setActiveSegment(segmentationId, newActiveSegmentIndex, true);\n    }\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  }\n\n  public setSegmentVisibility(\n    segmentationId: string,\n    segmentIndex: number,\n    isVisible: boolean,\n    toolGroupId?: string,\n    suppressEvents = false\n  ): void {\n    this._setSegmentVisibility(\n      segmentationId,\n      segmentIndex,\n      isVisible,\n      toolGroupId,\n      suppressEvents\n    );\n  }\n\n  public setSegmentLockedForSegmentation(\n    segmentationId: string,\n    segmentIndex: number,\n    isLocked: boolean\n  ): void {\n    const suppressEvents = false;\n    this._setSegmentLocked(\n      segmentationId,\n      segmentIndex,\n      isLocked,\n      suppressEvents\n    );\n  }\n\n  public setSegmentLabel(\n    segmentationId: string,\n    segmentIndex: number,\n    segmentLabel: string\n  ): void {\n    this._setSegmentLabel(segmentationId, segmentIndex, segmentLabel);\n  }\n\n  public setSegmentColor(\n    segmentationId: string,\n    segmentIndex: number,\n    color: ohifTypes.RGB,\n    toolGroupId?: string\n  ): void {\n    this._setSegmentColor(segmentationId, segmentIndex, color, toolGroupId);\n  }\n\n  public setSegmentRGBA = (\n    segmentationId: string,\n    segmentIndex: number,\n    rgbaColor: cstTypes.Color,\n    toolGroupId?: string\n  ): void => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const suppressEvents = true;\n    this._setSegmentOpacity(\n      segmentationId,\n      segmentIndex,\n      rgbaColor[3],\n      toolGroupId,\n      suppressEvents\n    );\n\n    this._setSegmentColor(\n      segmentationId,\n      segmentIndex,\n      [rgbaColor[0], rgbaColor[1], rgbaColor[2]],\n      toolGroupId,\n      suppressEvents\n    );\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  };\n\n  public setSegmentOpacity(\n    segmentationId: string,\n    segmentIndex: number,\n    opacity: number,\n    toolGroupId?: string\n  ): void {\n    this._setSegmentOpacity(segmentationId, segmentIndex, opacity, toolGroupId);\n  }\n\n  public setActiveSegmentationForToolGroup(\n    segmentationId: string,\n    toolGroupId?: string\n  ): void {\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const suppressEvents = false;\n    this._setActiveSegmentationForToolGroup(\n      segmentationId,\n      toolGroupId,\n      suppressEvents\n    );\n  }\n\n  public setActiveSegmentForSegmentation(\n    segmentationId: string,\n    segmentIndex: number\n  ): void {\n    this._setActiveSegment(segmentationId, segmentIndex, false);\n  }\n\n  /**\n   * Get all segmentations.\n   *\n   * * @param filterNonHydratedSegmentations - If true, only return hydrated segmentations\n   * hydrated segmentations are those that have been loaded and persisted\n   * in the state, but non hydrated segmentations are those that are\n   * only created for the SEG displayset (SEG viewport) and the user might not\n   * have loaded them yet fully.\n   *\n\n   * @return Array of segmentations\n   */\n  public getSegmentations(\n    filterNonHydratedSegmentations = true\n  ): Segmentation[] {\n    const segmentations = this._getSegmentations();\n\n    return (\n      segmentations &&\n      segmentations.filter(segmentation => {\n        return !filterNonHydratedSegmentations || segmentation.hydrated;\n      })\n    );\n  }\n\n  private _getSegmentations(): Segmentation[] {\n    const segmentations = this.arrayOfObjects(this.segmentations);\n    return (\n      segmentations &&\n      segmentations.map(m => this.segmentations[Object.keys(m)[0]])\n    );\n  }\n\n  /**\n   * Get specific segmentation by its id.\n   *\n   * @param segmentationId If of the segmentation\n   * @return segmentation instance\n   */\n  public getSegmentation(segmentationId: string): Segmentation {\n    return this.segmentations[segmentationId];\n  }\n\n  public addOrUpdateSegmentation(\n    segmentation: Segmentation,\n    suppressEvents = false,\n    notYetUpdatedAtSource = false\n  ): string {\n    const { id: segmentationId } = segmentation;\n    let cachedSegmentation = this.segmentations[segmentationId];\n    if (cachedSegmentation) {\n      // Update the segmentation (mostly for assigning metadata/labels)\n      Object.assign(cachedSegmentation, segmentation);\n\n      this._updateCornerstoneSegmentations({\n        segmentationId,\n        notYetUpdatedAtSource,\n      });\n\n      if (!suppressEvents) {\n        this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n          segmentation: cachedSegmentation,\n        });\n      }\n\n      return segmentationId;\n    }\n\n    const representationType = segmentation.type;\n    const representationData =\n      segmentation.representationData[representationType];\n    cstSegmentation.addSegmentations([\n      {\n        segmentationId,\n        representation: {\n          type: representationType,\n          data: {\n            ...representationData,\n          },\n        },\n      },\n    ]);\n\n    // Define a new color LUT and associate it with this segmentation.\n    // Todo: need to be generalized to accept custom color LUTs\n    const newColorLUT = this.generateNewColorLUT();\n    const newColorLUTIndex = this.getNextColorLUTIndex();\n\n    cstSegmentation.config.color.addColorLUT(newColorLUT, newColorLUTIndex);\n\n    this.segmentations[segmentationId] = {\n      ...segmentation,\n      label: segmentation.label || '',\n      segments: segmentation.segments || [null],\n      activeSegmentIndex: segmentation.activeSegmentIndex ?? null,\n      segmentCount: segmentation.segmentCount ?? 0,\n      isActive: false,\n      colorLUTIndex: newColorLUTIndex,\n      isVisible: true,\n    };\n\n    cachedSegmentation = this.segmentations[segmentationId];\n\n    this._updateCornerstoneSegmentations({\n      segmentationId,\n      notYetUpdatedAtSource: true,\n    });\n\n    if (!suppressEvents) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_ADDED, {\n        segmentation: cachedSegmentation,\n      });\n    }\n\n    return cachedSegmentation.id;\n  }\n\n  public async createSegmentationForSEGDisplaySet(\n    segDisplaySet,\n    segmentationId?: string,\n    suppressEvents = false\n  ): Promise<string> {\n    // Todo: we only support creating labelmap for SEG displaySets for now\n    const representationType = LABELMAP;\n\n    segmentationId = segmentationId ?? segDisplaySet.displaySetInstanceUID;\n\n    const defaultScheme = this._getDefaultSegmentationScheme();\n\n    const segmentation: Segmentation = {\n      ...defaultScheme,\n      id: segmentationId,\n      displaySetInstanceUID: segDisplaySet.displaySetInstanceUID,\n      type: representationType,\n      representationData: {\n        [LABELMAP]: {\n          volumeId: segmentationId,\n          referencedVolumeId: segDisplaySet.referencedVolumeId,\n        },\n      },\n    };\n\n    const labelmap = this.getLabelmapVolume(segmentationId);\n    const cachedSegmentation = this.getSegmentation(segmentationId);\n    if (labelmap && cachedSegmentation) {\n      // if the labelmap with the same segmentationId already exists, we can\n      // just assume that the segmentation is already created and move on with\n      // updating the state\n      return this.addOrUpdateSegmentation(\n        Object.assign(segmentation, cachedSegmentation),\n        suppressEvents\n      );\n    }\n\n    const { segments, referencedVolumeId } = segDisplaySet;\n\n    if (!segments || !referencedVolumeId) {\n      throw new Error(\n        'To create the segmentation from SEG displaySet, the displaySet should be loaded first, you can perform segDisplaySet.load() before calling this method.'\n      );\n    }\n\n    // if the labelmap doesn't exist, we need to create it first from the\n    // DICOM SEG displaySet data\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n\n    if (!referencedVolume) {\n      throw new Error(\n        `No volume found for referencedVolumeId: ${referencedVolumeId}`\n      );\n    }\n\n    // Force use of a Uint8Array SharedArrayBuffer for the segmentation to save space and so\n    // it is easily compressible in worker thread.\n    const derivedVolume = await volumeLoader.createAndCacheDerivedVolume(\n      referencedVolumeId,\n      {\n        volumeId: segmentationId,\n        targetBuffer: {\n          type: 'Uint8Array',\n          sharedArrayBuffer: true,\n        },\n      }\n    );\n    const [rows, columns] = derivedVolume.dimensions;\n    const derivedVolumeScalarData = derivedVolume.getScalarData();\n\n    const { imageIds } = referencedVolume;\n    const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId, index) => {\n      const { sopInstanceUid } = metaData.get('generalImageModule', imageId);\n      acc[sopInstanceUid] = index;\n      return acc;\n    }, {} as { [sopUID: string]: number });\n\n    const numSegments = Object.keys(segments).length;\n    // Note: ideally we could use the TypedArray set method, but since each\n    // slice can have multiple segments, we need to loop over each slice and\n    // set the segment value for each segment.\n    let overlappingSegments = false;\n\n    const _segmentInfoUpdate = (segmentInfo, segmentIndex) => {\n      const { pixelData: segPixelData } = segmentInfo;\n\n      let segmentX = 0;\n      let segmentY = 0;\n      let segmentZ = 0;\n      let count = 0;\n\n      for (const [\n        functionalGroupIndex,\n        functionalGroup,\n      ] of segmentInfo.functionalGroups.entries()) {\n        const {\n          ReferencedSOPInstanceUID,\n        } = functionalGroup.DerivationImageSequence.SourceImageSequence;\n\n        const imageIdIndex = sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n\n        if (imageIdIndex === -1) {\n          return;\n        }\n\n        const step = rows * columns;\n\n        // we need a faster way to get the pixel data for the current\n        // functional group, which we use typed array view\n\n        const functionGroupPixelData = new Uint8Array(\n          segPixelData.buffer,\n          functionalGroupIndex * step,\n          step\n        );\n\n        const functionalGroupStartIndex = imageIdIndex * step;\n        const functionalGroupEndIndex = (imageIdIndex + 1) * step;\n\n        // Note: this for loop is not optimized, since DICOM SEG stores\n        // each segment as a separate labelmap so if there is a slice\n        // that has multiple segments, we will have to loop over each\n        // segment and we cannot use the TypedArray set method.\n        for (\n          let i = functionalGroupStartIndex, j = 0;\n          i < functionalGroupEndIndex;\n          i++, j++\n        ) {\n          if (functionGroupPixelData[j] !== 0) {\n            if (derivedVolumeScalarData[i] !== 0) {\n              overlappingSegments = true;\n            }\n\n            derivedVolumeScalarData[i] = segmentIndex;\n\n            // centroid calculations\n            segmentX += i % columns;\n            segmentY += Math.floor(i / columns) % rows;\n            segmentZ += Math.floor(i / (columns * rows));\n            count++;\n          }\n        }\n      }\n\n      // centroid calculations\n      const x = Math.floor(segmentX / count);\n      const y = Math.floor(segmentY / count);\n      const z = Math.floor(segmentZ / count);\n\n      const centerWorld = derivedVolume.imageData.indexToWorld([x, y, z]);\n\n      segmentation.cachedStats = {\n        ...segmentation.cachedStats,\n        segmentCenter: {\n          ...segmentation.cachedStats.segmentCenter,\n          [segmentIndex]: {\n            center: {\n              image: [x, y, z],\n              world: centerWorld,\n            },\n            modifiedTime: segDisplaySet.SeriesDate,\n          },\n        },\n      };\n\n      const numInitialized = Object.keys(segmentation.cachedStats.segmentCenter)\n        .length;\n\n      // Calculate percentage completed\n      const percentComplete = Math.round((numInitialized / numSegments) * 100);\n\n      this._broadcastEvent(EVENTS.SEGMENT_LOADING_COMPLETE, {\n        percentComplete,\n        numSegments: numSegments,\n      });\n    };\n\n    const promiseArray = [];\n\n    for (const segmentIndex in segments) {\n      const segmentInfo = segments[segmentIndex];\n\n      // Important: we need a non-blocking way to update the segmentation\n      // state, otherwise the UI will freeze and the user will not be able\n      // to interact with the app or progress bars will not be updated.\n      const promise = new Promise<void>((resolve, reject) => {\n        setTimeout(() => {\n          _segmentInfoUpdate(segmentInfo, segmentIndex);\n          resolve();\n        }, 0);\n      });\n\n      promiseArray.push(promise);\n    }\n\n    await Promise.all(promiseArray);\n\n    segmentation.segmentCount = Object.keys(segments).length;\n    segmentation.segments = [null]; // segment 0\n\n    Object.keys(segments).forEach(segmentIndex => {\n      const segmentInfo = segments[segmentIndex];\n      const segIndex = Number(segmentIndex);\n\n      segmentation.segments[segIndex] = {\n        label: segmentInfo.label || `Segment ${segIndex}`,\n        segmentIndex: Number(segmentIndex),\n        color: [\n          segmentInfo.color[0],\n          segmentInfo.color[1],\n          segmentInfo.color[2],\n        ],\n        opacity: segmentInfo.color[3],\n        isVisible: true,\n        isLocked: false,\n      };\n    });\n\n    segDisplaySet.isLoaded = true;\n\n    this._broadcastEvent(EVENTS.SEGMENTATION_LOADING_COMPLETE, {\n      segmentationId,\n      segDisplaySet,\n      overlappingSegments,\n    });\n\n    return this.addOrUpdateSegmentation(segmentation, suppressEvents);\n  }\n\n  public async createSegmentationForRTDisplaySet(\n    rtDisplaySet,\n    segmentationId?: string,\n    suppressEvents = false\n  ): Promise<string> {\n    // Todo: we currently only have support for contour representation for initial\n    // RT display\n    const representationType = CONTOUR;\n    segmentationId = segmentationId ?? rtDisplaySet.displaySetInstanceUID;\n    const { structureSet } = rtDisplaySet;\n\n    if (!structureSet) {\n      throw new Error(\n        'To create the contours from RT displaySet, the displaySet should be loaded first, you can perform rtDisplaySet.load() before calling this method.'\n      );\n    }\n\n    const defaultScheme = this._getDefaultSegmentationScheme();\n    const rtDisplaySetUID = rtDisplaySet.displaySetInstanceUID;\n\n    const allRTStructData = mapROIContoursToRTStructData(\n      structureSet,\n      rtDisplaySetUID\n    );\n\n    // sort by segmentIndex\n    allRTStructData.sort((a, b) => a.segmentIndex - b.segmentIndex);\n\n    const geometryIds = allRTStructData.map(({ geometryId }) => geometryId);\n\n    const segmentation: Segmentation = {\n      ...defaultScheme,\n      id: segmentationId,\n      displaySetInstanceUID: rtDisplaySetUID,\n      type: representationType,\n      representationData: {\n        [CONTOUR]: {\n          geometryIds,\n        },\n      },\n    };\n\n    const cachedSegmentation = this.getSegmentation(segmentationId);\n\n    if (cachedSegmentation) {\n      // if the labelmap with the same segmentationId already exists, we can\n      // just assume that the segmentation is already created and move on with\n      // updating the state\n      return this.addOrUpdateSegmentation(\n        Object.assign(segmentation, cachedSegmentation),\n        suppressEvents\n      );\n    }\n\n    if (!structureSet.ROIContours?.length) {\n      throw new Error(\n        'The structureSet does not contain any ROIContours. Please ensure the structureSet is loaded first.'\n      );\n    }\n    const segmentsCachedStats = {};\n    const initializeContour = async rtStructData => {\n      const { data, id, color, segmentIndex, geometryId } = rtStructData;\n      const geometry = await geometryLoader.createAndCacheGeometry(geometryId, {\n        geometryData: {\n          data,\n          id,\n          color,\n          frameOfReferenceUID: structureSet.frameOfReferenceUID,\n          segmentIndex,\n        },\n        type: csEnums.GeometryType.CONTOUR,\n      });\n\n      const contourSet = geometry.data;\n      const centroid = contourSet.getCentroid();\n\n      segmentsCachedStats[segmentIndex] = {\n        center: { world: centroid },\n        modifiedTime: rtDisplaySet.SeriesDate, // we use the SeriesDate as the modifiedTime since this is the first time we are creating the segmentation\n      };\n\n      segmentation.segments[segmentIndex] = {\n        label: id,\n        segmentIndex,\n        color,\n        ...SEGMENT_CONSTANT,\n      };\n\n      const numInitialized = Object.keys(segmentsCachedStats).length;\n\n      // Calculate percentage completed\n      const percentComplete = Math.round(\n        (numInitialized / allRTStructData.length) * 100\n      );\n\n      this._broadcastEvent(EVENTS.SEGMENT_LOADING_COMPLETE, {\n        percentComplete,\n        // Note: this is not the geometryIds length since there might be\n        // some missing ROINumbers\n        numSegments: allRTStructData.length,\n      });\n    };\n\n    const promiseArray = [];\n\n    for (let i = 0; i < allRTStructData.length; i++) {\n      const promise = new Promise<void>((resolve, reject) => {\n        setTimeout(() => {\n          initializeContour(allRTStructData[i]).then(() => {\n            resolve();\n          });\n        }, 0);\n      });\n\n      promiseArray.push(promise);\n    }\n\n    await Promise.all(promiseArray);\n\n    segmentation.segmentCount = allRTStructData.length;\n    rtDisplaySet.isLoaded = true;\n\n    segmentation.cachedStats = {\n      ...segmentation.cachedStats,\n      segmentCenter: {\n        ...segmentation.cachedStats.segmentCenter,\n        ...segmentsCachedStats,\n      },\n    };\n\n    this._broadcastEvent(EVENTS.SEGMENTATION_LOADING_COMPLETE, {\n      segmentationId,\n      rtDisplaySet,\n    });\n\n    return this.addOrUpdateSegmentation(segmentation, suppressEvents);\n  }\n\n  public jumpToSegmentCenter(\n    segmentationId: string,\n    segmentIndex: number,\n    toolGroupId?: string,\n    highlightAlpha = 0.9,\n    highlightSegment = true,\n    animationLength = 750,\n    highlightHideOthers = false,\n    highlightFunctionType = 'ease-in-out' // todo: make animation functions configurable from outside\n  ): void {\n    const { toolGroupService } = this.servicesManager.services;\n    const center = this._getSegmentCenter(segmentationId, segmentIndex);\n\n    const { world } = center;\n\n    // todo: generalize\n    toolGroupId =\n      toolGroupId || this._getToolGroupIdsWithSegmentation(segmentationId);\n\n    const toolGroups = [];\n\n    if (Array.isArray(toolGroupId)) {\n      toolGroupId.forEach(toolGroup => {\n        toolGroups.push(toolGroupService.getToolGroup(toolGroup));\n      });\n    } else {\n      toolGroups.push(toolGroupService.getToolGroup(toolGroupId));\n    }\n\n    toolGroups.forEach(toolGroup => {\n      const viewportsInfo = toolGroup.getViewportsInfo();\n\n      // @ts-ignore\n      for (const { viewportId, renderingEngineId } of viewportsInfo) {\n        const { viewport } = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n        cstUtils.viewport.jumpToWorld(viewport, world);\n      }\n\n      if (highlightSegment) {\n        this.highlightSegment(\n          segmentationId,\n          segmentIndex,\n          toolGroup.id,\n          highlightAlpha,\n          animationLength,\n          highlightHideOthers,\n          highlightFunctionType\n        );\n      }\n    });\n  }\n\n  public highlightSegment(\n    segmentationId: string,\n    segmentIndex: number,\n    toolGroupId?: string,\n    alpha = 0.9,\n    animationLength = 750,\n    hideOthers = true,\n    highlightFunctionType = 'ease-in-out'\n  ): void {\n    if (this.highlightIntervalId) {\n      clearInterval(this.highlightIntervalId);\n    }\n\n    const segmentation = this.getSegmentation(segmentationId);\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    const { type } = segmentationRepresentation;\n    const { segments } = segmentation;\n\n    const highlightFn =\n      type === LABELMAP\n        ? this._highlightLabelmap.bind(this)\n        : this._highlightContour.bind(this);\n\n    const adjustedAlpha = type === LABELMAP ? alpha : 1 - alpha;\n\n    highlightFn(\n      segmentIndex,\n      adjustedAlpha,\n      hideOthers,\n      segments,\n      toolGroupId,\n      animationLength,\n      segmentationRepresentation\n    );\n  }\n\n  public createSegmentationForDisplaySet = async (\n    displaySetInstanceUID: string,\n    options?: {\n      segmentationId: string;\n      label: string;\n    }\n  ): Promise<string> => {\n    const { displaySetService } = this.servicesManager.services;\n\n    const displaySet = displaySetService.getDisplaySetByUID(\n      displaySetInstanceUID\n    );\n\n    // Todo: we currently only support labelmap for segmentation for a displaySet\n    const representationType = LABELMAP;\n\n    const volumeId = this._getVolumeIdForDisplaySet(displaySet);\n\n    const segmentationId = options?.segmentationId ?? `${csUtils.uuidv4()}`;\n\n    // Force use of a Uint8Array SharedArrayBuffer for the segmentation to save space and so\n    // it is easily compressible in worker thread.\n    await volumeLoader.createAndCacheDerivedVolume(volumeId, {\n      volumeId: segmentationId,\n      targetBuffer: {\n        type: 'Uint8Array',\n        sharedArrayBuffer: true,\n      },\n    });\n\n    const defaultScheme = this._getDefaultSegmentationScheme();\n\n    const segmentation: Segmentation = {\n      ...defaultScheme,\n      id: segmentationId,\n      displaySetInstanceUID,\n      label: options?.label,\n      // We should set it as active by default, as it created for display\n      isActive: true,\n      type: representationType,\n      representationData: {\n        LABELMAP: {\n          volumeId: segmentationId,\n          referencedVolumeId: volumeId, // Todo: this is so ugly\n        },\n      },\n    };\n\n    this.addOrUpdateSegmentation(segmentation);\n\n    return segmentationId;\n  };\n\n  /**\n   * Toggles the visibility of a segmentation in the state, and broadcasts the event.\n   * Note: this method does not update the segmentation state in the source. It only\n   * updates the state, and there should be separate listeners for that.\n   * @param ids segmentation ids\n   */\n  public toggleSegmentationVisibility = (segmentationId: string): void => {\n    this._toggleSegmentationVisibility(segmentationId, false);\n  };\n\n  public addSegmentationRepresentationToToolGroup = async (\n    toolGroupId: string,\n    segmentationId: string,\n    hydrateSegmentation = false,\n    representationType = csToolsEnums.SegmentationRepresentations.Labelmap\n  ): Promise<void> => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (!segmentation) {\n      throw new Error(\n        `Segmentation with segmentationId ${segmentationId} not found.`\n      );\n    }\n\n    if (hydrateSegmentation) {\n      // hydrate the segmentation if it's not hydrated yet\n      segmentation.hydrated = true;\n    }\n\n    const { colorLUTIndex } = segmentation;\n\n    // Based on the segmentationId, set the colorLUTIndex.\n    const segmentationRepresentationUIDs = await cstSegmentation.addSegmentationRepresentations(\n      toolGroupId,\n      [\n        {\n          segmentationId,\n          type: representationType,\n        },\n      ]\n    );\n\n    // set the latest segmentation representation as active one\n    this._setActiveSegmentationForToolGroup(\n      segmentationId,\n      toolGroupId,\n      segmentationRepresentationUIDs[0]\n    );\n\n    cstSegmentation.config.color.setColorLUT(\n      toolGroupId,\n      segmentationRepresentationUIDs[0],\n      colorLUTIndex\n    );\n\n    // add the segmentation segments properly\n    for (const segment of segmentation.segments) {\n      if (segment === null || segment === undefined) {\n        continue;\n      }\n\n      const {\n        segmentIndex,\n        color,\n        isLocked,\n        isVisible: visibility,\n        opacity,\n      } = segment;\n\n      const suppressEvents = true;\n\n      if (color !== undefined) {\n        this._setSegmentColor(\n          segmentationId,\n          segmentIndex,\n          color,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (opacity !== undefined) {\n        this._setSegmentOpacity(\n          segmentationId,\n          segmentIndex,\n          opacity,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (visibility !== undefined) {\n        this._setSegmentVisibility(\n          segmentationId,\n          segmentIndex,\n          visibility,\n          toolGroupId,\n          suppressEvents\n        );\n      }\n\n      if (isLocked !== undefined) {\n        this._setSegmentLocked(\n          segmentationId,\n          segmentIndex,\n          isLocked,\n          suppressEvents\n        );\n      }\n    }\n  };\n\n  public setSegmentRGBAColorForSegmentation = (\n    segmentationId: string,\n    segmentIndex: number,\n    rgbaColor,\n    toolGroupId?: string\n  ) => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    this._setSegmentOpacity(\n      segmentationId,\n      segmentIndex,\n      rgbaColor[3],\n      toolGroupId, // toolGroupId\n      true\n    );\n    this._setSegmentColor(\n      segmentationId,\n      segmentIndex,\n      [rgbaColor[0], rgbaColor[1], rgbaColor[2]],\n      toolGroupId, // toolGroupId\n      true\n    );\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n      segmentation,\n    });\n  };\n\n  public getToolGroupIdsWithSegmentation = (\n    segmentationId: string\n  ): string[] => {\n    const toolGroupIds = cstSegmentation.state.getToolGroupIdsWithSegmentation(\n      segmentationId\n    );\n    return toolGroupIds;\n  };\n\n  public hydrateSegmentation = (\n    segmentationId: string,\n    suppressEvents = false\n  ): void => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (!segmentation) {\n      throw new Error(\n        `Segmentation with segmentationId ${segmentationId} not found.`\n      );\n    }\n\n    segmentation.hydrated = true;\n\n    if (!suppressEvents) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _highlightLabelmap(\n    segmentIndex: number,\n    alpha: number,\n    hideOthers: boolean,\n    segments: Segment[],\n    toolGroupId: string,\n    animationLength: number,\n    segmentationRepresentation: cstTypes.ToolGroupSpecificRepresentation\n  ) {\n    const newSegmentSpecificConfig = {\n      [segmentIndex]: {\n        LABELMAP: {\n          fillAlpha: alpha,\n        },\n      },\n    };\n\n    if (hideOthers) {\n      for (let i = 0; i < segments.length; i++) {\n        if (i !== segmentIndex) {\n          newSegmentSpecificConfig[i] = {\n            LABELMAP: {\n              fillAlpha: 0,\n            },\n          };\n        }\n      }\n    }\n\n    const { fillAlpha } = this.getConfiguration(toolGroupId);\n\n    let startTime: number = null;\n    const animation = (timestamp: number) => {\n      if (startTime === null) {\n        startTime = timestamp;\n      }\n\n      const elapsed = timestamp - startTime;\n      const progress = Math.min(elapsed / animationLength, 1);\n\n      cstSegmentation.config.setSegmentSpecificConfig(\n        toolGroupId,\n        segmentationRepresentation.segmentationRepresentationUID,\n        {\n          [segmentIndex]: {\n            LABELMAP: {\n              fillAlpha: easeInOutBell(progress, fillAlpha),\n            },\n          },\n        }\n      );\n\n      if (progress < 1) {\n        requestAnimationFrame(animation);\n      } else {\n        cstSegmentation.config.setSegmentSpecificConfig(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          {}\n        );\n      }\n    };\n\n    requestAnimationFrame(animation);\n  }\n\n  private _highlightContour(\n    segmentIndex: number,\n    alpha: number,\n    hideOthers: boolean,\n    segments: Segment[],\n    toolGroupId: string,\n    animationLength: number,\n    segmentationRepresentation: cstTypes.ToolGroupSpecificRepresentation\n  ) {\n    const startTime = performance.now();\n\n    const animate = (currentTime: number) => {\n      const progress = (currentTime - startTime) / animationLength;\n      if (progress >= 1) {\n        cstSegmentation.config.setSegmentSpecificConfig(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          {}\n        );\n        return;\n      }\n\n      const reversedProgress = reverseEaseInOutBell(progress, 0.1);\n      cstSegmentation.config.setSegmentSpecificConfig(\n        toolGroupId,\n        segmentationRepresentation.segmentationRepresentationUID,\n        {\n          [segmentIndex]: {\n            CONTOUR: {\n              fillAlpha: reversedProgress,\n            },\n          },\n        }\n      );\n\n      requestAnimationFrame(animate);\n    };\n\n    requestAnimationFrame(animate);\n  }\n\n  public removeSegmentationRepresentationFromToolGroup(\n    toolGroupId: string,\n    segmentationRepresentationUIDsIds?: string[]\n  ): void {\n    const uids = segmentationRepresentationUIDsIds || [];\n    if (!uids.length) {\n      const representations = cstSegmentation.state.getSegmentationRepresentations(\n        toolGroupId\n      );\n\n      if (!representations || !representations.length) {\n        return;\n      }\n\n      uids.push(\n        ...representations.map(rep => rep.segmentationRepresentationUID)\n      );\n    }\n\n    cstSegmentation.removeSegmentationsFromToolGroup(toolGroupId, uids);\n  }\n\n  /**\n   * Removes a segmentation and broadcasts the removed event.\n   *\n   * @param {string} segmentationId The segmentation id\n   */\n  public remove(segmentationId: string): void {\n    const segmentation = this.segmentations[segmentationId];\n    const wasActive = segmentation.isActive;\n\n    if (!segmentationId || !segmentation) {\n      console.warn(\n        `No segmentationId provided, or unable to find segmentation by id.`\n      );\n      return;\n    }\n\n    const { colorLUTIndex } = segmentation;\n\n    this._removeSegmentationFromCornerstone(segmentationId);\n\n    // Delete associated colormap\n    // Todo: bring this back\n    cstSegmentation.state.removeColorLUT(colorLUTIndex);\n\n    delete this.segmentations[segmentationId];\n\n    // If this segmentation was active, and there is another segmentation, set another one active.\n\n    if (wasActive) {\n      const remainingSegmentations = this._getSegmentations();\n\n      if (remainingSegmentations.length) {\n        const { id } = remainingSegmentations[0];\n\n        this._setActiveSegmentationForToolGroup(\n          id,\n          this._getFirstToolGroupId(),\n          false\n        );\n      }\n    }\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_REMOVED, {\n      segmentationId,\n    });\n  }\n\n  public getConfiguration = (toolGroupId?: string): SegmentationConfig => {\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const brushSize = 1;\n    // const brushSize = cstUtils.segmentation.getBrushSizeForToolGroup(\n    //   toolGroupId\n    // );\n\n    const brushThresholdGate = 1;\n    // const brushThresholdGate = cstUtils.segmentation.getBrushThresholdForToolGroup(\n    //   toolGroupId\n    // );\n\n    const segmentationRepresentations = this.getSegmentationRepresentationsForToolGroup(\n      toolGroupId\n    );\n\n    const typeToUse = segmentationRepresentations?.[0]?.type || LABELMAP;\n\n    const config = cstSegmentation.config.getGlobalConfig();\n    const { renderInactiveSegmentations } = config;\n\n    const representation = config.representations[typeToUse];\n\n    const {\n      renderOutline,\n      outlineWidthActive,\n      renderFill,\n      fillAlpha,\n      fillAlphaInactive,\n      outlineOpacity,\n      outlineOpacityInactive,\n    } = representation;\n\n    return {\n      brushSize,\n      brushThresholdGate,\n      fillAlpha,\n      fillAlphaInactive,\n      outlineWidthActive,\n      renderFill,\n      renderInactiveSegmentations,\n      renderOutline,\n      outlineOpacity,\n      outlineOpacityInactive,\n    };\n  };\n\n  public setConfiguration = (configuration: SegmentationConfig): void => {\n    const {\n      brushSize,\n      brushThresholdGate,\n      fillAlpha,\n      fillAlphaInactive,\n      outlineWidthActive,\n      outlineOpacity,\n      renderFill,\n      renderInactiveSegmentations,\n      renderOutline,\n    } = configuration;\n\n    const setConfigValueIfDefined = (key, value, transformFn = null) => {\n      if (value !== undefined) {\n        const transformedValue = transformFn ? transformFn(value) : value;\n        this._setSegmentationConfig(key, transformedValue);\n      }\n    };\n\n    setConfigValueIfDefined('renderOutline', renderOutline);\n    setConfigValueIfDefined('outlineWidthActive', outlineWidthActive);\n    setConfigValueIfDefined('outlineOpacity', outlineOpacity, v => v / 100);\n    setConfigValueIfDefined('fillAlpha', fillAlpha, v => v / 100);\n    setConfigValueIfDefined('renderFill', renderFill);\n    setConfigValueIfDefined(\n      'fillAlphaInactive',\n      fillAlphaInactive,\n      v => v / 100\n    );\n    setConfigValueIfDefined('outlineOpacityInactive', fillAlphaInactive, v =>\n      Math.max(0.75, v / 100)\n    );\n\n    if (renderInactiveSegmentations !== undefined) {\n      const config = cstSegmentation.config.getGlobalConfig();\n      config.renderInactiveSegmentations = renderInactiveSegmentations;\n      cstSegmentation.config.setGlobalConfig(config);\n    }\n\n    // if (brushSize !== undefined) {\n    //   const { toolGroupService } = this.servicesManager.services;\n\n    //   const toolGroupIds = toolGroupService.getToolGroupIds();\n\n    //   toolGroupIds.forEach(toolGroupId => {\n    //     cstUtils.segmentation.setBrushSizeForToolGroup(toolGroupId, brushSize);\n    //   });\n    // }\n\n    // if (brushThresholdGate !== undefined) {\n    //   const { toolGroupService } = this.servicesManager.services;\n\n    //   const toolGroupIds = toolGroupService.getFirstToolGroupIds();\n\n    //   toolGroupIds.forEach(toolGroupId => {\n    //     cstUtils.segmentation.setBrushThresholdForToolGroup(\n    //       toolGroupId,\n    //       brushThresholdGate\n    //     );\n    //   });\n    // }\n\n    this._broadcastEvent(\n      this.EVENTS.SEGMENTATION_CONFIGURATION_CHANGED,\n      this.getConfiguration()\n    );\n  };\n\n  public getLabelmapVolume = (segmentationId: string) => {\n    return cache.getVolume(segmentationId);\n  };\n\n  public getSegmentationRepresentationsForToolGroup = toolGroupId => {\n    return cstSegmentation.state.getSegmentationRepresentations(toolGroupId);\n  };\n\n  public setSegmentLabelForSegmentation(\n    segmentationId: string,\n    segmentIndex: number,\n    label: string\n  ) {\n    this._setSegmentLabelForSegmentation(segmentationId, segmentIndex, label);\n  }\n\n  private _setSegmentLabelForSegmentation(\n    segmentationId: string,\n    segmentIndex: number,\n    label: string,\n    suppressEvents = false\n  ) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = segmentation.segments[segmentIndex];\n\n    if (segmentInfo === undefined) {\n      throw new Error(\n        `Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`\n      );\n    }\n\n    segmentInfo.label = label;\n\n    if (suppressEvents === false) {\n      // this._setSegmentationModified(segmentationId);\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  public shouldRenderSegmentation(\n    viewportDisplaySetInstanceUIDs,\n    segDisplaySetInstanceUID\n  ) {\n    if (\n      !viewportDisplaySetInstanceUIDs ||\n      !viewportDisplaySetInstanceUIDs.length\n    ) {\n      return false;\n    }\n\n    const { displaySetService } = this.servicesManager.services;\n\n    let shouldDisplaySeg = false;\n\n    const segDisplaySet = displaySetService.getDisplaySetByUID(\n      segDisplaySetInstanceUID\n    );\n\n    const segFrameOfReferenceUID = this._getFrameOfReferenceUIDForSeg(\n      segDisplaySet\n    );\n\n    // check if the displaySet is sharing the same frameOfReferenceUID\n    // with the new segmentation\n    for (const displaySetInstanceUID of viewportDisplaySetInstanceUIDs) {\n      const displaySet = displaySetService.getDisplaySetByUID(\n        displaySetInstanceUID\n      );\n\n      // Todo: this might not be ideal for use cases such as 4D, since we\n      // don't want to show the segmentation for all the frames\n      if (\n        displaySet.isReconstructable &&\n        displaySet?.images?.[0]?.FrameOfReferenceUID === segFrameOfReferenceUID\n      ) {\n        shouldDisplaySeg = true;\n        break;\n      }\n    }\n\n    return shouldDisplaySeg;\n  }\n\n  private _getDefaultSegmentationScheme() {\n    return {\n      activeSegmentIndex: 1,\n      cachedStats: {},\n      label: '',\n      segmentsLocked: [],\n      displayText: [],\n      hydrated: false, // by default we don't hydrate the segmentation for SEG displaySets\n      segmentCount: 0,\n      segments: [],\n      isVisible: true,\n      isActive: false,\n      colorLUTIndex: 0,\n    };\n  }\n\n  private _setActiveSegmentationForToolGroup(\n    segmentationId: string,\n    toolGroupId: string,\n    suppressEvents = false\n  ) {\n    const segmentations = this._getSegmentations();\n    const targetSegmentation = this.getSegmentation(segmentationId);\n\n    if (targetSegmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    segmentations.forEach(segmentation => {\n      segmentation.isActive = segmentation.id === segmentationId;\n    });\n\n    const representation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    cstSegmentation.activeSegmentation.setActiveSegmentationRepresentation(\n      toolGroupId,\n      representation.segmentationRepresentationUID\n    );\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation: targetSegmentation,\n      });\n    }\n  }\n\n  private _toggleSegmentationVisibility = (\n    segmentationId: string,\n    suppressEvents = false\n  ) => {\n    const segmentation = this.segmentations[segmentationId];\n\n    if (!segmentation) {\n      throw new Error(\n        `Segmentation with segmentationId ${segmentationId} not found.`\n      );\n    }\n\n    segmentation.isVisible = !segmentation.isVisible;\n\n    this._updateCornerstoneSegmentationVisibility(segmentationId);\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _setActiveSegment(\n    segmentationId: string,\n    segmentIndex: number,\n    suppressEvents = false\n  ) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    cstSegmentation.segmentIndex.setActiveSegmentIndex(\n      segmentationId,\n      segmentIndex\n    );\n\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _getSegmentInfo(segmentation: Segmentation, segmentIndex: number) {\n    const segments = segmentation.segments;\n\n    if (!segments) {\n      return;\n    }\n\n    if (segments && segments.length > 0) {\n      return segments[segmentIndex];\n    }\n  }\n\n  private _getVolumeIdForDisplaySet(displaySet) {\n    const volumeLoaderSchema =\n      displaySet.volumeLoaderSchema ?? VOLUME_LOADER_SCHEME;\n\n    return `${volumeLoaderSchema}:${displaySet.displaySetInstanceUID}`;\n  }\n\n  private _setSegmentColor = (\n    segmentationId: string,\n    segmentIndex: number,\n    color: ohifTypes.RGB,\n    toolGroupId?: string,\n    suppressEvents = false\n  ) => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(\n        `Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`\n      );\n    }\n\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    if (!segmentationRepresentation) {\n      throw new Error(\n        'Must add representation to toolgroup before setting segments'\n      );\n    }\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n\n    const rgbaColor = cstSegmentation.config.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    cstSegmentation.config.color.setColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex,\n      [...color, rgbaColor[3]]\n    );\n\n    segmentInfo.color = color;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _getSegmentCenter(segmentationId, segmentIndex) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (!segmentation) {\n      return;\n    }\n\n    const { cachedStats } = segmentation;\n\n    if (!cachedStats) {\n      return;\n    }\n\n    const { segmentCenter } = cachedStats;\n\n    if (!segmentCenter) {\n      return;\n    }\n\n    const { center } = segmentCenter[segmentIndex];\n\n    return center;\n  }\n\n  private _setSegmentLocked(\n    segmentationId: string,\n    segmentIndex: number,\n    isLocked: boolean,\n    suppressEvents = false\n  ) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(\n        `Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`\n      );\n    }\n\n    segmentInfo.isLocked = isLocked;\n\n    cstSegmentation.segmentLocking.setSegmentIndexLocked(\n      segmentationId,\n      segmentIndex,\n      isLocked\n    );\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _setSegmentVisibility(\n    segmentationId: string,\n    segmentIndex: number,\n    isVisible: boolean,\n    toolGroupId?: string,\n    suppressEvents = false\n  ) {\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const {\n      segmentationRepresentationUID,\n      segmentation,\n    } = this._getSegmentationInfo(segmentationId, toolGroupId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(\n        `Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`\n      );\n    }\n\n    segmentInfo.isVisible = isVisible;\n\n    cstSegmentation.config.visibility.setSegmentVisibility(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex,\n      isVisible\n    );\n\n    // make sure to update the isVisible flag on the segmentation\n    // if a segment becomes invisible then the segmentation should be invisible\n    // in the status as well, and show correct icon\n    segmentation.isVisible = segmentation.segments\n      .filter(Boolean)\n      .every(segment => segment.isVisible);\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _setSegmentOpacity = (\n    segmentationId: string,\n    segmentIndex: number,\n    opacity: number,\n    toolGroupId?: string,\n    suppressEvents = false\n  ) => {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(\n        `Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`\n      );\n    }\n\n    toolGroupId = toolGroupId ?? this._getFirstToolGroupId();\n\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    if (!segmentationRepresentation) {\n      throw new Error(\n        'Must add representation to toolgroup before setting segments'\n      );\n    }\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n\n    const rgbaColor = cstSegmentation.config.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    cstSegmentation.config.color.setColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex,\n      [rgbaColor[0], rgbaColor[1], rgbaColor[2], opacity]\n    );\n\n    segmentInfo.opacity = opacity;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  };\n\n  private _setSegmentLabel(\n    segmentationId: string,\n    segmentIndex: number,\n    segmentLabel: string,\n    suppressEvents = false\n  ) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n\n    const segmentInfo = this._getSegmentInfo(segmentation, segmentIndex);\n\n    if (segmentInfo === undefined) {\n      throw new Error(\n        `Segment ${segmentIndex} not yet added to segmentation: ${segmentationId}`\n      );\n    }\n\n    segmentInfo.label = segmentLabel;\n\n    if (suppressEvents === false) {\n      this._broadcastEvent(this.EVENTS.SEGMENTATION_UPDATED, {\n        segmentation,\n      });\n    }\n  }\n\n  private _getSegmentationRepresentation(segmentationId, toolGroupId) {\n    const segmentationRepresentations = this.getSegmentationRepresentationsForToolGroup(\n      toolGroupId\n    );\n\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // Todo: this finds the first segmentation representation that matches the segmentationId\n    // If there are two labelmap representations from the same segmentation, this will not work\n    const representation = segmentationRepresentations.find(\n      representation => representation.segmentationId === segmentationId\n    );\n\n    return representation;\n  }\n\n  private _setSegmentationConfig = (property, value) => {\n    // Todo: currently we only support global config, and we get the type\n    // from the first segmentation\n    const typeToUse = this.getSegmentations()[0].type;\n\n    const { cornerstoneViewportService } = this.servicesManager.services;\n\n    const config = cstSegmentation.config.getGlobalConfig();\n\n    config.representations[typeToUse][property] = value;\n\n    // Todo: add non global (representation specific config as well)\n    cstSegmentation.config.setGlobalConfig(config);\n\n    const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n    const viewportIds = cornerstoneViewportService.getViewportIds();\n\n    renderingEngine.renderViewports(viewportIds);\n  };\n\n  private _initSegmentationService() {\n    // Connect Segmentation Service to Cornerstone3D.\n    eventTarget.addEventListener(\n      csToolsEnums.Events.SEGMENTATION_MODIFIED,\n      this._onSegmentationModifiedFromSource\n    );\n\n    eventTarget.addEventListener(\n      csToolsEnums.Events.SEGMENTATION_DATA_MODIFIED,\n      this._onSegmentationDataModified\n    );\n  }\n\n  private _onSegmentationDataModified = evt => {\n    const { segmentationId } = evt.detail;\n\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      // Part of add operation, not update operation, exit early.\n      return;\n    }\n\n    this._broadcastEvent(this.EVENTS.SEGMENTATION_DATA_MODIFIED, {\n      segmentation,\n    });\n  };\n\n  private _onSegmentationModifiedFromSource = evt => {\n    const { segmentationId } = evt.detail;\n\n    const segmentation = this.segmentations[segmentationId];\n\n    if (segmentation === undefined) {\n      // Part of add operation, not update operation, exit early.\n      return;\n    }\n\n    const segmentationState = cstSegmentation.state.getSegmentation(\n      segmentationId\n    );\n\n    if (!segmentationState) {\n      return;\n    }\n\n    const {\n      activeSegmentIndex,\n      cachedStats,\n      segmentsLocked,\n      label,\n      type,\n    } = segmentationState;\n\n    if (![LABELMAP, CONTOUR].includes(type)) {\n      throw new Error(\n        `Unsupported segmentation type: ${type}. Only ${LABELMAP} and ${CONTOUR} are supported.`\n      );\n    }\n\n    const representationData = segmentationState.representationData[type];\n\n    // TODO: handle other representations when available in cornerstone3D\n    const segmentationSchema = {\n      ...segmentation,\n      activeSegmentIndex,\n      cachedStats,\n      displayText: [],\n      id: segmentationId,\n      label,\n      segmentsLocked,\n      type,\n      representationData: {\n        [type]: {\n          ...representationData,\n        },\n      },\n    };\n\n    try {\n      this.addOrUpdateSegmentation(segmentationSchema);\n    } catch (error) {\n      console.warn(\n        `Failed to add/update segmentation ${segmentationId}`,\n        error\n      );\n    }\n  };\n\n  private _getSegmentationInfo(segmentationId: string, toolGroupId: string) {\n    const segmentation = this.getSegmentation(segmentationId);\n\n    if (segmentation === undefined) {\n      throw new Error(`no segmentation for segmentationId: ${segmentationId}`);\n    }\n    const segmentationRepresentation = this._getSegmentationRepresentation(\n      segmentationId,\n      toolGroupId\n    );\n\n    if (!segmentationRepresentation) {\n      throw new Error(\n        'Must add representation to toolgroup before setting segments'\n      );\n    }\n\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n\n    return { segmentationRepresentationUID, segmentation };\n  }\n\n  private _removeSegmentationFromCornerstone(segmentationId: string) {\n    // TODO: This should be from the configuration\n    const removeFromCache = true;\n    const segmentationState = cstSegmentation.state;\n    const sourceSegState = segmentationState.getSegmentation(segmentationId);\n\n    if (!sourceSegState) {\n      return;\n    }\n\n    const toolGroupIds = segmentationState.getToolGroupIdsWithSegmentation(\n      segmentationId\n    );\n\n    toolGroupIds.forEach(toolGroupId => {\n      const segmentationRepresentations = segmentationState.getSegmentationRepresentations(\n        toolGroupId\n      );\n\n      const UIDsToRemove = [];\n      segmentationRepresentations.forEach(representation => {\n        if (representation.segmentationId === segmentationId) {\n          UIDsToRemove.push(representation.segmentationRepresentationUID);\n        }\n      });\n\n      // remove segmentation representations\n      cstSegmentation.removeSegmentationsFromToolGroup(\n        toolGroupId,\n        UIDsToRemove,\n        true // immediate\n      );\n    });\n\n    // cleanup the segmentation state too\n    segmentationState.removeSegmentation(segmentationId);\n\n    if (removeFromCache && cache.getVolumeLoadObject(segmentationId)) {\n      cache.removeVolumeLoadObject(segmentationId);\n    }\n  }\n\n  private _updateCornerstoneSegmentations({\n    segmentationId,\n    notYetUpdatedAtSource,\n  }) {\n    if (notYetUpdatedAtSource === false) {\n      return;\n    }\n    const segmentationState = cstSegmentation.state;\n    const sourceSegmentation = segmentationState.getSegmentation(\n      segmentationId\n    );\n    const segmentation = this.segmentations[segmentationId];\n    const { label, cachedStats } = segmentation;\n\n    // Update the label in the source if necessary\n    if (sourceSegmentation.label !== label) {\n      sourceSegmentation.label = label;\n    }\n\n    if (!isEqual(sourceSegmentation.cachedStats, cachedStats)) {\n      sourceSegmentation.cachedStats = cachedStats;\n    }\n  }\n\n  private _updateCornerstoneSegmentationVisibility = segmentationId => {\n    const segmentationState = cstSegmentation.state;\n    const toolGroupIds = segmentationState.getToolGroupIdsWithSegmentation(\n      segmentationId\n    );\n\n    toolGroupIds.forEach(toolGroupId => {\n      const segmentationRepresentations = cstSegmentation.state.getSegmentationRepresentations(\n        toolGroupId\n      );\n\n      if (segmentationRepresentations.length === 0) {\n        return;\n      }\n\n      // Todo: this finds the first segmentation representation that matches the segmentationId\n      // If there are two labelmap representations from the same segmentation, this will not work\n      const representation = segmentationRepresentations.find(\n        representation => representation.segmentationId === segmentationId\n      );\n\n      const { segmentsHidden } = representation;\n\n      const currentVisibility = segmentsHidden.size === 0 ? true : false;\n      const newVisibility = !currentVisibility;\n\n      cstSegmentation.config.visibility.setSegmentationVisibility(\n        toolGroupId,\n        representation.segmentationRepresentationUID,\n        newVisibility\n      );\n\n      // update segments visibility\n      const { segmentation } = this._getSegmentationInfo(\n        segmentationId,\n        toolGroupId\n      );\n\n      const segments = segmentation.segments.filter(Boolean);\n\n      segments.forEach(segment => {\n        segment.isVisible = newVisibility;\n      });\n    });\n  };\n\n  private _getToolGroupIdsWithSegmentation(segmentationId: string) {\n    const segmentationState = cstSegmentation.state;\n    const toolGroupIds = segmentationState.getToolGroupIdsWithSegmentation(\n      segmentationId\n    );\n\n    return toolGroupIds;\n  }\n\n  private _getFrameOfReferenceUIDForSeg(displaySet) {\n    const frameOfReferenceUID = displaySet.instance?.FrameOfReferenceUID;\n\n    if (frameOfReferenceUID) {\n      return frameOfReferenceUID;\n    }\n\n    // if not found we should try the ReferencedFrameOfReferenceSequence\n    const referencedFrameOfReferenceSequence =\n      displaySet.instance?.ReferencedFrameOfReferenceSequence;\n\n    if (referencedFrameOfReferenceSequence) {\n      return referencedFrameOfReferenceSequence.FrameOfReferenceUID;\n    }\n  }\n\n  private _getFirstToolGroupId = () => {\n    const { toolGroupService } = this.servicesManager.services;\n    const toolGroupIds = toolGroupService.getToolGroupIds();\n\n    return toolGroupIds[0];\n  };\n\n  private getNextColorLUTIndex = (): number => {\n    let i = 0;\n    while (true) {\n      if (cstSegmentation.state.getColorLUT(i) === undefined) {\n        return i;\n      }\n\n      i++;\n    }\n  };\n\n  private generateNewColorLUT() {\n    const newColorLUT = cloneDeep(COLOR_LUT);\n\n    return newColorLUT;\n  }\n\n  /**\n   * Converts object of objects to array.\n   *\n   * @return {Array} Array of objects\n   */\n  private arrayOfObjects = obj => {\n    return Object.entries(obj).map(e => ({ [e[0]]: e[1] }));\n  };\n}\n\nexport default SegmentationService;\nexport { EVENTS, VALUE_TYPES };\n","import SegmentationService from './SegmentationService';\n\nexport default SegmentationService;\n","import {\n  synchronizers,\n  SynchronizerManager,\n  Synchronizer,\n} from '@cornerstonejs/tools';\n\nimport { pubSubServiceInterface, Types, ServicesManager } from '@ohif/core';\n\nconst EVENTS = {\n  TOOL_GROUP_CREATED: 'event::cornerstone::syncgroupservice:toolgroupcreated',\n};\n\n/**\n * @params options - are an optional set of options associated with the first\n * sync group declared.\n */\nexport type SyncCreator = (\n  type: string,\n  options?: Record<string, unknown>\n) => Synchronizer;\n\nexport type SyncGroup = {\n  type: string;\n  id?: string;\n  // Source and target default to true if not specified\n  source?: boolean;\n  target?: boolean;\n  options?: Record<string, unknown>;\n};\n\nconst POSITION = 'cameraposition';\nconst VOI = 'voi';\nconst ZOOMPAN = 'zoompan';\nconst STACKIMAGE = 'stackimage';\n\nconst asSyncGroup = (syncGroup: string | SyncGroup): SyncGroup =>\n  typeof syncGroup === 'string' ? { type: syncGroup } : syncGroup;\n\nexport default class SyncGroupService {\n  static REGISTRATION = {\n    name: 'syncGroupService',\n    altName: 'SyncGroupService',\n    create: ({\n      servicesManager,\n    }: Types.Extensions.ExtensionParams): SyncGroupService => {\n      return new SyncGroupService(servicesManager);\n    },\n  };\n\n  servicesManager: ServicesManager;\n  listeners: { [key: string]: (...args: any[]) => void } = {};\n  EVENTS: { [key: string]: string };\n  synchronizerCreators: Record<string, SyncCreator> = {\n    [POSITION]: synchronizers.createCameraPositionSynchronizer,\n    [VOI]: synchronizers.createVOISynchronizer,\n    [ZOOMPAN]: synchronizers.createZoomPanSynchronizer,\n    [STACKIMAGE]: synchronizers.createStackImageSynchronizer,\n  };\n\n  constructor(serviceManager: ServicesManager) {\n    this.servicesManager = serviceManager;\n    this.listeners = {};\n    this.EVENTS = EVENTS;\n    //\n    Object.assign(this, pubSubServiceInterface);\n  }\n\n  private _createSynchronizer(\n    type: string,\n    id: string,\n    options\n  ): Synchronizer | undefined {\n    const syncCreator = this.synchronizerCreators[type.toLowerCase()];\n    if (syncCreator) {\n      return syncCreator(id, options);\n    } else {\n      console.warn('Unknown synchronizer type', type, id);\n    }\n  }\n\n  /**\n   * Creates a synchronizer type.\n   * @param type is the type of the synchronizer to create\n   * @param creator\n   */\n  public setSynchronizer(type: string, creator: SyncCreator): void {\n    this.synchronizerCreators[type.toLowerCase()] = creator;\n  }\n\n  protected _getOrCreateSynchronizer(\n    type: string,\n    id: string,\n    options: Record<string, unknown>\n  ): Synchronizer | undefined {\n    let synchronizer = SynchronizerManager.getSynchronizer(id);\n\n    if (!synchronizer) {\n      synchronizer = this._createSynchronizer(type, id, options);\n    }\n    return synchronizer;\n  }\n\n  public addViewportToSyncGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    syncGroups?: SyncGroup | string | SyncGroup[] | string[]\n  ): void {\n    if (!syncGroups) {\n      return;\n    }\n\n    const syncGroupsArray = Array.isArray(syncGroups)\n      ? syncGroups\n      : [syncGroups];\n\n    syncGroupsArray.forEach(syncGroup => {\n      const syncGroupObj = asSyncGroup(syncGroup);\n      const {\n        type,\n        target = true,\n        source = true,\n        options = {},\n        id = type,\n      } = syncGroupObj;\n\n      const synchronizer = this._getOrCreateSynchronizer(type, id, options);\n      synchronizer.setOptions(viewportId, options);\n\n      const viewportInfo = { viewportId, renderingEngineId };\n      if (target && source) {\n        synchronizer.add(viewportInfo);\n        return;\n      } else if (source) {\n        synchronizer.addSource(viewportInfo);\n      } else if (target) {\n        synchronizer.addTarget(viewportInfo);\n      }\n    });\n  }\n\n  public destroy(): void {\n    SynchronizerManager.destroy();\n  }\n\n  public removeViewportFromSyncGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    syncGroupId?: string\n  ): void {\n    const synchronizers = SynchronizerManager.getAllSynchronizers();\n\n    const filteredSynchronizers = syncGroupId\n      ? synchronizers.filter(s => s.id === syncGroupId)\n      : synchronizers;\n\n    filteredSynchronizers.forEach(synchronizer => {\n      if (!synchronizer) {\n        return;\n      }\n\n      synchronizer.remove({\n        viewportId,\n        renderingEngineId,\n      });\n\n      // check if any viewport is left in any of the sync groups, if not, delete that sync group\n      const sourceViewports = synchronizer.getSourceViewports();\n      const targetViewports = synchronizer.getTargetViewports();\n\n      if (!sourceViewports.length && !targetViewports.length) {\n        SynchronizerManager.destroySynchronizer(synchronizer.id);\n      }\n    });\n  }\n}\n","import SyncGroupService from './SyncGroupService';\n\nexport default SyncGroupService;\n","import { ToolGroupManager, Enums, Types } from '@cornerstonejs/tools';\n\nimport { Types as OhifTypes, pubSubServiceInterface } from '@ohif/core';\nimport getActiveViewportEnabledElement from '../../utils/getActiveViewportEnabledElement';\n\nconst EVENTS = {\n  VIEWPORT_ADDED: 'event::cornerstone::toolgroupservice:viewportadded',\n  TOOLGROUP_CREATED: 'event::cornerstone::toolgroupservice:toolgroupcreated',\n};\n\ntype Tool = {\n  toolName: string;\n  bindings?: typeof Enums.MouseBindings | Enums.KeyboardBindings;\n};\n\ntype Tools = {\n  active: Tool[];\n  passive?: Tool[];\n  enabled?: Tool[];\n  disabled?: Tool[];\n};\n\nexport default class ToolGroupService {\n  public static REGISTRATION = {\n    name: 'toolGroupService',\n    altName: 'ToolGroupService',\n    create: ({\n      servicesManager,\n    }: OhifTypes.Extensions.ExtensionParams): ToolGroupService => {\n      return new ToolGroupService(servicesManager);\n    },\n  };\n\n  serviceManager: any;\n  private toolGroupIds: Set<string> = new Set();\n  /**\n   * Service-specific\n   */\n  listeners: { [key: string]: Function[] };\n  EVENTS: { [key: string]: string };\n\n  constructor(serviceManager) {\n    const {\n      cornerstoneViewportService,\n      viewportGridService,\n    } = serviceManager.services;\n    this.cornerstoneViewportService = cornerstoneViewportService;\n    this.viewportGridService = viewportGridService;\n    this.listeners = {};\n    this.EVENTS = EVENTS;\n    Object.assign(this, pubSubServiceInterface);\n  }\n\n  onModeExit() {\n    this.destroy();\n  }\n\n  /**\n   * Retrieves a tool group from the ToolGroupManager by tool group ID.\n   * If no tool group ID is provided, it retrieves the tool group of the active viewport.\n   * @param toolGroupId - Optional ID of the tool group to retrieve.\n   * @returns The tool group or undefined if it is not found.\n   */\n  public getToolGroup(toolGroupId?: string): Types.IToolGroup | void {\n    let toolGroupIdToUse = toolGroupId;\n\n    if (!toolGroupIdToUse) {\n      // Use the active viewport's tool group if no tool group id is provided\n      const enabledElement = getActiveViewportEnabledElement(\n        this.viewportGridService\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { renderingEngineId, viewportId } = enabledElement;\n      const toolGroup = ToolGroupManager.getToolGroupForViewport(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!toolGroup) {\n        console.warn(\n          'No tool group found for viewportId:',\n          viewportId,\n          'and renderingEngineId:',\n          renderingEngineId\n        );\n        return;\n      }\n\n      toolGroupIdToUse = toolGroup.id;\n    }\n\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupIdToUse);\n    return toolGroup;\n  }\n\n  public getToolGroupIds(): string[] {\n    return Array.from(this.toolGroupIds);\n  }\n\n  public getToolGroupForViewport(viewportId: string): Types.IToolGroup | void {\n    const renderingEngine = this.cornerstoneViewportService.getRenderingEngine();\n    return ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngine.id\n    );\n  }\n\n  public getActiveToolForViewport(viewportId: string): string {\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId);\n    if (!toolGroup) {\n      return null;\n    }\n\n    return toolGroup.getActivePrimaryMouseButtonTool();\n  }\n\n  public destroy() {\n    ToolGroupManager.destroy();\n    this.toolGroupIds = new Set();\n  }\n\n  public destroyToolGroup(toolGroupId: string) {\n    ToolGroupManager.destroyToolGroup(toolGroupId);\n    this.toolGroupIds.delete(toolGroupId);\n  }\n\n  public removeViewportFromToolGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    deleteToolGroupIfEmpty?: boolean\n  ): void {\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewportId,\n      renderingEngineId\n    );\n\n    if (!toolGroup) {\n      return;\n    }\n\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n\n    const viewportIds = toolGroup.getViewportIds();\n\n    if (viewportIds.length === 0 && deleteToolGroupIfEmpty) {\n      ToolGroupManager.destroyToolGroup(toolGroup.id);\n    }\n  }\n\n  public addViewportToToolGroup(\n    viewportId: string,\n    renderingEngineId: string,\n    toolGroupId?: string\n  ): void {\n    if (!toolGroupId) {\n      // If toolGroupId is not provided, add the viewport to all toolGroups\n      const toolGroups = ToolGroupManager.getAllToolGroups();\n      toolGroups.forEach(toolGroup => {\n        toolGroup.addViewport(viewportId, renderingEngineId);\n      });\n    } else {\n      let toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n      if (!toolGroup) {\n        toolGroup = this.createToolGroup(toolGroupId);\n      }\n\n      toolGroup.addViewport(viewportId, renderingEngineId);\n    }\n\n    this._broadcastEvent(EVENTS.VIEWPORT_ADDED, {\n      viewportId,\n      toolGroupId,\n    });\n  }\n\n  public createToolGroup(toolGroupId: string): Types.IToolGroup {\n    if (this.getToolGroup(toolGroupId)) {\n      throw new Error(`ToolGroup ${toolGroupId} already exists`);\n    }\n\n    // if the toolGroup doesn't exist, create it\n    const toolGroup = ToolGroupManager.createToolGroup(toolGroupId);\n    this.toolGroupIds.add(toolGroupId);\n\n    this._broadcastEvent(EVENTS.TOOLGROUP_CREATED, {\n      toolGroupId,\n    });\n\n    return toolGroup;\n  }\n\n  public addToolsToToolGroup(\n    toolGroupId: string,\n    tools: Array<Tool>,\n    configs: any = {}\n  ): void {\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n    // this.changeConfigurationIfNecessary(toolGroup, volumeId);\n    this._addTools(toolGroup, tools, configs);\n    this._setToolsMode(toolGroup, tools);\n  }\n\n  public createToolGroupAndAddTools(\n    toolGroupId: string,\n    tools: Array<Tool>,\n    configs: any = {}\n  ): Types.IToolGroup {\n    const toolGroup = this.createToolGroup(toolGroupId);\n    this.addToolsToToolGroup(toolGroupId, tools, configs);\n    return toolGroup;\n  }\n\n  /**\n  private changeConfigurationIfNecessary(toolGroup, volumeUID) {\n    // handle specific assignment for volumeUID (e.g., fusion)\n    const toolInstances = toolGroup._toolInstances;\n    // Object.values(toolInstances).forEach(toolInstance => {\n    //   if (toolInstance.configuration) {\n    //     toolInstance.configuration.volumeUID = volumeUID;\n    //   }\n    // });\n  }\n  */\n\n  /**\n   * Get the tool's configuration based on the tool name and tool group id\n   * @param toolGroupId - The id of the tool group that the tool instance belongs to.\n   * @param toolName - The name of the tool\n   * @returns The configuration of the tool.\n   */\n  public getToolConfiguration(toolGroupId: string, toolName: string) {\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n    if (!toolGroup) {\n      return null;\n    }\n\n    const tool = toolGroup.getToolInstance(toolName);\n    if (!tool) {\n      return null;\n    }\n\n    return tool.configuration;\n  }\n\n  /**\n   * Set the tool instance configuration. This will update the tool instance configuration\n   * on the toolGroup\n   * @param toolGroupId - The id of the tool group that the tool instance belongs to.\n   * @param toolName - The name of the tool\n   * @param config - The configuration object that you want to set.\n   */\n  public setToolConfiguration(toolGroupId, toolName, config) {\n    const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);\n    const toolInstance = toolGroup.getToolInstance(toolName);\n    toolInstance.configuration = config;\n  }\n\n  private _getToolNames(toolGroupTools: Tools): string[] {\n    const toolNames = [];\n    if (toolGroupTools.active) {\n      toolGroupTools.active.forEach(tool => {\n        toolNames.push(tool.toolName);\n      });\n    }\n    if (toolGroupTools.passive) {\n      toolGroupTools.passive.forEach(tool => {\n        toolNames.push(tool.toolName);\n      });\n    }\n\n    if (toolGroupTools.enabled) {\n      toolGroupTools.enabled.forEach(tool => {\n        toolNames.push(tool.toolName);\n      });\n    }\n\n    if (toolGroupTools.disabled) {\n      toolGroupTools.disabled.forEach(tool => {\n        toolNames.push(tool.toolName);\n      });\n    }\n\n    return toolNames;\n  }\n\n  private _setToolsMode(toolGroup, tools) {\n    const { active, passive, enabled, disabled } = tools;\n\n    if (active) {\n      active.forEach(({ toolName, bindings }) => {\n        toolGroup.setToolActive(toolName, { bindings });\n      });\n    }\n\n    if (passive) {\n      passive.forEach(({ toolName }) => {\n        toolGroup.setToolPassive(toolName);\n      });\n    }\n\n    if (enabled) {\n      enabled.forEach(({ toolName }) => {\n        toolGroup.setToolEnabled(toolName);\n      });\n    }\n\n    if (disabled) {\n      disabled.forEach(({ toolName }) => {\n        toolGroup.setToolDisabled(toolName);\n      });\n    }\n  }\n\n  private _addTools(toolGroup, tools, configs) {\n    const toolNames = this._getToolNames(tools);\n    toolNames.forEach(toolName => {\n      // Initialize the toolConfig if no configuration is provided\n      const toolConfig = configs[toolName] ?? {};\n\n      // if (volumeUID) {\n      //   toolConfig.volumeUID = volumeUID;\n      // }\n\n      toolGroup.addTool(toolName, { ...toolConfig });\n    });\n  }\n}\n","import ToolGroupService from './ToolGroupService';\n\nexport default ToolGroupService;\n","import { PubSubService, ServicesManager } from '@ohif/core';\nimport * as OhifTypes from '@ohif/core/types';\nimport {\n  RenderingEngine,\n  StackViewport,\n  Types,\n  getRenderingEngine,\n  utilities as csUtils,\n  VolumeViewport,\n  VolumeViewport3D,\n  cache,\n  utilities,\n  CONSTANTS,\n  Enums as csEnums,\n} from '@cornerstonejs/core';\n\nimport {\n  utilities as csToolsUtils,\n  Enums as csToolsEnums,\n} from '@cornerstonejs/tools';\nimport { IViewportService } from './IViewportService';\nimport { RENDERING_ENGINE_ID } from './constants';\nimport ViewportInfo, {\n  ViewportOptions,\n  DisplaySetOptions,\n  PublicViewportOptions,\n} from './Viewport';\nimport {\n  StackViewportData,\n  VolumeViewportData,\n} from '../../types/CornerstoneCacheService';\nimport { Presentation, Presentations } from '../../types/Presentation';\n\nimport JumpPresets from '../../utils/JumpPresets';\n\nconst EVENTS = {\n  VIEWPORT_DATA_CHANGED:\n    'event::cornerstoneViewportService:viewportDataChanged',\n};\n\n/**\n * Handles cornerstone viewport logic including enabling, disabling, and\n * updating the viewport.\n */\nclass CornerstoneViewportService extends PubSubService\n  implements IViewportService {\n  static REGISTRATION = {\n    name: 'cornerstoneViewportService',\n    altName: 'CornerstoneViewportService',\n    create: ({\n      servicesManager,\n    }: OhifTypes.Extensions.ExtensionParams): CornerstoneViewportService => {\n      return new CornerstoneViewportService(servicesManager);\n    },\n  };\n\n  renderingEngine: Types.IRenderingEngine | null;\n  viewportsInfo: Map<number, ViewportInfo> = new Map();\n  viewportsById: Map<string, ViewportInfo> = new Map();\n  viewportGridResizeObserver: ResizeObserver | null;\n  viewportsDisplaySets: Map<string, string[]> = new Map();\n\n  // Some configs\n  enableResizeDetector: true;\n  resizeRefreshRateMs: 200;\n  resizeRefreshMode: 'debounce';\n  servicesManager = null;\n\n  constructor(servicesManager: ServicesManager) {\n    super(EVENTS);\n    this.renderingEngine = null;\n    this.viewportGridResizeObserver = null;\n    this.servicesManager = servicesManager;\n  }\n\n  /**\n   * Adds the HTML element to the viewportService\n   * @param {*} viewportIndex\n   * @param {*} elementRef\n   */\n  public enableViewport(\n    viewportIndex: number,\n    viewportOptions: PublicViewportOptions,\n    elementRef: HTMLDivElement\n  ): void {\n    // Use the provided viewportId\n    // Not providing a viewportId is frowned upon because it does weird things\n    // on moving them around, but it does mostly work.\n    if (!viewportOptions.viewportId) {\n      console.warn('Should provide viewport id externally', viewportOptions);\n      viewportOptions.viewportId =\n        this.getViewportId(viewportIndex) || `viewport-${viewportIndex}`;\n    }\n    const { viewportId } = viewportOptions;\n    const viewportInfo = new ViewportInfo(viewportIndex, viewportId);\n    if (!viewportInfo.viewportId) {\n      throw new Error('Should have viewport ID afterwards');\n    }\n\n    viewportInfo.setElement(elementRef);\n    this.viewportsInfo.set(viewportIndex, viewportInfo);\n    this.viewportsById.set(viewportId, viewportInfo);\n  }\n\n  public getViewportIds(): string[] {\n    const viewportIds = [];\n\n    this.viewportsInfo.forEach(viewportInfo => {\n      viewportIds.push(viewportInfo.getViewportId());\n    });\n\n    return viewportIds;\n  }\n\n  public getViewportId(viewportIndex: number): string {\n    return this.viewportsInfo[viewportIndex]?.viewportId;\n  }\n\n  /**\n   * It retrieves the renderingEngine if it does exist, or creates one otherwise\n   * @returns {RenderingEngine} rendering engine\n   */\n  public getRenderingEngine() {\n    // get renderingEngine from cache if it exists\n    const renderingEngine = getRenderingEngine(RENDERING_ENGINE_ID);\n\n    if (renderingEngine) {\n      this.renderingEngine = renderingEngine;\n      return this.renderingEngine;\n    }\n\n    if (!renderingEngine || renderingEngine.hasBeenDestroyed) {\n      this.renderingEngine = new RenderingEngine(RENDERING_ENGINE_ID);\n    }\n\n    return this.renderingEngine;\n  }\n\n  /**\n   * It triggers the resize on the rendering engine.\n   */\n  public resize() {\n    const immediate = true;\n    const keepCamera = true;\n\n    this.renderingEngine.resize(immediate, keepCamera);\n    this.renderingEngine.render();\n  }\n\n  /**\n   * Removes the viewport from cornerstone, and destroys the rendering engine\n   */\n  public destroy() {\n    this._removeResizeObserver();\n    this.viewportGridResizeObserver = null;\n    try {\n      this.renderingEngine?.destroy?.();\n    } catch (e) {\n      console.warn('Rendering engine not destroyed', e);\n    }\n    this.viewportsDisplaySets.clear();\n    this.renderingEngine = null;\n    cache.purgeCache();\n  }\n\n  /**\n   * Disables the viewport inside the renderingEngine, if no viewport is left\n   * it destroys the renderingEngine.\n   *\n   * This is called when the element goes away entirely - with new viewportId's\n   * created for every new viewport, this will be called whenever the set of\n   * viewports is changed, but NOT when the viewport position changes only.\n   *\n   * @param viewportIndex\n   */\n  public disableElement(viewportIndex: number): void {\n    const viewportInfo = this.viewportsInfo.get(viewportIndex);\n    if (!viewportInfo) {\n      return;\n    }\n\n    const viewportId = viewportInfo.getViewportId();\n\n    this.renderingEngine && this.renderingEngine.disableElement(viewportId);\n\n    this.viewportsInfo.get(viewportIndex).destroy();\n    this.viewportsInfo.delete(viewportIndex);\n    this.viewportsById.delete(viewportId);\n  }\n\n  public setPresentations(viewport, presentations?: Presentations): void {\n    const properties = presentations?.lutPresentation?.properties;\n    if (properties) viewport.setProperties(properties);\n    const camera = presentations?.positionPresentation?.camera;\n    if (camera) viewport.setCamera(camera);\n  }\n\n  public getPresentation(viewportIndex: number): Presentation {\n    const viewportInfo = this.viewportsInfo.get(viewportIndex);\n    if (!viewportInfo) return;\n    const { viewportType, presentationIds } = viewportInfo.getViewportOptions();\n\n    const csViewport = this.getCornerstoneViewportByIndex(viewportIndex);\n    if (!csViewport) return;\n\n    const properties = csViewport.getProperties();\n    if (properties.isComputedVOI) {\n      delete properties.voiRange;\n      delete properties.VOILUTFunction;\n    }\n    const initialImageIndex = csViewport.getCurrentImageIdIndex();\n    const camera = csViewport.getCamera();\n    return {\n      presentationIds,\n      viewportType:\n        !viewportType || viewportType === 'stack' ? 'stack' : 'volume',\n      properties,\n      initialImageIndex,\n      camera,\n    };\n  }\n\n  /**\n   * Uses the renderingEngine to enable the element for the given viewport index\n   * and sets the displaySet data to the viewport\n   * @param {*} viewportIndex\n   * @param {*} displaySet\n   * @param {*} dataSource\n   * @returns\n   */\n  public setViewportData(\n    viewportIndex: number,\n    viewportData: StackViewportData | VolumeViewportData,\n    publicViewportOptions: PublicViewportOptions,\n    publicDisplaySetOptions: DisplaySetOptions[],\n    presentations?: Presentations\n  ): void {\n    const renderingEngine = this.getRenderingEngine();\n    const viewportId =\n      publicViewportOptions.viewportId || this.getViewportId(viewportIndex);\n    if (!viewportId) {\n      throw new Error('Must define viewportId externally');\n    }\n\n    const viewportInfo = this.viewportsById.get(viewportId);\n\n    if (!viewportInfo) {\n      throw new Error('Viewport info not defined');\n    }\n\n    // If the viewport has moved index, then record the new index\n    if (viewportInfo.viewportIndex !== viewportIndex) {\n      this.viewportsInfo.delete(viewportInfo.viewportIndex);\n      this.viewportsInfo.set(viewportIndex, viewportInfo);\n      viewportInfo.viewportIndex = viewportIndex;\n    }\n\n    viewportInfo.setRenderingEngineId(renderingEngine.id);\n\n    const {\n      viewportOptions,\n      displaySetOptions,\n    } = this._getViewportAndDisplaySetOptions(\n      publicViewportOptions,\n      publicDisplaySetOptions,\n      viewportInfo\n    );\n\n    viewportInfo.setViewportOptions(viewportOptions);\n    viewportInfo.setDisplaySetOptions(displaySetOptions);\n    viewportInfo.setViewportData(viewportData);\n\n    const element = viewportInfo.getElement();\n    const type = viewportInfo.getViewportType();\n    const background = viewportInfo.getBackground();\n    const orientation = viewportInfo.getOrientation();\n\n    const viewportInput: Types.PublicViewportInput = {\n      viewportId,\n      element,\n      type,\n      defaultOptions: {\n        background,\n        orientation,\n      },\n    };\n\n    // Todo: this is not optimal at all, we are re-enabling the already enabled\n    // element which is not what we want. But enabledElement as part of the\n    // renderingEngine is designed to be used like this. This will trigger\n    // ENABLED_ELEMENT again and again, which will run onEnableElement callbacks\n    renderingEngine.enableElement(viewportInput);\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    this._setDisplaySets(viewport, viewportData, viewportInfo, presentations);\n\n    // The broadcast event here ensures that listeners have a valid, up to date\n    // viewport to access.  Doing it too early can result in exceptions or\n    // invalid data.\n    this._broadcastEvent(this.EVENTS.VIEWPORT_DATA_CHANGED, {\n      viewportData,\n      viewportIndex,\n      viewportId,\n    });\n  }\n\n  public getCornerstoneViewport(\n    viewportId: string\n  ): Types.IStackViewport | Types.IVolumeViewport | null {\n    const viewportInfo = this.getViewportInfo(viewportId);\n\n    if (\n      !viewportInfo ||\n      !this.renderingEngine ||\n      this.renderingEngine.hasBeenDestroyed\n    ) {\n      return null;\n    }\n\n    const viewport = this.renderingEngine.getViewport(viewportId);\n\n    return viewport;\n  }\n\n  public getCornerstoneViewportByIndex(\n    viewportIndex: number\n  ): Types.IStackViewport | Types.IVolumeViewport | null {\n    const viewportInfo = this.getViewportInfoByIndex(viewportIndex);\n\n    if (\n      !viewportInfo ||\n      !this.renderingEngine ||\n      this.renderingEngine.hasBeenDestroyed\n    ) {\n      return null;\n    }\n\n    const viewport = this.renderingEngine.getViewport(\n      viewportInfo.getViewportId()\n    );\n\n    return viewport;\n  }\n\n  /**\n   * Returns the viewportIndex for the provided viewportId\n   * @param {string} viewportId - the viewportId\n   * @returns {number} - the viewportIndex\n   */\n  public getViewportInfoByIndex(viewportIndex: number): ViewportInfo {\n    return this.viewportsInfo.get(viewportIndex);\n  }\n\n  public getViewportInfo(viewportId: string): ViewportInfo {\n    // @ts-ignore\n    for (const [index, viewport] of this.viewportsInfo.entries()) {\n      if (viewport.getViewportId() === viewportId) {\n        return viewport;\n      }\n    }\n    return null;\n  }\n\n  _setStackViewport(\n    viewport: Types.IStackViewport,\n    viewportData: StackViewportData,\n    viewportInfo: ViewportInfo,\n    presentations: Presentations\n  ): void {\n    const displaySetOptions = viewportInfo.getDisplaySetOptions();\n\n    const {\n      imageIds,\n      initialImageIndex,\n      displaySetInstanceUID,\n    } = viewportData.data;\n\n    this.viewportsDisplaySets.set(viewport.id, [displaySetInstanceUID]);\n\n    let initialImageIndexToUse =\n      presentations?.positionPresentation?.initialImageIndex ??\n      initialImageIndex;\n\n    if (\n      initialImageIndexToUse === undefined ||\n      initialImageIndexToUse === null\n    ) {\n      initialImageIndexToUse =\n        this._getInitialImageIndexForViewport(viewportInfo, imageIds) || 0;\n    }\n\n    const properties = { ...presentations.lutPresentation?.properties };\n    if (!presentations.lutPresentation?.properties) {\n      const { voi, voiInverted } = displaySetOptions[0];\n      if (voi && (voi.windowWidth || voi.windowCenter)) {\n        const { lower, upper } = csUtils.windowLevel.toLowHighRange(\n          voi.windowWidth,\n          voi.windowCenter\n        );\n        properties.voiRange = { lower, upper };\n      }\n\n      if (voiInverted !== undefined) {\n        properties.invert = voiInverted;\n      }\n    }\n\n    viewport.setStack(imageIds, initialImageIndexToUse).then(() => {\n      viewport.setProperties(properties);\n      const camera = presentations.positionPresentation?.camera;\n      if (camera) viewport.setCamera(camera);\n    });\n  }\n\n  private _getInitialImageIndexForViewport(\n    viewportInfo: ViewportInfo,\n    imageIds?: string[]\n  ): number {\n    const initialImageOptions = viewportInfo.getInitialImageOptions();\n\n    if (!initialImageOptions) {\n      return;\n    }\n\n    const { index, preset } = initialImageOptions;\n    const viewportType = viewportInfo.getViewportType();\n\n    let numberOfSlices;\n    if (viewportType === csEnums.ViewportType.STACK) {\n      numberOfSlices = imageIds.length;\n    } else if (viewportType === csEnums.ViewportType.ORTHOGRAPHIC) {\n      const viewport = this.getCornerstoneViewport(\n        viewportInfo.getViewportId()\n      );\n      const imageSliceData = csUtils.getImageSliceDataForVolumeViewport(\n        viewport\n      );\n\n      if (!imageSliceData) {\n        return;\n      }\n\n      ({ numberOfSlices } = imageSliceData);\n    } else {\n      return;\n    }\n\n    return this._getInitialImageIndex(numberOfSlices, index, preset);\n  }\n\n  _getInitialImageIndex(\n    numberOfSlices: number,\n    imageIndex?: number,\n    preset?: JumpPresets\n  ): number {\n    const lastSliceIndex = numberOfSlices - 1;\n\n    if (imageIndex !== undefined) {\n      return csToolsUtils.clip(imageIndex, 0, lastSliceIndex);\n    }\n\n    if (preset === JumpPresets.First) {\n      return 0;\n    }\n\n    if (preset === JumpPresets.Last) {\n      return lastSliceIndex;\n    }\n\n    if (preset === JumpPresets.Middle) {\n      // Note: this is a simple but yet very important formula.\n      // since viewport reset works with the middle slice\n      // if the below formula is not correct, on a viewport reset\n      // it will jump to a different slice than the middle one which\n      // was the initial slice, and we have some tools such as Crosshairs\n      // which rely on a relative camera modifications and those will break.\n      return lastSliceIndex % 2 === 0\n        ? lastSliceIndex / 2\n        : (lastSliceIndex + 1) / 2;\n    }\n\n    return 0;\n  }\n\n  async _setVolumeViewport(\n    viewport: Types.IVolumeViewport,\n    viewportData: VolumeViewportData,\n    viewportInfo: ViewportInfo,\n    presentations: Presentations\n  ): Promise<void> {\n    // TODO: We need to overhaul the way data sources work so requests can be made\n    // async. I think we should follow the image loader pattern which is async and\n    // has a cache behind it.\n    // The problem is that to set this volume, we need the metadata, but the request is\n    // already in-flight, and the promise is not cached, so we have no way to wait for\n    // it and know when it has fully arrived.\n    // loadStudyMetadata(StudyInstanceUID) => Promise([instances for study])\n    // loadSeriesMetadata(StudyInstanceUID, SeriesInstanceUID) => Promise([instances for series])\n    // If you call loadStudyMetadata and it's not in the DicomMetadataStore cache, it should fire\n    // a request through the data source?\n    // (This call may or may not create sub-requests for series metadata)\n    const volumeInputArray = [];\n    const displaySetOptionsArray = viewportInfo.getDisplaySetOptions();\n    const { hangingProtocolService } = this.servicesManager.services;\n\n    const volumeToLoad = [];\n    const displaySetInstanceUIDs = [];\n\n    for (const [index, data] of viewportData.data.entries()) {\n      const { volume, imageIds, displaySetInstanceUID } = data;\n\n      displaySetInstanceUIDs.push(displaySetInstanceUID);\n\n      if (!volume) {\n        console.log('Volume display set not found');\n        continue;\n      }\n\n      volumeToLoad.push(volume);\n\n      const displaySetOptions = displaySetOptionsArray[index];\n      const { volumeId } = volume;\n\n      volumeInputArray.push({\n        imageIds,\n        volumeId,\n        blendMode: displaySetOptions.blendMode,\n        slabThickness: this._getSlabThickness(displaySetOptions, volumeId),\n      });\n    }\n\n    this.viewportsDisplaySets.set(viewport.id, displaySetInstanceUIDs);\n\n    if (\n      hangingProtocolService.hasCustomImageLoadStrategy() &&\n      !hangingProtocolService.customImageLoadPerformed\n    ) {\n      // delegate the volume loading to the hanging protocol service if it has a custom image load strategy\n      return hangingProtocolService.runImageLoadStrategy({\n        viewportId: viewport.id,\n        volumeInputArray,\n      });\n    }\n\n    volumeToLoad.forEach(volume => {\n      if (!volume.loadStatus.loaded && !volume.loadStatus.loading) {\n        volume.load();\n      }\n    });\n\n    // This returns the async continuation only\n    return this.setVolumesForViewport(\n      viewport,\n      volumeInputArray,\n      presentations\n    );\n  }\n\n  public async setVolumesForViewport(\n    viewport,\n    volumeInputArray,\n    presentations\n  ) {\n    const {\n      displaySetService,\n      toolGroupService,\n    } = this.servicesManager.services;\n\n    const viewportInfo = this.getViewportInfo(viewport.id);\n    const displaySetOptions = viewportInfo.getDisplaySetOptions();\n\n    // Todo: use presentations states\n    const volumesProperties = volumeInputArray.map((volumeInput, index) => {\n      const { volumeId } = volumeInput;\n      const displaySetOption = displaySetOptions[index];\n      const { voi, voiInverted, colormap, displayPreset } = displaySetOption;\n      const properties = {};\n\n      if (voi && (voi.windowWidth || voi.windowCenter)) {\n        const { lower, upper } = csUtils.windowLevel.toLowHighRange(\n          voi.windowWidth,\n          voi.windowCenter\n        );\n        properties.voiRange = { lower, upper };\n      }\n\n      if (voiInverted !== undefined) {\n        properties.invert = voiInverted;\n      }\n\n      if (colormap !== undefined) {\n        properties.colormap = colormap;\n      }\n\n      if (displayPreset !== undefined) {\n        properties.preset = displayPreset;\n      }\n\n      return { properties, volumeId };\n    });\n\n    await viewport.setVolumes(volumeInputArray);\n    volumesProperties.forEach(({ properties, volumeId }) => {\n      viewport.setProperties(properties, volumeId);\n    });\n\n    this.setPresentations(viewport, presentations);\n\n    // load any secondary displaySets\n    const displaySetInstanceUIDs = this.viewportsDisplaySets.get(viewport.id);\n\n    // can be SEG or RTSTRUCT for now\n    const overlayDisplaySet = displaySetInstanceUIDs\n      .map(displaySetService.getDisplaySetByUID)\n      .find(displaySet => displaySet?.isOverlayDisplaySet);\n\n    if (overlayDisplaySet) {\n      this.addOverlayRepresentationForDisplaySet(overlayDisplaySet, viewport);\n    } else {\n      // If the displaySet is not a SEG displaySet we assume it is a primary displaySet\n      // and we can look into hydrated segmentations to check if any of them are\n      // associated with the primary displaySet\n\n      // get segmentations only returns the hydrated segmentations\n      this._addSegmentationRepresentationToToolGroupIfNecessary(\n        displaySetInstanceUIDs,\n        viewport\n      );\n    }\n\n    const toolGroup = toolGroupService.getToolGroupForViewport(viewport.id);\n    csToolsUtils.segmentation.triggerSegmentationRender(toolGroup.id);\n\n    const imageIndex = this._getInitialImageIndexForViewport(viewportInfo);\n\n    if (imageIndex !== undefined) {\n      csToolsUtils.jumpToSlice(viewport.element, {\n        imageIndex,\n      });\n    }\n\n    viewport.render();\n  }\n\n  private _addSegmentationRepresentationToToolGroupIfNecessary(\n    displaySetInstanceUIDs: string[],\n    viewport: any\n  ) {\n    const {\n      segmentationService,\n      toolGroupService,\n    } = this.servicesManager.services;\n\n    const toolGroup = toolGroupService.getToolGroupForViewport(viewport.id);\n\n    // this only returns hydrated segmentations\n    const segmentations = segmentationService.getSegmentations();\n\n    for (const segmentation of segmentations) {\n      const toolGroupSegmentationRepresentations =\n        segmentationService.getSegmentationRepresentationsForToolGroup(\n          toolGroup.id\n        ) || [];\n\n      // if there is already a segmentation representation for this segmentation\n      // for this toolGroup, don't bother at all\n      const isSegmentationInToolGroup = toolGroupSegmentationRepresentations.find(\n        representation => representation.segmentationId === segmentation.id\n      );\n\n      if (isSegmentationInToolGroup) {\n        continue;\n      }\n\n      // otherwise, check if the hydrated segmentations are in the same FOR\n      // as the primary displaySet, if so add the representation (since it was not there)\n      const { id: segDisplaySetInstanceUID, type } = segmentation;\n      const segFrameOfReferenceUID = this._getFrameOfReferenceUID(\n        segDisplaySetInstanceUID\n      );\n\n      let shouldDisplaySeg = false;\n\n      for (const displaySetInstanceUID of displaySetInstanceUIDs) {\n        const primaryFrameOfReferenceUID = this._getFrameOfReferenceUID(\n          displaySetInstanceUID\n        );\n\n        if (segFrameOfReferenceUID === primaryFrameOfReferenceUID) {\n          shouldDisplaySeg = true;\n          break;\n        }\n      }\n\n      if (!shouldDisplaySeg) {\n        return;\n      }\n\n      segmentationService.addSegmentationRepresentationToToolGroup(\n        toolGroup.id,\n        segmentation.id,\n        false, // already hydrated,\n        segmentation.type\n      );\n    }\n  }\n\n  private addOverlayRepresentationForDisplaySet(\n    displaySet: any,\n    viewport: any\n  ) {\n    const {\n      segmentationService,\n      toolGroupService,\n    } = this.servicesManager.services;\n\n    const { referencedVolumeId } = displaySet;\n    const segmentationId = displaySet.displaySetInstanceUID;\n\n    const toolGroup = toolGroupService.getToolGroupForViewport(viewport.id);\n\n    const representationType =\n      referencedVolumeId && cache.getVolume(referencedVolumeId) !== undefined\n        ? csToolsEnums.SegmentationRepresentations.Labelmap\n        : csToolsEnums.SegmentationRepresentations.Contour;\n\n    segmentationService.addSegmentationRepresentationToToolGroup(\n      toolGroup.id,\n      segmentationId,\n      false,\n      representationType\n    );\n  }\n\n  // Todo: keepCamera is an interim solution until we have a better solution for\n  // keeping the camera position when the viewport data is changed\n  public updateViewport(\n    viewportIndex: number,\n    viewportData,\n    keepCamera = false\n  ) {\n    const viewportInfo = this.getViewportInfoByIndex(viewportIndex);\n\n    const viewportId = viewportInfo.getViewportId();\n    const viewport = this.getCornerstoneViewport(viewportId);\n    const viewportCamera = viewport.getCamera();\n\n    if (viewport instanceof VolumeViewport) {\n      this._setVolumeViewport(viewport, viewportData, viewportInfo).then(() => {\n        if (keepCamera) {\n          viewport.setCamera(viewportCamera);\n          viewport.render();\n        }\n      });\n\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      this._setStackViewport(viewport, viewportData, viewportInfo);\n      return;\n    }\n  }\n\n  _setDisplaySets(\n    viewport: StackViewport | VolumeViewport,\n    viewportData: StackViewportData | VolumeViewportData,\n    viewportInfo: ViewportInfo,\n    presentations: Presentations = {}\n  ): void {\n    if (viewport instanceof StackViewport) {\n      this._setStackViewport(\n        viewport,\n        viewportData as StackViewportData,\n        viewportInfo,\n        presentations\n      );\n    } else if (\n      viewport instanceof VolumeViewport ||\n      viewport instanceof VolumeViewport3D\n    ) {\n      this._setVolumeViewport(\n        viewport,\n        viewportData as VolumeViewportData,\n        viewportInfo,\n        presentations\n      );\n    } else {\n      throw new Error('Unknown viewport type');\n    }\n  }\n\n  /**\n   * Removes the resize observer from the viewport element\n   */\n  _removeResizeObserver() {\n    if (this.viewportGridResizeObserver) {\n      this.viewportGridResizeObserver.disconnect();\n    }\n  }\n\n  _getSlabThickness(displaySetOptions, volumeId) {\n    const { blendMode } = displaySetOptions;\n    if (\n      blendMode === undefined ||\n      displaySetOptions.slabThickness === undefined\n    ) {\n      return;\n    }\n\n    // if there is a slabThickness set as a number then use it\n    if (typeof displaySetOptions.slabThickness === 'number') {\n      return displaySetOptions.slabThickness;\n    }\n\n    if (displaySetOptions.slabThickness.toLowerCase() === 'fullvolume') {\n      // calculate the slab thickness based on the volume dimensions\n      const imageVolume = cache.getVolume(volumeId);\n\n      const { dimensions } = imageVolume;\n      const slabThickness = Math.sqrt(\n        dimensions[0] * dimensions[0] +\n          dimensions[1] * dimensions[1] +\n          dimensions[2] * dimensions[2]\n      );\n\n      return slabThickness;\n    }\n  }\n\n  _getViewportAndDisplaySetOptions(\n    publicViewportOptions: PublicViewportOptions,\n    publicDisplaySetOptions: DisplaySetOptions[],\n    viewportInfo: ViewportInfo\n  ): {\n    viewportOptions: ViewportOptions;\n    displaySetOptions: DisplaySetOptions[];\n  } {\n    const viewportIndex = viewportInfo.getViewportIndex();\n\n    // Creating a temporary viewportInfo to handle defaults\n    const newViewportInfo = new ViewportInfo(\n      viewportIndex,\n      viewportInfo.getViewportId()\n    );\n\n    // To handle setting the default values if missing for the viewportOptions and\n    // displaySetOptions\n    newViewportInfo.setPublicViewportOptions(publicViewportOptions);\n    newViewportInfo.setPublicDisplaySetOptions(publicDisplaySetOptions);\n\n    const newViewportOptions = newViewportInfo.getViewportOptions();\n    const newDisplaySetOptions = newViewportInfo.getDisplaySetOptions();\n\n    return {\n      viewportOptions: newViewportOptions,\n      displaySetOptions: newDisplaySetOptions,\n    };\n  }\n\n  _getFrameOfReferenceUID(displaySetInstanceUID) {\n    const { displaySetService } = this.servicesManager.services;\n    const displaySet = displaySetService.getDisplaySetByUID(\n      displaySetInstanceUID\n    );\n\n    if (!displaySet) {\n      return;\n    }\n\n    if (displaySet.frameOfReferenceUID) {\n      return displaySet.frameOfReferenceUID;\n    }\n\n    if (displaySet.Modality === 'SEG') {\n      const { instance } = displaySet;\n      return instance.FrameOfReferenceUID;\n    }\n\n    if (displaySet.Modality === 'RTSTRUCT') {\n      const { instance } = displaySet;\n      return instance.ReferencedFrameOfReferenceSequence.FrameOfReferenceUID;\n    }\n\n    const { images } = displaySet;\n    if (images && images.length) {\n      return images[0].FrameOfReferenceUID;\n    }\n  }\n\n  /**\n   * Looks through the viewports to see if the specified measurement can be\n   * displayed in one of the viewports.\n   *\n   * @param measurement\n   *          The measurement that is desired to view.\n   * @param activeViewportIndex - the index that was active at the time the jump\n   *          was initiated.\n   * @return the viewportIndex to display the given measurement\n   */\n  public getViewportIndexToJump(\n    activeViewportIndex: number,\n    displaySetInstanceUID: string,\n    cameraProps: unknown\n  ): number {\n    const viewportInfo = this.viewportsInfo.get(activeViewportIndex);\n    const { referencedImageId } = cameraProps;\n    if (viewportInfo?.contains(displaySetInstanceUID, referencedImageId)) {\n      return activeViewportIndex;\n    }\n\n    return (\n      [...this.viewportsById.values()].find(viewportInfo =>\n        viewportInfo.contains(displaySetInstanceUID, referencedImageId)\n      )?.viewportIndex ?? -1\n    );\n  }\n}\n\nexport default CornerstoneViewportService;\n","import { Types, Enums } from '@cornerstonejs/core';\nimport { Types as UITypes } from '@ohif/ui';\nimport {\n  StackViewportData,\n  VolumeViewportData,\n} from '../../types/CornerstoneCacheService';\nimport getCornerstoneBlendMode from '../../utils/getCornerstoneBlendMode';\nimport getCornerstoneOrientation from '../../utils/getCornerstoneOrientation';\nimport getCornerstoneViewportType from '../../utils/getCornerstoneViewportType';\nimport JumpPresets from '../../utils/JumpPresets';\nimport { SyncGroup } from '../SyncGroupService/SyncGroupService';\n\nexport type InitialImageOptions = {\n  index?: number;\n  preset?: JumpPresets;\n};\n\nexport type ViewportOptions = {\n  id?: string;\n  viewportType: Enums.ViewportType;\n  toolGroupId: string;\n  viewportId: string;\n  // Presentation ID to store/load presentation state from\n  presentationIds?: UITypes.PresentationIds;\n  orientation?: Enums.OrientationAxis;\n  background?: Types.Point3;\n  syncGroups?: SyncGroup[];\n  initialImageOptions?: InitialImageOptions;\n  customViewportProps?: Record<string, unknown>;\n  /*\n   * Allows drag and drop of display sets not matching viewport options, but\n   * doesn't show them initially.  Displays initially blank if no required match\n   */\n  allowUnmatchedView?: boolean;\n};\n\nexport type PublicViewportOptions = {\n  id?: string;\n  viewportType?: string;\n  toolGroupId?: string;\n  presentationIds?: UITypes.PresentationIds;\n  viewportId?: string;\n  orientation?: Enums.OrientationAxis;\n  background?: Types.Point3;\n  syncGroups?: SyncGroup[];\n  initialImageOptions?: InitialImageOptions;\n  customViewportProps?: Record<string, unknown>;\n  allowUnmatchedView?: boolean;\n};\n\nexport type DisplaySetSelector = {\n  id?: string;\n  options?: PublicDisplaySetOptions;\n};\n\nexport type PublicDisplaySetOptions = {\n  /** The display set options can have an id in order to distinguish\n   * it from other similar items.\n   */\n  id?: string;\n  voi?: VOI;\n  voiInverted?: boolean;\n  blendMode?: string;\n  slabThickness?: number;\n  colormap?: string;\n  displayPreset?: string;\n};\n\nexport type DisplaySetOptions = {\n  id?: string;\n  voi?: VOI;\n  voiInverted: boolean;\n  blendMode?: Enums.BlendModes;\n  slabThickness?: number;\n  colormap?: string;\n  displayPreset?: string;\n};\n\ntype VOI = {\n  windowWidth: number;\n  windowCenter: number;\n};\n\nexport type DisplaySet = {\n  displaySetInstanceUID: string;\n};\n\nconst STACK = 'stack';\nconst DEFAULT_TOOLGROUP_ID = 'default';\n\n// Return true if the data contains the given display set UID OR the imageId\n// if it is a composite object.\nconst dataContains = (\n  data,\n  displaySetUID: string,\n  imageId?: string\n): boolean => {\n  if (data.displaySetInstanceUID === displaySetUID) return true;\n  if (imageId && data.isCompositeStack && data.imageIds) {\n    return !!data.imageIds.find(dataId => dataId === imageId);\n  }\n  return false;\n};\n\nclass ViewportInfo {\n  private viewportId = '';\n  private viewportIndex: number;\n  private element: HTMLDivElement;\n  private viewportOptions: ViewportOptions;\n  private displaySetOptions: Array<DisplaySetOptions>;\n  private viewportData: StackViewportData | VolumeViewportData;\n  private renderingEngineId: string;\n\n  constructor(viewportIndex: number, viewportId: string) {\n    this.viewportIndex = viewportIndex;\n    this.viewportId = viewportId;\n    this.setPublicViewportOptions({});\n    this.setPublicDisplaySetOptions([{}]);\n  }\n\n  /**\n   * Return true if the viewport contains the given display set UID,\n   * OR if it is a composite stack and contains the given imageId\n   */\n  public contains(displaySetUID: string, imageId: string): boolean {\n    if (!this.viewportData?.data) return false;\n\n    if (this.viewportData.data.length) {\n      return !!this.viewportData.data.find(data =>\n        dataContains(data, displaySetUID, imageId)\n      );\n    }\n    return dataContains(this.viewportData.data, displaySetUID, imageId);\n  }\n\n  public destroy = (): void => {\n    this.element = null;\n    this.viewportData = null;\n    this.viewportOptions = null;\n    this.displaySetOptions = null;\n  };\n\n  public setRenderingEngineId(renderingEngineId: string): void {\n    this.renderingEngineId = renderingEngineId;\n  }\n\n  public getRenderingEngineId(): string {\n    return this.renderingEngineId;\n  }\n\n  public setViewportId(viewportId: string): void {\n    this.viewportId = viewportId;\n  }\n  public setViewportIndex(viewportIndex: number): void {\n    this.viewportIndex = viewportIndex;\n  }\n\n  public setElement(element: HTMLDivElement): void {\n    this.element = element;\n  }\n\n  public setViewportData(\n    viewportData: StackViewportData | VolumeViewportData\n  ): void {\n    this.viewportData = viewportData;\n  }\n\n  public getViewportData(): StackViewportData | VolumeViewportData {\n    return this.viewportData;\n  }\n\n  public getViewportIndex(): number {\n    return this.viewportIndex;\n  }\n\n  public getElement(): HTMLDivElement {\n    return this.element;\n  }\n\n  public getViewportId(): string {\n    return this.viewportId;\n  }\n\n  public setPublicDisplaySetOptions(\n    publicDisplaySetOptions: PublicDisplaySetOptions[] | DisplaySetSelector[]\n  ): void {\n    // map the displaySetOptions and check if they are undefined then set them to default values\n    const displaySetOptions = this.mapDisplaySetOptions(\n      publicDisplaySetOptions\n    );\n\n    this.setDisplaySetOptions(displaySetOptions);\n  }\n\n  public hasDisplaySet(displaySetInstanceUID: string): boolean {\n    // Todo: currently this does not work for non image & referenceImage displaySets.\n    // Since SEG and other derived displaySets are loaded in a different way, and not\n    // via cornerstoneViewportService\n    let viewportData = this.getViewportData();\n\n    if (viewportData.viewportType === Enums.ViewportType.ORTHOGRAPHIC) {\n      viewportData = viewportData as VolumeViewportData;\n      return viewportData.data.some(\n        ({ displaySetInstanceUID: dsUID }) => dsUID === displaySetInstanceUID\n      );\n    }\n\n    viewportData = viewportData as StackViewportData;\n    return viewportData.data.displaySetInstanceUID === displaySetInstanceUID;\n  }\n\n  public setPublicViewportOptions(\n    viewportOptionsEntry: PublicViewportOptions\n  ): void {\n    let viewportType = viewportOptionsEntry.viewportType;\n    const {\n      toolGroupId = DEFAULT_TOOLGROUP_ID,\n      presentationIds,\n    } = viewportOptionsEntry;\n    let orientation;\n\n    if (!viewportType) {\n      viewportType = getCornerstoneViewportType(STACK);\n    } else {\n      viewportType = getCornerstoneViewportType(\n        viewportOptionsEntry.viewportType\n      );\n    }\n\n    // map SAGITTAL, AXIAL, CORONAL orientation to be used by cornerstone\n    if (viewportOptionsEntry.viewportType?.toLowerCase() !== STACK) {\n      orientation = getCornerstoneOrientation(viewportOptionsEntry.orientation);\n    }\n\n    if (!toolGroupId) {\n      toolGroupId = DEFAULT_TOOLGROUP_ID;\n    }\n\n    this.setViewportOptions({\n      ...viewportOptionsEntry,\n      viewportId: this.viewportId,\n      viewportType: viewportType as Enums.ViewportType,\n      orientation,\n      toolGroupId,\n      presentationIds,\n    });\n  }\n\n  public setViewportOptions(viewportOptions: ViewportOptions): void {\n    this.viewportOptions = viewportOptions;\n  }\n\n  public getViewportOptions(): ViewportOptions {\n    return this.viewportOptions;\n  }\n\n  public setDisplaySetOptions(\n    displaySetOptions: Array<DisplaySetOptions>\n  ): void {\n    this.displaySetOptions = displaySetOptions;\n  }\n\n  public getSyncGroups(): SyncGroup[] {\n    this.viewportOptions.syncGroups ||= [];\n    return this.viewportOptions.syncGroups;\n  }\n\n  public getDisplaySetOptions(): Array<DisplaySetOptions> {\n    return this.displaySetOptions;\n  }\n\n  public getViewportType(): Enums.ViewportType {\n    return this.viewportOptions.viewportType || Enums.ViewportType.STACK;\n  }\n\n  public getToolGroupId(): string {\n    return this.viewportOptions.toolGroupId;\n  }\n\n  public getBackground(): Types.Point3 {\n    return this.viewportOptions.background || [0, 0, 0];\n  }\n\n  public getOrientation(): Enums.OrientationAxis {\n    return this.viewportOptions.orientation;\n  }\n\n  public getInitialImageOptions(): InitialImageOptions {\n    return this.viewportOptions.initialImageOptions;\n  }\n\n  // Handle incoming public display set options or a display set select\n  // with a contained options.\n  private mapDisplaySetOptions(\n    options: PublicDisplaySetOptions[] | DisplaySetSelector[] = [{}]\n  ): Array<DisplaySetOptions> {\n    const displaySetOptions: Array<DisplaySetOptions> = [];\n\n    options.forEach(item => {\n      let option = item?.options || item;\n      if (!option) {\n        option = {\n          blendMode: undefined,\n          slabThickness: undefined,\n          colormap: undefined,\n          voi: {},\n          voiInverted: false,\n        };\n      }\n      const blendMode = getCornerstoneBlendMode(option.blendMode);\n\n      displaySetOptions.push({\n        voi: option.voi,\n        voiInverted: option.voiInverted,\n        colormap: option.colormap,\n        slabThickness: option.slabThickness,\n        blendMode,\n        displayPreset: option.displayPreset,\n      });\n    });\n\n    return displaySetOptions;\n  }\n}\n\nexport default ViewportInfo;\n","const RENDERING_ENGINE_ID = 'OHIFCornerstoneRenderingEngine';\n\nexport { RENDERING_ENGINE_ID };\n","const state = {\n  // The `defaultContext` of an extension's commandsModule\n  DEFAULT_CONTEXT: 'CORNERSTONE',\n  enabledElements: {},\n};\n\n/**\n * Sets the enabled element `dom` reference for an active viewport.\n * @param {HTMLElement} dom Active viewport element.\n * @return void\n */\nconst setEnabledElement = (\n  viewportIndex: number,\n  element: HTMLElement,\n  context?: string\n): void => {\n  const targetContext = context || state.DEFAULT_CONTEXT;\n\n  state.enabledElements[viewportIndex] = {\n    element,\n    context: targetContext,\n  };\n};\n\n/**\n * Grabs the enabled element `dom` reference of an ative viewport.\n *\n * @return {HTMLElement} Active viewport element.\n */\nconst getEnabledElement = viewportIndex => {\n  return state.enabledElements[viewportIndex];\n};\n\nconst reset = () => {\n  state.enabledElements = {};\n};\n\nexport { setEnabledElement, getEnabledElement, reset };\n","import { metaData } from '@cornerstonejs/core';\nimport { LengthTool, utilities } from '@cornerstonejs/tools';\nimport callInputDialog from '../utils/callInputDialog';\nimport getActiveViewportEnabledElement from '../utils/getActiveViewportEnabledElement';\n\nconst { calibrateImageSpacing } = utilities;\n\n/**\n * Calibration Line tool works almost the same as the\n */\nclass CalibrationLineTool extends LengthTool {\n  static toolName = 'CalibrationLine';\n\n  _renderingViewport: any;\n  _lengthToolRenderAnnotation = this.renderAnnotation;\n\n  renderAnnotation = (enabledElement, svgDrawingHelper) => {\n    const { viewport } = enabledElement;\n    this._renderingViewport = viewport;\n    return this._lengthToolRenderAnnotation(enabledElement, svgDrawingHelper);\n  };\n\n  _getTextLines(data, targetId) {\n    const [canvasPoint1, canvasPoint2] = data.handles.points.map(p =>\n      this._renderingViewport.worldToCanvas(p)\n    );\n    // for display, round to 2 decimal points\n    const lengthPx =\n      Math.round(calculateLength2(canvasPoint1, canvasPoint2) * 100) / 100;\n\n    const textLines = [`${lengthPx}px`];\n\n    return textLines;\n  }\n}\n\nfunction calculateLength2(point1, point2) {\n  const dx = point1[0] - point2[0];\n  const dy = point1[1] - point2[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction calculateLength3(pos1, pos2) {\n  const dx = pos1[0] - pos2[0];\n  const dy = pos1[1] - pos2[1];\n  const dz = pos1[2] - pos2[2];\n\n  return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n\nexport default CalibrationLineTool;\n\nexport function onCompletedCalibrationLine(servicesManager, csToolsEvent) {\n  const { uiDialogService, viewportGridService } = servicesManager.services;\n\n  // calculate length (mm) with the current Pixel Spacing\n  const annotationAddedEventDetail = csToolsEvent.detail;\n  const {\n    annotation: { metadata, data: annotationData },\n  } = annotationAddedEventDetail;\n  const { referencedImageId: imageId } = metadata;\n  const enabledElement = getActiveViewportEnabledElement(viewportGridService);\n  const { viewport } = enabledElement;\n\n  const length =\n    Math.round(\n      calculateLength3(\n        annotationData.handles.points[0],\n        annotationData.handles.points[1]\n      ) * 100\n    ) / 100;\n\n  // calculate the currently applied pixel spacing on the viewport\n  const calibratedPixelSpacing = metaData.get(\n    'calibratedPixelSpacing',\n    imageId\n  );\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n  const currentRowPixelSpacing =\n    calibratedPixelSpacing?.[0] || imagePlaneModule?.rowPixelSpacing || 1;\n  const currentColumnPixelSpacing =\n    calibratedPixelSpacing?.[1] || imagePlaneModule?.columnPixelSpacing || 1;\n\n  const adjustCalibration = newLength => {\n    const spacingScale = newLength / length;\n    const rowSpacing = spacingScale * currentRowPixelSpacing;\n    const colSpacing = spacingScale * currentColumnPixelSpacing;\n\n    // trigger resize of the viewport to adjust the world/pixel mapping\n    calibrateImageSpacing(\n      imageId,\n      viewport.getRenderingEngine(),\n      rowSpacing,\n      colSpacing\n    );\n  };\n\n  return new Promise((resolve, reject) => {\n    if (!uiDialogService) {\n      reject('UIDialogService is not initiated');\n      return;\n    }\n\n    callInputDialog(\n      uiDialogService,\n      {\n        text: '',\n        label: `${length}`,\n      },\n      (value, id) => {\n        if (id === 'save') {\n          adjustCalibration(Number.parseFloat(value));\n          resolve(true);\n        } else {\n          reject('cancel');\n        }\n      },\n      false,\n      {\n        dialogTitle: 'Calibration',\n        inputLabel: 'Actual Physical distance (mm)',\n\n        // the input value must be a number\n        validateFunc: val => {\n          try {\n            const v = Number.parseFloat(val);\n            return !isNaN(v) && v !== 0.0;\n          } catch {\n            return false;\n          }\n        },\n      }\n    );\n  });\n}\n","import * as CornerstoneCacheService from './CornerstoneCacheService'\nimport CornerstoneServices from './CornerstoneServices';\n\nexport type {\n  CornerstoneCacheService,\n  CornerstoneServices,\n}\n","import React, { useEffect, useState } from 'react';\nimport html2canvas from 'html2canvas';\nimport {\n  Enums,\n  getEnabledElement,\n  getOrCreateCanvas,\n  StackViewport,\n  VolumeViewport,\n} from '@cornerstonejs/core';\nimport { ToolGroupManager } from '@cornerstonejs/tools';\nimport PropTypes from 'prop-types';\nimport { ViewportDownloadForm } from '@ohif/ui';\n\nimport { getEnabledElement as OHIFgetEnabledElement } from '../state';\n\nconst MINIMUM_SIZE = 100;\nconst DEFAULT_SIZE = 512;\nconst MAX_TEXTURE_SIZE = 10000;\nconst VIEWPORT_ID = 'cornerstone-viewport-download-form';\n\nconst CornerstoneViewportDownloadForm = ({\n  onClose,\n  activeViewportIndex,\n  cornerstoneViewportService,\n}) => {\n  const enabledElement = OHIFgetEnabledElement(activeViewportIndex);\n  const activeViewportElement = enabledElement?.element;\n  const activeViewportEnabledElement = getEnabledElement(activeViewportElement);\n\n  const {\n    viewportId: activeViewportId,\n    renderingEngineId,\n  } = activeViewportEnabledElement;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    activeViewportId,\n    renderingEngineId\n  );\n\n  const toolModeAndBindings = Object.keys(toolGroup.toolOptions).reduce(\n    (acc, toolName) => {\n      const tool = toolGroup.toolOptions[toolName];\n      const { mode, bindings } = tool;\n\n      return {\n        ...acc,\n        [toolName]: {\n          mode,\n          bindings,\n        },\n      };\n    },\n    {}\n  );\n\n  useEffect(() => {\n    return () => {\n      Object.keys(toolModeAndBindings).forEach(toolName => {\n        const { mode, bindings } = toolModeAndBindings[toolName];\n        toolGroup.setToolMode(toolName, mode, { bindings });\n      });\n    };\n  }, []);\n\n  const enableViewport = viewportElement => {\n    if (viewportElement) {\n      const { renderingEngine, viewport } = getEnabledElement(\n        activeViewportElement\n      );\n\n      const viewportInput = {\n        viewportId: VIEWPORT_ID,\n        element: viewportElement,\n        type: viewport.type,\n        defaultOptions: {\n          background: viewport.defaultOptions.background,\n          orientation: viewport.defaultOptions.orientation,\n        },\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n  };\n\n  const disableViewport = viewportElement => {\n    if (viewportElement) {\n      const { renderingEngine } = getEnabledElement(viewportElement);\n      return new Promise(resolve => {\n        renderingEngine.disableElement(VIEWPORT_ID);\n      });\n    }\n  };\n\n  const updateViewportPreview = (\n    downloadViewportElement,\n    internalCanvas,\n    fileType\n  ) =>\n    new Promise(resolve => {\n      const enabledElement = getEnabledElement(downloadViewportElement);\n\n      const { viewport: downloadViewport, renderingEngine } = enabledElement;\n\n      // Note: Since any trigger of dimensions will update the viewport,\n      // we need to resize the offScreenCanvas to accommodate for the new\n      // dimensions, this is due to the reason that we are using the GPU offScreenCanvas\n      // to render the viewport for the downloadViewport.\n      renderingEngine.resize();\n\n      // Trigger the render on the viewport to update the on screen\n      downloadViewport.render();\n\n      downloadViewportElement.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        function updateViewport(event) {\n          const enabledElement = getEnabledElement(event.target);\n          const { viewport } = enabledElement;\n          const { element } = viewport;\n\n          const downloadCanvas = getOrCreateCanvas(element);\n\n          const type = 'image/' + fileType;\n          const dataUrl = downloadCanvas.toDataURL(type, 1);\n\n          let newWidth = element.offsetHeight;\n          let newHeight = element.offsetWidth;\n\n          if (newWidth > DEFAULT_SIZE || newHeight > DEFAULT_SIZE) {\n            const multiplier = DEFAULT_SIZE / Math.max(newWidth, newHeight);\n            newHeight *= multiplier;\n            newWidth *= multiplier;\n          }\n\n          resolve({ dataUrl, width: newWidth, height: newHeight });\n\n          downloadViewportElement.removeEventListener(\n            Enums.Events.IMAGE_RENDERED,\n            updateViewport\n          );\n        }\n      );\n    });\n\n  const loadImage = (activeViewportElement, viewportElement, width, height) =>\n    new Promise(resolve => {\n      if (activeViewportElement && viewportElement) {\n        const activeViewportEnabledElement = getEnabledElement(\n          activeViewportElement\n        );\n\n        if (!activeViewportEnabledElement) {\n          return;\n        }\n\n        const { viewport } = activeViewportEnabledElement;\n\n        const renderingEngine = cornerstoneViewportService.getRenderingEngine();\n        const downloadViewport = renderingEngine.getViewport(VIEWPORT_ID);\n\n        if (downloadViewport instanceof StackViewport) {\n          const imageId = viewport.getCurrentImageId();\n          const properties = viewport.getProperties();\n\n          downloadViewport.setStack([imageId]).then(() => {\n            downloadViewport.setProperties(properties);\n\n            const newWidth = Math.min(width || image.width, MAX_TEXTURE_SIZE);\n            const newHeight = Math.min(\n              height || image.height,\n              MAX_TEXTURE_SIZE\n            );\n\n            resolve({ width: newWidth, height: newHeight });\n          });\n        } else if (downloadViewport instanceof VolumeViewport) {\n          const actors = viewport.getActors();\n          // downloadViewport.setActors(actors);\n          actors.forEach(actor => {\n            downloadViewport.addActor(actor);\n          });\n\n          downloadViewport.setCamera(viewport.getCamera());\n          downloadViewport.render();\n\n          const newWidth = Math.min(width || image.width, MAX_TEXTURE_SIZE);\n          const newHeight = Math.min(height || image.height, MAX_TEXTURE_SIZE);\n\n          resolve({ width: newWidth, height: newHeight });\n        }\n      }\n    });\n\n  const toggleAnnotations = (\n    toggle,\n    viewportElement,\n    activeViewportElement\n  ) => {\n    const activeViewportEnabledElement = getEnabledElement(\n      activeViewportElement\n    );\n\n    const downloadViewportElement = getEnabledElement(viewportElement);\n\n    const {\n      viewportId: activeViewportId,\n      renderingEngineId,\n    } = activeViewportEnabledElement;\n    const { viewportId: downloadViewportId } = downloadViewportElement;\n\n    if (!activeViewportEnabledElement || !downloadViewportElement) {\n      return;\n    }\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      activeViewportId,\n      renderingEngineId\n    );\n\n    // add the viewport to the toolGroup\n    toolGroup.addViewport(downloadViewportId, renderingEngineId);\n\n    Object.keys(toolGroup._toolInstances).forEach(toolName => {\n      // make all tools Enabled so that they can not be interacted with\n      // in the download viewport\n      if (toggle && toolName !== 'Crosshairs') {\n        try {\n          toolGroup.setToolEnabled(toolName);\n        } catch (e) {\n          console.log(e);\n        }\n      } else {\n        toolGroup.setToolDisabled(toolName);\n      }\n    });\n  };\n\n  const downloadBlob = (filename, fileType) => {\n    const file = `${filename}.${fileType}`;\n    const divForDownloadViewport = document.querySelector(\n      `div[data-viewport-uid=\"${VIEWPORT_ID}\"]`\n    );\n\n    html2canvas(divForDownloadViewport).then(canvas => {\n      const link = document.createElement('a');\n      link.download = file;\n      link.href = canvas.toDataURL(fileType, 1.0);\n      link.click();\n    });\n  };\n\n  return (\n    <ViewportDownloadForm\n      onClose={onClose}\n      minimumSize={MINIMUM_SIZE}\n      maximumSize={MAX_TEXTURE_SIZE}\n      defaultSize={DEFAULT_SIZE}\n      canvasClass={'cornerstone-canvas'}\n      activeViewportElement={activeViewportElement}\n      enableViewport={enableViewport}\n      disableViewport={disableViewport}\n      updateViewportPreview={updateViewportPreview}\n      loadImage={loadImage}\n      toggleAnnotations={toggleAnnotations}\n      downloadBlob={downloadBlob}\n    />\n  );\n};\n\nCornerstoneViewportDownloadForm.propTypes = {\n  onClose: PropTypes.func,\n  activeViewportIndex: PropTypes.number.isRequired,\n};\n\nexport default CornerstoneViewportDownloadForm;\n","import dicomImageLoader from '@cornerstonejs/dicom-image-loader';\n\nimport { PubSubService } from '@ohif/core';\n\nexport const EVENTS = {\n  PROGRESS: 'event:DicomFileUploader:progress',\n};\n\nexport interface DicomFileUploaderEvent {\n  fileId: number;\n}\n\nexport interface DicomFileUploaderProgressEvent extends DicomFileUploaderEvent {\n  percentComplete: number;\n}\n\nexport enum UploadStatus {\n  NotStarted,\n  InProgress,\n  Success,\n  Failed,\n  Cancelled,\n}\n\ntype CancelOrFailed = UploadStatus.Cancelled | UploadStatus.Failed;\n\nexport class UploadRejection {\n  message: string;\n  status: CancelOrFailed;\n\n  constructor(status: CancelOrFailed, message: string) {\n    this.message = message;\n    this.status = status;\n  }\n}\n\nexport default class DicomFileUploader extends PubSubService {\n  private _file;\n  private _fileId;\n  private _dataSource;\n  private _loadPromise;\n  private _abortController = new AbortController();\n  private _status: UploadStatus = UploadStatus.NotStarted;\n  private _percentComplete = 0;\n\n  constructor(file, dataSource) {\n    super(EVENTS);\n    this._file = file;\n    this._fileId = dicomImageLoader.wadouri.fileManager.add(file);\n    this._dataSource = dataSource;\n  }\n\n  getFileId(): string {\n    return this._fileId;\n  }\n\n  getFileName(): string {\n    return this._file.name;\n  }\n\n  getFileSize(): number {\n    return this._file.size;\n  }\n\n  cancel(): void {\n    this._abortController.abort();\n  }\n\n  getStatus(): UploadStatus {\n    return this._status;\n  }\n\n  getPercentComplete(): number {\n    return this._percentComplete;\n  }\n\n  async load(): Promise<void> {\n    if (this._loadPromise) {\n      // Already started loading, return the load promise.\n      return this._loadPromise;\n    }\n\n    this._loadPromise = new Promise<void>((resolve, reject) => {\n      // The upload listeners: fire progress events and/or settle the promise.\n      const uploadCallbacks = {\n        progress: evt => {\n          if (!evt.lengthComputable) {\n            // Progress computation is not possible.\n            return;\n          }\n\n          this._status = UploadStatus.InProgress;\n\n          this._percentComplete = Math.round((100 * evt.loaded) / evt.total);\n          this._broadcastEvent(EVENTS.PROGRESS, {\n            fileId: this._fileId,\n            percentComplete: this._percentComplete,\n          });\n        },\n        timeout: () => {\n          this._reject(\n            reject,\n            new UploadRejection(UploadStatus.Failed, 'The request timed out.')\n          );\n        },\n        abort: () => {\n          this._reject(\n            reject,\n            new UploadRejection(UploadStatus.Cancelled, 'Cancelled')\n          );\n        },\n        error: () => {\n          this._reject(\n            reject,\n            new UploadRejection(UploadStatus.Failed, 'The request failed.')\n          );\n        },\n      };\n\n      // First try to load the file.\n      dicomImageLoader.wadouri\n        .loadFileRequest(this._fileId)\n        .then(dicomFile => {\n          if (this._abortController.signal.aborted) {\n            this._reject(\n              reject,\n              new UploadRejection(UploadStatus.Cancelled, 'Cancelled')\n            );\n            return;\n          }\n\n          if (!this._checkDicomFile(dicomFile)) {\n            // The file is not DICOM\n            this._reject(\n              reject,\n              new UploadRejection(\n                UploadStatus.Failed,\n                'Not a valid DICOM file.'\n              )\n            );\n            return;\n          }\n\n          const request = new XMLHttpRequest();\n          this._addRequestCallbacks(request, uploadCallbacks);\n\n          // Do the actual upload by supplying the DICOM file and upload callbacks/listeners.\n          return this._dataSource.store\n            .dicom(dicomFile, request)\n            .then(() => {\n              this._status = UploadStatus.Success;\n              resolve();\n            })\n            .catch(reason => {\n              this._reject(reject, reason);\n            });\n        })\n        .catch(reason => {\n          this._reject(reject, reason);\n        });\n    });\n\n    return this._loadPromise;\n  }\n\n  private _isRejected(): boolean {\n    return (\n      this._status === UploadStatus.Failed ||\n      this._status === UploadStatus.Cancelled\n    );\n  }\n\n  private _reject(reject: (reason?: any) => void, reason: any) {\n    if (this._isRejected()) {\n      return;\n    }\n\n    if (reason instanceof UploadRejection) {\n      this._status = reason.status;\n      reject(reason);\n      return;\n    }\n\n    this._status = UploadStatus.Failed;\n\n    if (reason.message) {\n      reject(new UploadRejection(UploadStatus.Failed, reason.message));\n      return;\n    }\n\n    reject(new UploadRejection(UploadStatus.Failed, reason));\n  }\n\n  private _addRequestCallbacks(request: XMLHttpRequest, uploadCallbacks) {\n    const abortCallback = () => request.abort();\n    this._abortController.signal.addEventListener('abort', abortCallback);\n\n    for (const [eventName, callback] of Object.entries(uploadCallbacks)) {\n      request.upload.addEventListener(eventName, callback);\n    }\n\n    const cleanUpCallback = () => {\n      this._abortController.signal.removeEventListener('abort', abortCallback);\n\n      for (const [eventName, callback] of Object.entries(uploadCallbacks)) {\n        request.upload.removeEventListener(eventName, callback);\n      }\n\n      request.removeEventListener('loadend', cleanUpCallback);\n    };\n    request.addEventListener('loadend', cleanUpCallback);\n  }\n\n  private _checkDicomFile(arrayBuffer: ArrayBuffer) {\n    if (arrayBuffer.length <= 132) return false;\n    const arr = new Uint8Array(arrayBuffer.slice(128, 132));\n    // bytes from 128 to 132 must be \"DICM\"\n    return Array.from('DICM').every((char, i) => char.charCodeAt(0) === arr[i]);\n  }\n}\n","/**\n * Jump Presets - This enum defines the 3 jump states which are available\n * to be used with the jumpToSlice utility function.\n */\nenum JumpPresets {\n  /** Jumps to first slice */\n  First = 'first',\n  /** Jumps to last slice */\n  Last = 'last',\n  /** Jumps to the middle slice */\n  Middle = 'middle',\n}\n\nexport default JumpPresets;\n","import React from 'react';\nimport { Input, Dialog } from '@ohif/ui';\n\n/**\n *\n * @param {*} data\n * @param {*} data.text\n * @param {*} data.label\n * @param {*} event\n * @param {*} callback\n * @param {*} isArrowAnnotateInputDialog\n * @param {*} dialogConfig\n * @param {string?} dialogConfig.dialogTitle - title of the input dialog\n * @param {string?} dialogConfig.inputLabel - show label above the input\n */\nfunction callInputDialog(\n  uiDialogService,\n  data,\n  callback,\n  isArrowAnnotateInputDialog = true,\n  dialogConfig: any = {}\n) {\n  const dialogId = 'dialog-enter-annotation';\n  const label = data\n    ? isArrowAnnotateInputDialog\n      ? data.text\n      : data.label\n    : '';\n  const {\n    dialogTitle = 'Annotation',\n    inputLabel = 'Enter your annotation',\n    validateFunc = value => true,\n  } = dialogConfig;\n\n  const onSubmitHandler = ({ action, value }) => {\n    switch (action.id) {\n      case 'save':\n        if (typeof validateFunc === 'function' && !validateFunc(value.label))\n          return;\n\n        callback(value.label, action.id);\n        break;\n      case 'cancel':\n        callback('', action.id);\n        break;\n    }\n    uiDialogService.dismiss({ id: dialogId });\n  };\n\n  if (uiDialogService) {\n    uiDialogService.create({\n      id: dialogId,\n      centralize: true,\n      isDraggable: false,\n      showOverlay: true,\n      content: Dialog,\n      contentProps: {\n        title: dialogTitle,\n        value: { label },\n        noCloseButton: true,\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\n        actions: [\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\n          { id: 'save', text: 'Save', type: 'secondary' },\n        ],\n        onSubmit: onSubmitHandler,\n        body: ({ value, setValue }) => {\n          return (\n            <Input\n              autoFocus\n              className=\"bg-black border-primary-main\"\n              type=\"text\"\n              id=\"annotation\"\n              label={inputLabel}\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\n              value={value.label}\n              onChange={event => {\n                event.persist();\n                setValue(value => ({ ...value, label: event.target.value }));\n              }}\n              onKeyPress={event => {\n                if (event.key === 'Enter') {\n                  onSubmitHandler({ value, action: { id: 'save' } });\n                }\n              }}\n            />\n          );\n        },\n      },\n    });\n  }\n}\n\nexport default callInputDialog;\n","import { imageLoader } from '@cornerstonejs/core';\nimport dicomImageLoader from '@cornerstonejs/dicom-image-loader';\nimport { api } from 'dicomweb-client';\nimport { DICOMWeb, errorHandler } from '@ohif/core';\n\nconst getImageId = imageObj => {\n  if (!imageObj) {\n    return;\n  }\n\n  return typeof imageObj.getImageId === 'function'\n    ? imageObj.getImageId()\n    : imageObj.url;\n};\n\nconst findImageIdOnStudies = (studies, displaySetInstanceUID) => {\n  const study = studies.find(study => {\n    const displaySet = study.displaySets.some(\n      displaySet => displaySet.displaySetInstanceUID === displaySetInstanceUID\n    );\n    return displaySet;\n  });\n  const { series = [] } = study;\n  const { instances = [] } = series[0] || {};\n  const instance = instances[0];\n\n  return getImageId(instance);\n};\n\nconst someInvalidStrings = strings => {\n  const stringsArray = Array.isArray(strings) ? strings : [strings];\n  const emptyString = string => !string;\n  let invalid = stringsArray.some(emptyString);\n  return invalid;\n};\n\nconst getImageInstance = dataset => {\n  return dataset && dataset.images && dataset.images[0];\n};\n\nconst getNonImageInstance = dataset => {\n  return dataset && dataset.instance;\n};\n\nconst getImageInstanceId = imageInstance => {\n  return getImageId(imageInstance);\n};\n\nconst fetchIt = (url, headers = DICOMWeb.getAuthorizationHeader()) => {\n  return fetch(url, headers).then(response => response.arrayBuffer());\n};\n\nconst cornerstoneRetriever = imageId => {\n  return imageLoader.loadAndCacheImage(imageId).then(image => {\n    return image && image.data && image.data.byteArray.buffer;\n  });\n};\n\nconst wadorsRetriever = (\n  url,\n  studyInstanceUID,\n  seriesInstanceUID,\n  sopInstanceUID,\n  headers = DICOMWeb.getAuthorizationHeader(),\n  errorInterceptor = errorHandler.getHTTPErrorHandler()\n) => {\n  const config = {\n    url,\n    headers,\n    errorInterceptor,\n  };\n  const dicomWeb = new api.DICOMwebClient(config);\n\n  return dicomWeb.retrieveInstance({\n    studyInstanceUID,\n    seriesInstanceUID,\n    sopInstanceUID,\n  });\n};\n\nconst getImageLoaderType = imageId => {\n  const loaderRegExp = /^\\w+\\:/;\n  const loaderType = loaderRegExp.exec(imageId);\n\n  return (\n    (loaderRegExp.lastIndex === 0 &&\n      loaderType &&\n      loaderType[0] &&\n      loaderType[0].replace(':', '')) ||\n    ''\n  );\n};\n\nclass DicomLoaderService {\n  getLocalData(dataset, studies) {\n    // Use referenced imageInstance\n    const imageInstance = getImageInstance(dataset);\n    const nonImageInstance = getNonImageInstance(dataset);\n\n    if (\n      (!imageInstance && !nonImageInstance) ||\n      !nonImageInstance.imageId.startsWith('dicomfile')\n    ) {\n      return;\n    }\n\n    const instance = imageInstance || nonImageInstance;\n\n    let imageId = getImageInstanceId(instance);\n\n    // or Try to get it from studies\n    if (someInvalidStrings(imageId)) {\n      imageId = findImageIdOnStudies(studies, dataset.displaySetInstanceUID);\n    }\n\n    if (!someInvalidStrings(imageId)) {\n      return dicomImageLoader.wadouri.loadFileRequest(imageId);\n    }\n  }\n\n  getDataByImageType(dataset) {\n    const imageInstance = getImageInstance(dataset);\n\n    if (imageInstance) {\n      const imageId = getImageInstanceId(imageInstance);\n      let getDicomDataMethod = fetchIt;\n      const loaderType = getImageLoaderType(imageId);\n\n      switch (loaderType) {\n        case 'dicomfile':\n          getDicomDataMethod = cornerstoneRetriever.bind(this, imageId);\n          break;\n        case 'wadors':\n          const url = imageInstance.getData().wadoRoot;\n          const studyInstanceUID = imageInstance.getStudyInstanceUID();\n          const seriesInstanceUID = imageInstance.getSeriesInstanceUID();\n          const sopInstanceUID = imageInstance.getSOPInstanceUID();\n          const invalidParams = someInvalidStrings([\n            url,\n            studyInstanceUID,\n            seriesInstanceUID,\n            sopInstanceUID,\n          ]);\n          if (invalidParams) {\n            return;\n          }\n\n          getDicomDataMethod = wadorsRetriever.bind(\n            this,\n            url,\n            studyInstanceUID,\n            seriesInstanceUID,\n            sopInstanceUID\n          );\n          break;\n        case 'wadouri':\n          // Strip out the image loader specifier\n          imageId = imageId.substring(imageId.indexOf(':') + 1);\n\n          if (someInvalidStrings(imageId)) {\n            return;\n          }\n          getDicomDataMethod = fetchIt.bind(this, imageId);\n          break;\n        default:\n          throw new Error(\n            `Unsupported image type: ${loaderType} for imageId: ${imageId}`\n          );\n      }\n\n      return getDicomDataMethod();\n    }\n  }\n\n  getDataByDatasetType(dataset) {\n    const {\n      StudyInstanceUID,\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      authorizationHeaders,\n      wadoRoot,\n      wadoUri,\n    } = dataset;\n    // Retrieve wadors or just try to fetch wadouri\n    if (!someInvalidStrings(wadoRoot)) {\n      return wadorsRetriever(\n        wadoRoot,\n        StudyInstanceUID,\n        SeriesInstanceUID,\n        SOPInstanceUID,\n        authorizationHeaders\n      );\n    } else if (!someInvalidStrings(wadoUri)) {\n      return fetchIt(wadoUri, { headers: authorizationHeaders });\n    }\n  }\n\n  *getLoaderIterator(dataset, studies, headers) {\n    yield this.getLocalData(dataset, studies);\n    yield this.getDataByImageType(dataset);\n    yield this.getDataByDatasetType(dataset);\n  }\n\n  findDicomDataPromise(dataset, studies, headers) {\n    dataset.authorizationHeaders = headers;\n    const loaderIterator = this.getLoaderIterator(dataset, studies);\n    // it returns first valid retriever method.\n    for (const loader of loaderIterator) {\n      if (loader) {\n        return loader;\n      }\n    }\n\n    // in case of no valid loader\n    throw new Error('Invalid dicom data loader');\n  }\n}\n\nconst dicomLoaderService = new DicomLoaderService();\n\nexport default dicomLoaderService;\n","/**\n * Finds tool nearby event position triggered.\n *\n * @param {Object} commandsManager mannager of commands\n * @param {Object} event that has being triggered\n * @returns cs toolData or undefined if not found.\n */\nexport const findNearbyToolData = (commandsManager, evt) => {\n  if (!evt?.detail) {\n    return;\n  }\n  const { element, currentPoints } = evt.detail;\n  return commandsManager.runCommand(\n    'getNearbyAnnotation',\n    {\n      element,\n      canvasCoordinates: currentPoints?.canvas,\n    },\n    'CORNERSTONE'\n  );\n};\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { IEnabledElement } from '@cornerstonejs/core/dist/esm/types';\n\nimport { getEnabledElement as OHIFgetEnabledElement } from '../state';\n\nexport default function getActiveViewportEnabledElement(\n  viewportGridService\n): IEnabledElement {\n  const { activeViewportIndex } = viewportGridService.getState();\n  const { element } = OHIFgetEnabledElement(activeViewportIndex) || {};\n  const enabledElement = getEnabledElement(element);\n  return enabledElement;\n}\n","import { Enums } from '@cornerstonejs/core';\n\nconst MIP = 'mip';\n\nexport default function getCornerstoneBlendMode(\n  blendMode: string\n): Enums.BlendModes {\n  if (!blendMode) {\n    return Enums.BlendModes.COMPOSITE;\n  }\n\n  if (blendMode.toLowerCase() === MIP) {\n    return Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n  }\n\n  throw new Error();\n}\n","import { Enums } from '@cornerstonejs/core';\n\nconst AXIAL = 'axial';\nconst SAGITTAL = 'sagittal';\nconst CORONAL = 'coronal';\n\nexport default function getCornerstoneOrientation(\n  orientation: string\n): Enums.OrientationAxis {\n  if (orientation) {\n    switch (orientation.toLowerCase()) {\n      case AXIAL:\n        return Enums.OrientationAxis.AXIAL;\n      case SAGITTAL:\n        return Enums.OrientationAxis.SAGITTAL;\n      case CORONAL:\n        return Enums.OrientationAxis.CORONAL;\n      default:\n        return Enums.OrientationAxis.ACQUISITION;\n    }\n  }\n\n  return Enums.OrientationAxis.ACQUISITION;\n}\n","import { Enums } from '@cornerstonejs/core';\n\nconst STACK = 'stack';\nconst VOLUME = 'volume';\nconst ORTHOGRAPHIC = 'orthographic';\nconst VOLUME_3D = 'volume3d';\n\nexport default function getCornerstoneViewportType(\n  viewportType: string\n): Enums.ViewportType {\n  const lowerViewportType = viewportType.toLowerCase();\n  if (lowerViewportType === STACK) {\n    return Enums.ViewportType.STACK;\n  }\n\n  if (lowerViewportType === VOLUME || lowerViewportType === ORTHOGRAPHIC) {\n    return Enums.ViewportType.ORTHOGRAPHIC;\n  }\n\n  if (lowerViewportType === VOLUME_3D) {\n    return Enums.ViewportType.VOLUME_3D;\n  }\n\n  throw new Error(\n    `Invalid viewport type: ${viewportType}. Valid types are: stack, volume`\n  );\n}\n","export default function getInterleavedFrames(imageIds) {\n  const minImageIdIndex = 0;\n  const maxImageIdIndex = imageIds.length - 1;\n\n  const middleImageIdIndex = Math.floor(imageIds.length / 2);\n\n  let lowerImageIdIndex = middleImageIdIndex;\n  let upperImageIdIndex = middleImageIdIndex;\n\n  // Build up an array of images to prefetch, starting with the current image.\n  const imageIdsToPrefetch = [\n    { imageId: imageIds[middleImageIdIndex], imageIdIndex: middleImageIdIndex },\n  ];\n\n  const prefetchQueuedFilled = {\n    currentPositionDownToMinimum: false,\n    currentPositionUpToMaximum: false,\n  };\n\n  // Check if on edges and some criteria is already fulfilled\n\n  if (middleImageIdIndex === minImageIdIndex) {\n    prefetchQueuedFilled.currentPositionDownToMinimum = true;\n  } else if (middleImageIdIndex === maxImageIdIndex) {\n    prefetchQueuedFilled.currentPositionUpToMaximum = true;\n  }\n\n  while (\n    !prefetchQueuedFilled.currentPositionDownToMinimum ||\n    !prefetchQueuedFilled.currentPositionUpToMaximum\n  ) {\n    if (!prefetchQueuedFilled.currentPositionDownToMinimum) {\n      // Add imageId bellow\n      lowerImageIdIndex--;\n      imageIdsToPrefetch.push({\n        imageId: imageIds[lowerImageIdIndex],\n        imageIdIndex: lowerImageIdIndex,\n      });\n\n      if (lowerImageIdIndex === minImageIdIndex) {\n        prefetchQueuedFilled.currentPositionDownToMinimum = true;\n      }\n    }\n\n    if (!prefetchQueuedFilled.currentPositionUpToMaximum) {\n      // Add imageId above\n      upperImageIdIndex++;\n      imageIdsToPrefetch.push({\n        imageId: imageIds[upperImageIdIndex],\n        imageIdIndex: upperImageIdIndex,\n      });\n\n      if (upperImageIdIndex === maxImageIdIndex) {\n        prefetchQueuedFilled.currentPositionUpToMaximum = true;\n      }\n    }\n  }\n\n  return imageIdsToPrefetch;\n}\n","/**\n * Returns a re-ordered array consisting of, in order:\n *    1. First few objects\n *    2. Center objects\n *    3. Last few objects\n *    4. nth Objects (n=7), set 2\n *    5. nth Objects set 5,\n *    6. Remaining objects\n * What this does is return the first/center/start objects, as those\n * are often used first, then a selection of objects scattered over the\n * instances in order to allow making requests over a set of image instances.\n *\n * @param {[]} imageIds\n * @returns [] reordered to be an nth selection\n */\nexport default function getNthFrames(imageIds) {\n  const frames = [[], [], [], [], []];\n  const centerStart = imageIds.length / 2 - 3;\n  const centerEnd = centerStart + 6;\n\n  for (let i = 0; i < imageIds.length; i++) {\n    if (\n      i < 2 ||\n      i > imageIds.length - 4 ||\n      (i > centerStart && i < centerEnd)\n    ) {\n      frames[0].push(imageIds[i]);\n    } else if (i % 7 === 2) {\n      frames[1].push(imageIds[i]);\n    } else if (i % 7 === 5) {\n      frames[2].push(imageIds[i]);\n    } else {\n      frames[(i % 2) + 3].push(imageIds[i]);\n    }\n  }\n  const ret = [\n    ...frames[0],\n    ...frames[1],\n    ...frames[2],\n    ...frames[3],\n    ...frames[4],\n  ];\n  return ret;\n}\n","/**\n * Interleave the items from all the lists so that the first items are first\n * in the returned list, the second items are next etc.\n * Does this in a O(n) fashion, and return lists[0] if there is only one list.\n *\n * @param {[]} lists\n * @returns [] reordered to be breadth first traversal of lists\n */\nexport default function interleave(lists) {\n  if (!lists || !lists.length) return [];\n  if (lists.length === 1) return lists[0];\n  console.time('interleave');\n  const useLists = [...lists];\n  const ret = [];\n  for (let i = 0; useLists.length > 0; i++) {\n    for (const list of useLists) {\n      if (i >= list.length) {\n        useLists.splice(useLists.indexOf(list), 1);\n        continue;\n      }\n      ret.push(list[i]);\n    }\n  }\n  console.timeEnd('interleave');\n  return ret;\n}\n","import { cache, imageLoadPoolManager, Enums } from '@cornerstonejs/core';\nimport getInterleavedFrames from './getInterleavedFrames';\nimport { compact, flatten, zip } from 'lodash';\n\n// Map of volumeId and SeriesInstanceId\nconst volumeIdMapsToLoad = new Map<string, string>();\nconst viewportIdVolumeInputArrayMap = new Map<string, unknown[]>();\n\n/**\n * This function caches the volumeUIDs until all the volumes inside the\n * hanging protocol are initialized. Then it goes through the imageIds\n * of the volumes, and interleave them, in order for the volumes to be loaded\n * together from middle to the start and the end.\n * @param {Object} props image loading properties from Cornerstone ViewportService\n * @returns\n */\nexport default function interleaveCenterLoader({\n  data: { viewportId, volumeInputArray },\n  displaySetsMatchDetails,\n  viewportMatchDetails: matchDetails,\n}) {\n  viewportIdVolumeInputArrayMap.set(viewportId, volumeInputArray);\n\n  // Based on the volumeInputs store the volumeIds and SeriesInstanceIds\n  // to keep track of the volumes being loaded\n  for (const volumeInput of volumeInputArray) {\n    const { volumeId } = volumeInput;\n    const volume = cache.getVolume(volumeId);\n\n    if (!volume) {\n      return;\n    }\n\n    // if the volumeUID is not in the volumeUIDs array, add it\n    if (!volumeIdMapsToLoad.has(volumeId)) {\n      const { metadata } = volume;\n      volumeIdMapsToLoad.set(volumeId, metadata.SeriesInstanceUID);\n    }\n  }\n\n  /**\n   * The following is checking if all the viewports that were matched in the HP has been\n   * successfully created their cornerstone viewport or not. Todo: This can be\n   * improved by not checking it, and as soon as the matched DisplaySets have their\n   * volume loaded, we start the loading, but that comes at the cost of viewports\n   * not being created yet (e.g., in a 10 viewport ptCT fusion, when one ct viewport and one\n   * pt viewport are created we have a guarantee that the volumes are created in the cache\n   * but the rest of the viewports (fusion, mip etc.) are not created yet. So\n   * we can't initiate setting the volumes for those viewports. One solution can be\n   * to add an event when a viewport is created (not enabled element event) and then\n   * listen to it and as the other viewports are created we can set the volumes for them\n   * since volumes are already started loading.\n   */\n  if (matchDetails.size !== viewportIdVolumeInputArrayMap.size) {\n    return;\n  }\n\n  // Check if all the matched volumes are loaded\n  for (const [_, details] of displaySetsMatchDetails.entries()) {\n    const { SeriesInstanceUID } = details;\n\n    // HangingProtocol has matched, but don't have all the volumes created yet, so return\n    if (!Array.from(volumeIdMapsToLoad.values()).includes(SeriesInstanceUID)) {\n      return;\n    }\n  }\n\n  const volumeIds = Array.from(volumeIdMapsToLoad.keys()).slice();\n  // get volumes from cache\n  const volumes = volumeIds.map(volumeId => {\n    return cache.getVolume(volumeId);\n  });\n\n  // iterate over all volumes, and get their imageIds, and interleave\n  // the imageIds and save them in AllRequests for later use\n  const AllRequests = [];\n  volumes.forEach(volume => {\n    const requests = volume.getImageLoadRequests();\n\n    if (!requests.length || !requests[0] || !requests[0].imageId) {\n      return;\n    }\n\n    const requestImageIds = requests.map(request => {\n      return request.imageId;\n    });\n\n    const imageIds = getInterleavedFrames(requestImageIds);\n\n    const reOrderedRequests = imageIds.map(({ imageId }) => {\n      const request = requests.find(req => req.imageId === imageId);\n      return request;\n    });\n\n    AllRequests.push(reOrderedRequests);\n  });\n\n  // flatten the AllRequests array, which will result in a list of all the\n  // imageIds for all the volumes but interleaved\n  const interleavedRequests = compact(flatten(zip(...AllRequests)));\n\n  // set the finalRequests to the imageLoadPoolManager\n  const finalRequests = [];\n  interleavedRequests.forEach(request => {\n    const { imageId } = request;\n\n    AllRequests.forEach(volumeRequests => {\n      const volumeImageIdRequest = volumeRequests.find(\n        req => req.imageId === imageId\n      );\n      if (volumeImageIdRequest) {\n        finalRequests.push(volumeImageIdRequest);\n      }\n    });\n  });\n\n  const requestType = Enums.RequestType.Prefetch;\n  const priority = 0;\n\n  finalRequests.forEach(\n    ({ callLoadImage, additionalDetails, imageId, imageIdIndex, options }) => {\n      const callLoadImageBound = callLoadImage.bind(\n        null,\n        imageId,\n        imageIdIndex,\n        options\n      );\n\n      imageLoadPoolManager.addRequest(\n        callLoadImageBound,\n        requestType,\n        additionalDetails,\n        priority\n      );\n    }\n  );\n\n  // clear the volumeIdMapsToLoad\n  volumeIdMapsToLoad.clear();\n\n  // copy the viewportIdVolumeInputArrayMap\n  const viewportIdVolumeInputArrayMapCopy = new Map(\n    viewportIdVolumeInputArrayMap\n  );\n\n  // reset the viewportIdVolumeInputArrayMap\n  viewportIdVolumeInputArrayMap.clear();\n\n  return viewportIdVolumeInputArrayMapCopy;\n}\n","import { cache, imageLoadPoolManager, Enums } from '@cornerstonejs/core';\nimport { compact, flatten, zip } from 'lodash';\n\n// Map of volumeId and SeriesInstanceId\nconst volumeIdMapsToLoad = new Map<string, string>();\nconst viewportIdVolumeInputArrayMap = new Map<string, unknown[]>();\n\n/**\n * This function caches the volumeIds until all the volumes inside the\n * hanging protocol are initialized. Then it goes through the imageIds\n * of the volumes, and interleave them, in order for the volumes to be loaded\n * together from middle to the start and the end.\n * @param {Object} {viewportData, displaySetMatchDetails}\n * @returns\n */\nexport default function interleaveTopToBottom({\n  data: { viewportId, volumeInputArray },\n  displaySetsMatchDetails,\n  viewportMatchDetails: matchDetails,\n}) {\n  viewportIdVolumeInputArrayMap.set(viewportId, volumeInputArray);\n\n  // Based on the volumeInputs store the volumeIds and SeriesInstanceIds\n  // to keep track of the volumes being loaded\n  for (const volumeInput of volumeInputArray) {\n    const { volumeId } = volumeInput;\n    const volume = cache.getVolume(volumeId);\n\n    if (!volume) {\n      return;\n    }\n\n    // if the volumeUID is not in the volumeUIDs array, add it\n    if (!volumeIdMapsToLoad.has(volumeId)) {\n      const { metadata } = volume;\n      volumeIdMapsToLoad.set(volumeId, metadata.SeriesInstanceUID);\n    }\n  }\n\n  /**\n   * The following is checking if all the viewports that were matched in the HP has been\n   * successfully created their cornerstone viewport or not. Todo: This can be\n   * improved by not checking it, and as soon as the matched DisplaySets have their\n   * volume loaded, we start the loading, but that comes at the cost of viewports\n   * not being created yet (e.g., in a 10 viewport ptCT fusion, when one ct viewport and one\n   * pt viewport are created we have a guarantee that the volumes are created in the cache\n   * but the rest of the viewports (fusion, mip etc.) are not created yet. So\n   * we can't initiate setting the volumes for those viewports. One solution can be\n   * to add an event when a viewport is created (not enabled element event) and then\n   * listen to it and as the other viewports are created we can set the volumes for them\n   * since volumes are already started loading.\n   */\n  if (matchDetails.size !== viewportIdVolumeInputArrayMap.size) {\n    return;\n  }\n\n  // Check if all the matched volumes are loaded\n  for (const [_, details] of displaySetsMatchDetails.entries()) {\n    const { SeriesInstanceUID } = details;\n\n    // HangingProtocol has matched, but don't have all the volumes created yet, so return\n    if (!Array.from(volumeIdMapsToLoad.values()).includes(SeriesInstanceUID)) {\n      return;\n    }\n  }\n\n  const volumeIds = Array.from(volumeIdMapsToLoad.keys()).slice();\n  // get volumes from cache\n  const volumes = volumeIds.map(volumeId => {\n    return cache.getVolume(volumeId);\n  });\n\n  // iterate over all volumes, and get their imageIds, and interleave\n  // the imageIds and save them in AllRequests for later use\n  const AllRequests = [];\n  volumes.forEach(volume => {\n    const requests = volume.getImageLoadRequests();\n\n    if (!requests.length || !requests[0] || !requests[0].imageId) {\n      return;\n    }\n\n    // reverse the requests\n    AllRequests.push(requests.reverse());\n  });\n\n  // flatten the AllRequests array, which will result in a list of all the\n  // imageIds for all the volumes but interleaved\n  const interleavedRequests = compact(flatten(zip(...AllRequests)));\n\n  // set the finalRequests to the imageLoadPoolManager\n  const finalRequests = [];\n  interleavedRequests.forEach(request => {\n    const { imageId } = request;\n\n    AllRequests.forEach(volumeRequests => {\n      const volumeImageIdRequest = volumeRequests.find(\n        req => req.imageId === imageId\n      );\n      if (volumeImageIdRequest) {\n        finalRequests.push(volumeImageIdRequest);\n      }\n    });\n  });\n\n  const requestType = Enums.RequestType.Prefetch;\n  const priority = 0;\n\n  finalRequests.forEach(\n    ({ callLoadImage, additionalDetails, imageId, imageIdIndex, options }) => {\n      const callLoadImageBound = callLoadImage.bind(\n        null,\n        imageId,\n        imageIdIndex,\n        options\n      );\n\n      imageLoadPoolManager.addRequest(\n        callLoadImageBound,\n        requestType,\n        additionalDetails,\n        priority\n      );\n    }\n  );\n\n  // clear the volumeIdMapsToLoad\n  volumeIdMapsToLoad.clear();\n\n  // copy the viewportIdVolumeInputArrayMap\n  const viewportIdVolumeInputArrayMapCopy = new Map(\n    viewportIdVolumeInputArrayMap\n  );\n\n  // reset the viewportIdVolumeInputArrayMap\n  viewportIdVolumeInputArrayMap.clear();\n\n  return viewportIdVolumeInputArrayMapCopy;\n}\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst Angle = {\n  toAnnotation: measurement => { },\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      displaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations?.[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return;\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error(\n        'Non-acquisition plane measurement mapping not supported'\n      );\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber,\n    } = getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { angle } = targetStats;\n    const unit = '\\u00B0';\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      angle,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:Angle');\n\n  mappedAnnotations.forEach(annotation => {\n    const { angle, unit } = annotation;\n    columns.push(`Angle (${unit})`);\n    values.push(angle);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const {\n    angle,\n    unit,\n    SeriesNumber,\n    SOPInstanceUID,\n    frameNumber,\n  } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n  if (angle === undefined) return displayText;\n  const roundedAngle = utils.roundNumber(angle, 2);\n  displayText.push(\n    `${roundedAngle} ${unit} (S: ${SeriesNumber}${instanceText}${frameText})`\n  );\n\n  return displayText;\n}\n\nexport default Angle;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\n\nconst Length = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      cornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      displaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.text,\n      text: data.text,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport: () => {\n        throw new Error('Not implemented');\n      },\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { text } = data;\n  const { referencedImageId } = metadata;\n\n  const annotations = [];\n\n  const {\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    frameNumber,\n  } = getSOPInstanceAttributes(referencedImageId);\n\n  const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    frameNumber\n  );\n\n  const { SeriesNumber } = displaySet;\n\n  annotations.push({\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesNumber,\n    frameNumber,\n    text,\n  });\n\n  return annotations;\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { SeriesNumber, SOPInstanceUID, frameNumber } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  displayText.push(`(S: ${SeriesNumber}${instanceText}${frameText})`);\n\n  return displayText;\n}\n\nexport default Length;\n","import { annotation } from '@cornerstonejs/tools';\n\nimport SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst Bidirectional = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      cornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      displaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId, referencedSeriesInstanceUID } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error(\n        'Non-acquisition plane measurement mapping not supported'\n      );\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber,\n    } = getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { length, width } = targetStats;\n    const unit = 'mm';\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      length,\n      width,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:Bidirectional');\n\n  mappedAnnotations.forEach(annotation => {\n    const { length, width } = annotation;\n    columns.push(`Length (mm)`, `Width (mm)`);\n    values.push(length, width);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const {\n    length,\n    width,\n    SeriesNumber,\n    SOPInstanceUID,\n    frameNumber,\n  } = mappedAnnotations[0];\n  const roundedLength = utils.roundNumber(length, 2);\n  const roundedWidth = utils.roundNumber(width, 2);\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  displayText.push(\n    `L: ${roundedLength} mm (S: ${SeriesNumber}${instanceText}${frameText})`\n  );\n  displayText.push(`W: ${roundedWidth} mm`);\n\n  return displayText;\n}\n\nexport default Bidirectional;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport getModalityUnit from './utils/getModalityUnit';\nimport { utils } from '@ohif/core';\n\nconst CircleROI = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    DisplaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = DisplaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      DisplaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      // Todo: Non-acquisition plane measurement mapping not supported yet\n      throw new Error(\n        'Non-acquisition plane measurement mapping not supported'\n      );\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber,\n    } = getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { mean, stdDev, max, area, Modality } = targetStats;\n    const unit = getModalityUnit(Modality);\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      Modality,\n      unit,\n      mean,\n      stdDev,\n      max,\n      area,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:CircleROI');\n\n  mappedAnnotations.forEach(annotation => {\n    const { mean, stdDev, max, area, unit } = annotation;\n\n    if (!mean || !unit || !max || !area) {\n      return;\n    }\n\n    columns.push(\n      `max (${unit})`,\n      `mean (${unit})`,\n      `std (${unit})`,\n      `area (mm2)`\n    );\n    values.push(max, mean, stdDev, area);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { area, SOPInstanceUID, frameNumber } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  // Area sometimes becomes undefined if `preventHandleOutsideImage` is off.\n  const roundedArea = utils.roundNumber(area || 0, 2);\n  displayText.push(`${roundedArea} mm<sup>2</sup>`);\n\n  // Todo: we need a better UI for displaying all these information\n  mappedAnnotations.forEach(mappedAnnotation => {\n    const { unit, max, SeriesNumber } = mappedAnnotation;\n\n    let maxStr = '';\n    if (max) {\n      const roundedMax = utils.roundNumber(max, 2);\n      maxStr = `Max: ${roundedMax} <small>${unit}</small> `;\n    }\n\n    const str = `${maxStr}(S:${SeriesNumber}${instanceText}${frameText})`;\n    if (!displayText.includes(str)) {\n      displayText.push(str);\n    }\n  });\n\n  return displayText;\n}\n\nexport default CircleROI;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst CobbAngle = {\n  toAnnotation: measurement => { },\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Cobb Angle tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      displaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations?.[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return;\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error(\n        'Non-acquisition plane measurement mapping not supported'\n      );\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber,\n    } = getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { angle } = targetStats;\n    const unit = '\\u00B0';\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      angle,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:CobbAngle');\n\n  mappedAnnotations.forEach(annotation => {\n    const { angle, unit } = annotation;\n    columns.push(`Angle (${unit})`);\n    values.push(angle);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const {\n    angle,\n    unit,\n    SeriesNumber,\n    SOPInstanceUID,\n    frameNumber,\n  } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n  if (angle === undefined) return displayText;\n  const roundedAngle = utils.roundNumber(angle, 2);\n  displayText.push(\n    `${roundedAngle} ${unit} (S: ${SeriesNumber}${instanceText}${frameText})`\n  );\n\n  return displayText;\n}\n\nexport default CobbAngle;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport getModalityUnit from './utils/getModalityUnit';\nimport { utils } from '@ohif/core';\n\nconst EllipticalROI = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      cornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      displaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      // Todo: Non-acquisition plane measurement mapping not supported yet\n      throw new Error(\n        'Non-acquisition plane measurement mapping not supported'\n      );\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber,\n    } = getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { mean, stdDev, max, area, Modality } = targetStats;\n    const unit = getModalityUnit(Modality);\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      Modality,\n      unit,\n      mean,\n      stdDev,\n      max,\n      area,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:EllipticalROI');\n\n  mappedAnnotations.forEach(annotation => {\n    const { mean, stdDev, max, area, unit } = annotation;\n\n    if (!mean || !unit || !max || !area) {\n      return;\n    }\n\n    columns.push(\n      `max (${unit})`,\n      `mean (${unit})`,\n      `std (${unit})`,\n      `area (mm2)`\n    );\n    values.push(max, mean, stdDev, area);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { area, SOPInstanceUID, frameNumber } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  // Area sometimes becomes undefined if `preventHandleOutsideImage` is off.\n  const roundedArea = utils.roundNumber(area || 0, 2);\n  displayText.push(`${roundedArea} mm<sup>2</sup>`);\n\n  // Todo: we need a better UI for displaying all these information\n  mappedAnnotations.forEach(mappedAnnotation => {\n    const { unit, max, SeriesNumber } = mappedAnnotation;\n\n    let maxStr = '';\n    if (max) {\n      const roundedMax = utils.roundNumber(max, 2);\n      maxStr = `Max: ${roundedMax} <small>${unit}</small> `;\n    }\n\n    const str = `${maxStr}(S:${SeriesNumber}${instanceText}${frameText})`;\n    if (!displayText.includes(str)) {\n      displayText.push(str);\n    }\n  });\n\n  return displayText;\n}\n\nexport default EllipticalROI;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport { utils } from '@ohif/core';\n\nconst Length = {\n  toAnnotation: measurement => {},\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    displaySetService,\n    cornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Length tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } =\n      getSOPInstanceAttributes(\n        referencedImageId,\n        cornerstoneViewportService,\n        viewportId\n      );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = displaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      displaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, displaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      throw new Error(\n        'Non-acquisition plane measurement mapping not supported'\n      );\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n      getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = displaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { length } = targetStats;\n    const unit = 'mm';\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      unit,\n      length,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:Length');\n\n  mappedAnnotations.forEach(annotation => {\n    const { length } = annotation;\n    columns.push(`Length (mm)`);\n    values.push(length);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { length, SeriesNumber, SOPInstanceUID, frameNumber } =\n    mappedAnnotations[0];\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  if (length === null || length === undefined) return displayText;\n  const roundedLength = utils.roundNumber(length, 2);\n  displayText.push(\n    `${roundedLength} mm (S: ${SeriesNumber}${instanceText}${frameText})`\n  );\n\n  return displayText;\n}\n\nexport default Length;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\n\nconst PlanarFreehandROI = {\n  toAnnotation: measurement => { },\n\n  /**\n   * Maps cornerstone annotation event data to measurement service format.\n   *\n   * @param {Object} cornerstone Cornerstone event data\n   * @return {Measurement} Measurement instance\n   */\n  toMeasurement: (\n    csToolsEventDetail,\n    DisplaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('PlanarFreehandROI tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const {\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      StudyInstanceUID,\n    } = getSOPInstanceAttributes(\n      referencedImageId,\n      CornerstoneViewportService,\n      viewportId\n    );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = DisplaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      DisplaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: { ...data, ...data.cachedStats },\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\n/**\n * It maps an imaging library annotation to a list of simplified annotation properties.\n *\n * @param {Object} annotationData\n * @param {Object} DisplaySetService\n * @returns\n */\nfunction getMappedAnnotations(annotationData, DisplaySetService) {\n  const { metadata, data } = annotationData;\n  const { label } = data;\n  const { referencedImageId } = metadata;\n\n  const annotations = [];\n\n  const {\n    SOPInstanceUID: _SOPInstanceUID,\n    SeriesInstanceUID: _SeriesInstanceUID,\n  } = getSOPInstanceAttributes(referencedImageId) || {};\n\n  if (!_SOPInstanceUID || !_SeriesInstanceUID) {\n    return annotations;\n  }\n\n  const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n    _SOPInstanceUID,\n    _SeriesInstanceUID\n  );\n\n  const { SeriesNumber, SeriesInstanceUID } = displaySet;\n\n  annotations.push({\n    SeriesInstanceUID,\n    SeriesNumber,\n    label,\n    data,\n  });\n\n  return annotations;\n}\n\n/**\n * TBD\n * This function is used to convert the measurement data to a format that is suitable for the report generation (e.g. for the csv report).\n * The report returns a list of columns and corresponding values.\n * @param {*} mappedAnnotations\n * @param {*} points\n * @param {*} FrameOfReferenceUID\n * @returns Object representing the report's content for this tool.\n */\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations) {\n  return '';\n}\n\nexport default PlanarFreehandROI;\n","import SUPPORTED_TOOLS from './constants/supportedTools';\nimport getSOPInstanceAttributes from './utils/getSOPInstanceAttributes';\nimport getModalityUnit from './utils/getModalityUnit';\nimport { utils } from '@ohif/core';\n\nconst RectangleROI = {\n  toAnnotation: measurement => {},\n  toMeasurement: (\n    csToolsEventDetail,\n    DisplaySetService,\n    CornerstoneViewportService,\n    getValueTypeFromToolType\n  ) => {\n    const { annotation, viewportId } = csToolsEventDetail;\n    const { metadata, data, annotationUID } = annotation;\n\n    if (!metadata || !data) {\n      console.warn('Rectangle ROI tool: Missing metadata or data');\n      return null;\n    }\n\n    const { toolName, referencedImageId, FrameOfReferenceUID } = metadata;\n    const validToolType = SUPPORTED_TOOLS.includes(toolName);\n\n    if (!validToolType) {\n      throw new Error('Tool not supported');\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, StudyInstanceUID } =\n      getSOPInstanceAttributes(\n        referencedImageId,\n        CornerstoneViewportService,\n        viewportId\n      );\n\n    let displaySet;\n\n    if (SOPInstanceUID) {\n      displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n        SOPInstanceUID,\n        SeriesInstanceUID\n      );\n    } else {\n      displaySet = DisplaySetService.getDisplaySetsForSeries(SeriesInstanceUID);\n    }\n\n    const { points } = data.handles;\n\n    const mappedAnnotations = getMappedAnnotations(\n      annotation,\n      DisplaySetService\n    );\n\n    const displayText = getDisplayText(mappedAnnotations, displaySet);\n    const getReport = () =>\n      _getReport(mappedAnnotations, points, FrameOfReferenceUID);\n\n    return {\n      uid: annotationUID,\n      SOPInstanceUID,\n      FrameOfReferenceUID,\n      points,\n      metadata,\n      referenceSeriesUID: SeriesInstanceUID,\n      referenceStudyUID: StudyInstanceUID,\n      frameNumber: mappedAnnotations[0]?.frameNumber || 1,\n      toolName: metadata.toolName,\n      displaySetInstanceUID: displaySet.displaySetInstanceUID,\n      label: data.label,\n      displayText: displayText,\n      data: data.cachedStats,\n      type: getValueTypeFromToolType(toolName),\n      getReport,\n    };\n  },\n};\n\nfunction getMappedAnnotations(annotation, DisplaySetService) {\n  const { metadata, data } = annotation;\n  const { cachedStats } = data;\n  const { referencedImageId } = metadata;\n  const targets = Object.keys(cachedStats);\n\n  if (!targets.length) {\n    return [];\n  }\n\n  const annotations = [];\n  Object.keys(cachedStats).forEach(targetId => {\n    const targetStats = cachedStats[targetId];\n\n    if (!referencedImageId) {\n      // Todo: Non-acquisition plane measurement mapping not supported yet\n      throw new Error(\n        'Non-acquisition plane measurement mapping not supported'\n      );\n    }\n\n    const { SOPInstanceUID, SeriesInstanceUID, frameNumber } =\n      getSOPInstanceAttributes(referencedImageId);\n\n    const displaySet = DisplaySetService.getDisplaySetForSOPInstanceUID(\n      SOPInstanceUID,\n      SeriesInstanceUID,\n      frameNumber\n    );\n\n    const { SeriesNumber } = displaySet;\n    const { mean, stdDev, max, area, Modality } = targetStats;\n    const unit = getModalityUnit(Modality);\n\n    annotations.push({\n      SeriesInstanceUID,\n      SOPInstanceUID,\n      SeriesNumber,\n      frameNumber,\n      Modality,\n      unit,\n      mean,\n      stdDev,\n      max,\n      area,\n    });\n  });\n\n  return annotations;\n}\n\n/*\nThis function is used to convert the measurement data to a format that is\nsuitable for the report generation (e.g. for the csv report). The report\nreturns a list of columns and corresponding values.\n*/\nfunction _getReport(mappedAnnotations, points, FrameOfReferenceUID) {\n  const columns = [];\n  const values = [];\n\n  // Add Type\n  columns.push('AnnotationType');\n  values.push('Cornerstone:RectangleROI');\n\n  mappedAnnotations.forEach(annotation => {\n    const { mean, stdDev, max, area, unit } = annotation;\n\n    if (!mean || !unit || !max || !area) {\n      return;\n    }\n\n    columns.push(\n      `max (${unit})`,\n      `mean (${unit})`,\n      `std (${unit})`,\n      `area (mm2)`\n    );\n    values.push(max, mean, stdDev, area);\n  });\n\n  if (FrameOfReferenceUID) {\n    columns.push('FrameOfReferenceUID');\n    values.push(FrameOfReferenceUID);\n  }\n\n  if (points) {\n    columns.push('points');\n    // points has the form of [[x1, y1, z1], [x2, y2, z2], ...]\n    // convert it to string of [[x1 y1 z1];[x2 y2 z2];...]\n    // so that it can be used in the csv report\n    values.push(points.map(p => p.join(' ')).join(';'));\n  }\n\n  return {\n    columns,\n    values,\n  };\n}\n\nfunction getDisplayText(mappedAnnotations, displaySet) {\n  if (!mappedAnnotations || !mappedAnnotations.length) {\n    return '';\n  }\n\n  const displayText = [];\n\n  // Area is the same for all series\n  const { area, SOPInstanceUID, frameNumber } = mappedAnnotations[0];\n\n  const instance = displaySet.images.find(\n    image => image.SOPInstanceUID === SOPInstanceUID\n  );\n\n  let InstanceNumber;\n  if (instance) {\n    InstanceNumber = instance.InstanceNumber;\n  }\n\n  const instanceText = InstanceNumber ? ` I: ${InstanceNumber}` : '';\n  const frameText = displaySet.isMultiFrame ? ` F: ${frameNumber}` : '';\n\n  // Area sometimes becomes undefined if `preventHandleOutsideImage` is off.\n  const roundedArea = utils.roundNumber(area || 0, 2);\n  displayText.push(`${roundedArea} mm<sup>2</sup>`);\n\n  // Todo: we need a better UI for displaying all these information\n  mappedAnnotations.forEach(mappedAnnotation => {\n    const { unit, max, SeriesNumber } = mappedAnnotation;\n\n    let maxStr = '';\n    if (max) {\n      const roundedMax = utils.roundNumber(max, 2);\n      maxStr = `Max: ${roundedMax} <small>${unit}</small> `;\n    }\n\n    const str = `${maxStr}(S:${SeriesNumber}${instanceText}${frameText})`;\n    if (!displayText.includes(str)) {\n      displayText.push(str);\n    }\n  });\n\n  return displayText;\n}\n\nexport default RectangleROI;\n","export default [\n  'Length',\n  'EllipticalROI',\n  'CircleROI',\n  'Bidirectional',\n  'ArrowAnnotate',\n  'Angle',\n  'CobbAngle',\n  'Probe',\n  'RectangleROI',\n  'PlanarFreehandROI',\n];\n","import * as measurementMappingUtils from './utils';\n\nexport { measurementMappingUtils };\n","import { MeasurementService } from '@ohif/core';\nimport Length from './Length';\nimport Bidirectional from './Bidirectional';\nimport EllipticalROI from './EllipticalROI';\nimport CircleROI from './CircleROI';\nimport ArrowAnnotate from './ArrowAnnotate';\nimport CobbAngle from './CobbAngle';\nimport Angle from './Angle';\nimport PlanarFreehandROI from './PlanarFreehandROI';\nimport RectangleROI from './RectangleROI';\n\nconst measurementServiceMappingsFactory = (\n  measurementService: MeasurementService,\n  displaySetService,\n  cornerstoneViewportService\n) => {\n  /**\n   * Maps measurement service format object to cornerstone annotation object.\n   *\n   * @param measurement The measurement instance\n   * @param definition The source definition\n   * @return Cornerstone annotation data\n   */\n\n  const _getValueTypeFromToolType = toolType => {\n    const {\n      POLYLINE,\n      ELLIPSE,\n      CIRCLE,\n      RECTANGLE,\n      BIDIRECTIONAL,\n      POINT,\n      ANGLE,\n    } = MeasurementService.VALUE_TYPES;\n\n    // TODO -> I get why this was attempted, but its not nearly flexible enough.\n    // A single measurement may have an ellipse + a bidirectional measurement, for instances.\n    // You can't define a bidirectional tool as a single type..\n    const TOOL_TYPE_TO_VALUE_TYPE = {\n      Length: POLYLINE,\n      EllipticalROI: ELLIPSE,\n      CircleROI: CIRCLE,\n      RectangleROI: RECTANGLE,\n      PlanarFreehandROI: POLYLINE,\n      Bidirectional: BIDIRECTIONAL,\n      ArrowAnnotate: POINT,\n      CobbAngle: ANGLE,\n      Angle: ANGLE,\n    };\n\n    return TOOL_TYPE_TO_VALUE_TYPE[toolType];\n  };\n\n  const factories = {\n    Length: {\n      toAnnotation: Length.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        Length.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n          points: 2,\n        },\n      ],\n    },\n    Bidirectional: {\n      toAnnotation: Bidirectional.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        Bidirectional.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        // TODO -> We should eventually do something like shortAxis + longAxis,\n        // But its still a little unclear how these automatic interpretations will work.\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n          points: 2,\n        },\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n          points: 2,\n        },\n      ],\n    },\n\n    EllipticalROI: {\n      toAnnotation: EllipticalROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        EllipticalROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.ELLIPSE,\n        },\n      ],\n    },\n\n    CircleROI: {\n      toAnnotation: CircleROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        CircleROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.CIRCLE,\n        },\n      ],\n    },\n\n    RectangleROI: {\n      toAnnotation: RectangleROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        RectangleROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n        },\n      ],\n    },\n\n    PlanarFreehandROI: {\n      toAnnotation: PlanarFreehandROI.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        PlanarFreehandROI.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POLYLINE,\n        },\n      ],\n    },\n\n    ArrowAnnotate: {\n      toAnnotation: ArrowAnnotate.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        ArrowAnnotate.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.POINT,\n          points: 1,\n        },\n      ],\n    },\n\n    CobbAngle: {\n      toAnnotation: CobbAngle.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        CobbAngle.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.ANGLE,\n        },\n      ],\n    },\n\n    Angle: {\n      toAnnotation: Angle.toAnnotation,\n      toMeasurement: csToolsAnnotation =>\n        Angle.toMeasurement(\n          csToolsAnnotation,\n          displaySetService,\n          cornerstoneViewportService,\n          _getValueTypeFromToolType\n        ),\n      matchingCriteria: [\n        {\n          valueType: MeasurementService.VALUE_TYPES.ANGLE,\n        },\n      ],\n    },\n  };\n\n  return factories;\n};\n\nexport default measurementServiceMappingsFactory;\n","export default function getHandlesFromPoints(points) {\n  if (points.longAxis && points.shortAxis) {\n    const handles = {};\n    handles.start = points.longAxis[0];\n    handles.end = points.longAxis[1];\n    handles.perpendicularStart = points.longAxis[0];\n    handles.perpendicularEnd = points.longAxis[1];\n    return handles;\n  }\n\n  return points\n    .map((p, i) => (i % 10 === 0 ? { start: p } : { end: p }))\n    .reduce((obj, item) => Object.assign(obj, { ...item }), {});\n}\n","function getModalityUnit(modality) {\n  if (modality === 'CT') {\n    return 'HU';\n  } else if (modality === 'PT') {\n    return 'SUV';\n  } else {\n    return '';\n  }\n}\n\nexport default getModalityUnit;\n","import * as cornerstone from '@cornerstonejs/core';\n\n/**\n * It checks if the imageId is provided then it uses it to query\n * the metadata and get the SOPInstanceUID, SeriesInstanceUID and StudyInstanceUID.\n * If the imageId is not provided then undefined is returned.\n * @param {string} imageId The image id of the referenced image\n * @returns\n */\nexport default function getSOPInstanceAttributes(imageId) {\n  if (imageId) {\n    return _getUIDFromImageID(imageId);\n  }\n\n  // Todo: implement for volume viewports and use the referencedSeriesInstanceUID\n}\n\nfunction _getUIDFromImageID(imageId) {\n  const instance = cornerstone.metaData.get('instance', imageId);\n\n  return {\n    SOPInstanceUID: instance.SOPInstanceUID,\n    SeriesInstanceUID: instance.SeriesInstanceUID,\n    StudyInstanceUID: instance.StudyInstanceUID,\n    frameNumber: instance.frameNumber || 1,\n  };\n}\n","import getHandlesFromPoints from './getHandlesFromPoints';\nimport {\n  isAnnotationSelected,\n  setAnnotationSelected,\n  getFirstAnnotationSelected,\n} from './selection';\nimport getModalityUnit from './getModalityUnit';\nimport getSOPInstanceAttributes from './getSOPInstanceAttributes';\n\nexport {\n  getModalityUnit,\n  getHandlesFromPoints,\n  getSOPInstanceAttributes,\n  isAnnotationSelected,\n  setAnnotationSelected,\n  getFirstAnnotationSelected,\n};\n","import { annotation as cs3dToolAnnotationUtils } from '@cornerstonejs/tools';\n\n/**\n * Check whether an annotation from imaging library is selected or not.\n * @param {string} annotationUID uid of imaging library annotation\n * @returns boolean\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return cs3dToolAnnotationUtils.selection.isAnnotationSelected(annotationUID);\n}\n\n/**\n * Change an annotation from imaging library's selected property.\n * @param annotationUID - uid of imaging library annotation\n * @param selected - new value for selected\n */\nfunction setAnnotationSelected(annotationUID: string, selected: boolean): void {\n  const isCurrentSelected = isAnnotationSelected(annotationUID);\n  // branch cut, avoid invoking imaging library unnecessarily.\n  if (isCurrentSelected !== selected) {\n    cs3dToolAnnotationUtils.selection.setAnnotationSelected(\n      annotationUID,\n      selected\n    );\n  }\n}\n\nfunction getFirstAnnotationSelected(element) {\n  const [selectedAnnotationUID] =\n    cs3dToolAnnotationUtils.selection.getAnnotationsSelected() || [];\n\n  if (selectedAnnotationUID) {\n    return cs3dToolAnnotationUtils.state.getAnnotation(selectedAnnotationUID);\n  }\n}\n\nexport {\n  isAnnotationSelected,\n  setAnnotationSelected,\n  getFirstAnnotationSelected,\n};\n","import { cache, imageLoadPoolManager, Enums } from '@cornerstonejs/core';\nimport getNthFrames from './getNthFrames';\nimport interleave from './interleave';\n\n// Map of volumeId and SeriesInstanceId\nconst volumeIdMapsToLoad = new Map<string, string>();\nconst viewportIdVolumeInputArrayMap = new Map<string, unknown[]>();\n\n/**\n * This function caches the volumeUIDs until all the volumes inside the\n * hanging protocol are initialized. Then it goes through the requests and\n * chooses a sub-selection starting the the first few objects, center objects\n * and last objects, and then the remaining nth images until all instances are\n * retrieved.  This causes the image to have a progressive load order and looks\n * visually much better.\n * @param {Object} props image loading properties from Cornerstone ViewportService\n */\nexport default function interleaveNthLoader({\n  data: { viewportId, volumeInputArray },\n  displaySetsMatchDetails,\n}) {\n  viewportIdVolumeInputArrayMap.set(viewportId, volumeInputArray);\n\n  // Based on the volumeInputs store the volumeIds and SeriesInstanceIds\n  // to keep track of the volumes being loaded\n  for (const volumeInput of volumeInputArray) {\n    const { volumeId } = volumeInput;\n    const volume = cache.getVolume(volumeId);\n\n    if (!volume) {\n      console.log(\"interleaveNthLoader::No volume, can't load it\");\n      return;\n    }\n\n    // if the volumeUID is not in the volumeUIDs array, add it\n    if (!volumeIdMapsToLoad.has(volumeId)) {\n      const { metadata } = volume;\n      volumeIdMapsToLoad.set(volumeId, metadata.SeriesInstanceUID);\n    }\n  }\n\n  const volumeIds = Array.from(volumeIdMapsToLoad.keys()).slice();\n  // get volumes from cache\n  const volumes = volumeIds.map(volumeId => {\n    return cache.getVolume(volumeId);\n  });\n\n  // iterate over all volumes, and get their imageIds, and interleave\n  // the imageIds and save them in AllRequests for later use\n  const originalRequests = volumes\n    .map(volume => volume.getImageLoadRequests())\n    .filter(requests => requests?.[0]?.imageId);\n\n  const orderedRequests = originalRequests.map(request =>\n    getNthFrames(request)\n  );\n\n  // set the finalRequests to the imageLoadPoolManager\n  const finalRequests = interleave(orderedRequests);\n\n  const requestType = Enums.RequestType.Prefetch;\n  const priority = 0;\n\n  finalRequests.forEach(\n    ({ callLoadImage, additionalDetails, imageId, imageIdIndex, options }) => {\n      const callLoadImageBound = callLoadImage.bind(\n        null,\n        imageId,\n        imageIdIndex,\n        options\n      );\n\n      imageLoadPoolManager.addRequest(\n        callLoadImageBound,\n        requestType,\n        additionalDetails,\n        priority\n      );\n    }\n  );\n\n  // clear the volumeIdMapsToLoad\n  volumeIdMapsToLoad.clear();\n\n  // copy the viewportIdVolumeInputArrayMap\n  const viewportIdVolumeInputArrayMapCopy = new Map(\n    viewportIdVolumeInputArrayMap\n  );\n\n  // reset the viewportIdVolumeInputArrayMap\n  viewportIdVolumeInputArrayMap.clear();\n\n  return viewportIdVolumeInputArrayMapCopy;\n}\n","import { Types, getRenderingEngine, utilities } from '@cornerstonejs/core';\n\nexport default function calculateViewportRegistrations(\n  viewports: Types.IViewportId[]\n) {\n  const viewportPairs = _getViewportPairs(viewports);\n\n  for (const [viewport, nextViewport] of viewportPairs) {\n    // check if they are in the same Frame of Reference\n    const renderingEngine1 = getRenderingEngine(viewport.renderingEngineId);\n    const renderingEngine2 = getRenderingEngine(nextViewport.renderingEngineId);\n\n    const csViewport1 = renderingEngine1.getViewport(viewport.viewportId);\n    const csViewport2 = renderingEngine2.getViewport(nextViewport.viewportId);\n\n    utilities.calculateViewportsSpatialRegistration(csViewport1, csViewport2);\n  }\n}\n\nconst _getViewportPairs = (viewports: Types.IViewportId[]) => {\n  const viewportPairs = [];\n\n  for (let i = 0; i < viewports.length; i++) {\n    for (let j = i + 1; j < viewports.length; j++) {\n      viewportPairs.push([viewports[i], viewports[j]]);\n    }\n  }\n\n  return viewportPairs;\n};\n","import calculateViewportRegistrations from './calculateViewportRegistrations';\n\n// [ {\n//   synchronizerId: string,\n//   viewports: [ { viewportId: number, renderingEngineId: string, index: number } , ...]\n// ]}\nlet STACK_IMAGE_SYNC_GROUPS_INFO = [];\n\nexport default function toggleStackImageSync({\n  toggledState,\n  servicesManager,\n  getEnabledElement,\n}) {\n  const {\n    syncGroupService,\n    viewportGridService,\n    displaySetService,\n    cornerstoneViewportService,\n  } = servicesManager.services;\n\n  if (!toggledState) {\n    STACK_IMAGE_SYNC_GROUPS_INFO.forEach(syncGroupInfo => {\n      const { viewports, synchronizerId } = syncGroupInfo;\n\n      viewports.forEach(({ viewportId, renderingEngineId }) => {\n        syncGroupService.removeViewportFromSyncGroup(\n          viewportId,\n          renderingEngineId,\n          synchronizerId\n        );\n      });\n    });\n\n    return;\n  }\n\n  STACK_IMAGE_SYNC_GROUPS_INFO = [];\n\n  // create synchronization groups and add viewports\n  let { viewports } = viewportGridService.getState();\n\n  // filter empty viewports\n  viewports = viewports.filter(\n    viewport =>\n      viewport.displaySetInstanceUIDs && viewport.displaySetInstanceUIDs.length\n  );\n\n  // filter reconstructable viewports\n  viewports = viewports.filter(viewport => {\n    const { displaySetInstanceUIDs } = viewport;\n\n    for (const displaySetInstanceUID of displaySetInstanceUIDs) {\n      const displaySet = displaySetService.getDisplaySetByUID(\n        displaySetInstanceUID\n      );\n\n      if (displaySet && displaySet.isReconstructable) {\n        return true;\n      }\n\n      return false;\n    }\n  });\n\n  const viewportsByOrientation = viewports.reduce((acc, viewport) => {\n    const { viewportId, viewportType } = viewport.viewportOptions;\n\n    if (viewportType !== 'stack') {\n      console.warn('Viewport is not a stack, cannot sync images yet');\n      return acc;\n    }\n\n    const { element } = cornerstoneViewportService.getViewportInfo(viewportId);\n    const { viewport: csViewport, renderingEngineId } = getEnabledElement(\n      element\n    );\n    const { viewPlaneNormal } = csViewport.getCamera();\n\n    // Should we round here? I guess so, but not sure how much precision we need\n    const orientation = viewPlaneNormal.map(v => Math.round(v)).join(',');\n\n    if (!acc[orientation]) {\n      acc[orientation] = [];\n    }\n\n    acc[orientation].push({ viewportId, renderingEngineId });\n\n    return acc;\n  }, {});\n\n  // create synchronizer for each group\n  Object.values(viewportsByOrientation).map(viewports => {\n    let synchronizerId = viewports\n      .map(({ viewportId }) => viewportId)\n      .join(',');\n\n    synchronizerId = `imageSync_${synchronizerId}`;\n\n    calculateViewportRegistrations(viewports);\n\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      syncGroupService.addViewportToSyncGroup(viewportId, renderingEngineId, {\n        type: 'stackimage',\n        id: synchronizerId,\n        source: true,\n        target: true,\n      });\n    });\n\n    STACK_IMAGE_SYNC_GROUPS_INFO.push({\n      synchronizerId,\n      viewports,\n    });\n  });\n}\n","/**\n * It is a bell curved function that uses ease in out quadratic for css\n * transition timing function for each side of the curve.\n *\n * @param {number} x - The current time, in the range [0, 1].\n * @param {number} baseline - The baseline value to start from and return to.\n * @returns the value of the transition at time x.\n */\nexport function easeInOutBell(x: number, baseline: number): number {\n  const alpha = 1 - baseline;\n\n  // prettier-ignore\n  if (x < 1 / 4) {\n    return  4 * Math.pow(2 * x, 3) * alpha + baseline;\n  } else if (x < 1 / 2) {\n    return (1 - Math.pow(-4 * x + 2, 3) / 2) * alpha + baseline;\n  } else if (x < 3 / 4) {\n    return (1 - Math.pow(4 * x - 2, 3) / 2) * alpha + baseline;\n  } else {\n    return (- 4 * Math.pow(2 * x - 2, 3)) * alpha + baseline;\n  }\n}\n\n/**\n * A reversed bell curved function that starts from 1 and goes to baseline and\n * come back to 1 again. It uses ease in out quadratic for css transition\n * timing function for each side of the curve.\n *\n * @param {number} x - The current time, in the range [0, 1].\n * @param {number} baseline - The baseline value to start from and return to.\n * @returns the value of the transition at time x.\n */\nexport function reverseEaseInOutBell(x: number, baseline: number): number {\n  const y = easeInOutBell(x, baseline);\n  return -y + 1 + baseline;\n}\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../../../node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".dicom-upload-drop-area-border-dash {\\n  background-image: repeating-linear-gradient(to right, #7BB2CE 0%, #7BB2CE 50%, transparent 50%, transparent 100%), repeating-linear-gradient(to right, #7BB2CE 0%, #7BB2CE 50%, transparent 50%, transparent 100%), repeating-linear-gradient(to bottom, #7BB2CE 0%, #7BB2CE 50%, transparent 50%, transparent 100%), repeating-linear-gradient(to bottom, #7BB2CE 0%, #7BB2CE 50%, transparent 50%, transparent 100%);\\n  background-position: left top, left bottom, left top, right top;\\n  background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;\\n  background-size: 20px 3px, 20px 3px, 3px 20px, 3px 20px;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n","var api = require(\"!../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./DicomUpload.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./DicomUpload.css\",\n      function () {\n        content = require(\"!!../../../../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[3].use[1]!../../../../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[3].use[2]!./DicomUpload.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};","/* (ignored) */"],"names":[],"sourceRoot":""}